
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>common: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/jmleefree/actiontest2/src/core/common/common.go (100.0%)</option>
				
				<option value="file1">github.com/jmleefree/actiontest2/src/core/common/ns.go (0.0%)</option>
				
				<option value="file2">github.com/jmleefree/actiontest2/src/core/model/cluster.go (20.0%)</option>
				
				<option value="file3">github.com/jmleefree/actiontest2/src/core/model/node.go (20.0%)</option>
				
				<option value="file4">github.com/jmleefree/actiontest2/src/core/model/spider/base.go (37.5%)</option>
				
				<option value="file5">github.com/jmleefree/actiontest2/src/core/model/spider/connection.go (63.6%)</option>
				
				<option value="file6">github.com/jmleefree/actiontest2/src/core/model/spider/region.go (66.7%)</option>
				
				<option value="file7">github.com/jmleefree/actiontest2/src/core/model/status.go (0.0%)</option>
				
				<option value="file8">github.com/jmleefree/actiontest2/src/core/model/tumblebug/base.go (44.4%)</option>
				
				<option value="file9">github.com/jmleefree/actiontest2/src/core/model/tumblebug/firewall.go (33.3%)</option>
				
				<option value="file10">github.com/jmleefree/actiontest2/src/core/model/tumblebug/image.go (33.3%)</option>
				
				<option value="file11">github.com/jmleefree/actiontest2/src/core/model/tumblebug/mcis.go (33.3%)</option>
				
				<option value="file12">github.com/jmleefree/actiontest2/src/core/model/tumblebug/ns.go (71.4%)</option>
				
				<option value="file13">github.com/jmleefree/actiontest2/src/core/model/tumblebug/spec.go (42.1%)</option>
				
				<option value="file14">github.com/jmleefree/actiontest2/src/core/model/tumblebug/sshkey.go (42.1%)</option>
				
				<option value="file15">github.com/jmleefree/actiontest2/src/core/model/tumblebug/tvm.go (0.0%)</option>
				
				<option value="file16">github.com/jmleefree/actiontest2/src/core/model/tumblebug/vpc.go (33.3%)</option>
				
				<option value="file17">github.com/jmleefree/actiontest2/src/core/model/vm.go (63.0%)</option>
				
				<option value="file18">github.com/jmleefree/actiontest2/src/core/service/common.go (84.8%)</option>
				
				<option value="file19">github.com/jmleefree/actiontest2/src/core/service/csp.go (19.5%)</option>
				
				<option value="file20">github.com/jmleefree/actiontest2/src/core/service/mcir.go (84.1%)</option>
				
				<option value="file21">github.com/jmleefree/actiontest2/src/grpc-api/cbadm/cmd/cluster.go (0.0%)</option>
				
				<option value="file22">github.com/jmleefree/actiontest2/src/grpc-api/cbadm/cmd/config.go (0.0%)</option>
				
				<option value="file23">github.com/jmleefree/actiontest2/src/grpc-api/cbadm/cmd/connectinfo.go (0.0%)</option>
				
				<option value="file24">github.com/jmleefree/actiontest2/src/grpc-api/cbadm/cmd/credential.go (0.0%)</option>
				
				<option value="file25">github.com/jmleefree/actiontest2/src/grpc-api/cbadm/cmd/driver.go (0.0%)</option>
				
				<option value="file26">github.com/jmleefree/actiontest2/src/grpc-api/cbadm/cmd/gclient.go (0.0%)</option>
				
				<option value="file27">github.com/jmleefree/actiontest2/src/grpc-api/cbadm/cmd/healthy.go (0.0%)</option>
				
				<option value="file28">github.com/jmleefree/actiontest2/src/grpc-api/cbadm/cmd/image.go (0.0%)</option>
				
				<option value="file29">github.com/jmleefree/actiontest2/src/grpc-api/cbadm/cmd/keypair.go (0.0%)</option>
				
				<option value="file30">github.com/jmleefree/actiontest2/src/grpc-api/cbadm/cmd/mcis.go (0.0%)</option>
				
				<option value="file31">github.com/jmleefree/actiontest2/src/grpc-api/cbadm/cmd/namespace.go (0.0%)</option>
				
				<option value="file32">github.com/jmleefree/actiontest2/src/grpc-api/cbadm/cmd/network.go (0.0%)</option>
				
				<option value="file33">github.com/jmleefree/actiontest2/src/grpc-api/cbadm/cmd/node.go (0.0%)</option>
				
				<option value="file34">github.com/jmleefree/actiontest2/src/grpc-api/cbadm/cmd/region.go (0.0%)</option>
				
				<option value="file35">github.com/jmleefree/actiontest2/src/grpc-api/cbadm/cmd/root.go (0.0%)</option>
				
				<option value="file36">github.com/jmleefree/actiontest2/src/grpc-api/cbadm/cmd/securitygroup.go (0.0%)</option>
				
				<option value="file37">github.com/jmleefree/actiontest2/src/grpc-api/cbadm/cmd/spec.go (0.0%)</option>
				
				<option value="file38">github.com/jmleefree/actiontest2/src/grpc-api/cbadm/cmd/tbutil.go (0.0%)</option>
				
				<option value="file39">github.com/jmleefree/actiontest2/src/grpc-api/cbadm/cmd/version.go (0.0%)</option>
				
				<option value="file40">github.com/jmleefree/actiontest2/src/grpc-api/cbadm/proc/connectinfos.go (0.0%)</option>
				
				<option value="file41">github.com/jmleefree/actiontest2/src/grpc-api/cbadm/proc/keypair.go (0.0%)</option>
				
				<option value="file42">github.com/jmleefree/actiontest2/src/grpc-api/cbadm/proc/mcis.go (0.0%)</option>
				
				<option value="file43">github.com/jmleefree/actiontest2/src/grpc-api/common/cbconnection.go (0.0%)</option>
				
				<option value="file44">github.com/jmleefree/actiontest2/src/grpc-api/common/cbmessage.go (45.9%)</option>
				
				<option value="file45">github.com/jmleefree/actiontest2/src/grpc-api/common/cbserver.go (34.8%)</option>
				
				<option value="file46">github.com/jmleefree/actiontest2/src/grpc-api/common/grpcstatuserr.go (0.0%)</option>
				
				<option value="file47">github.com/jmleefree/actiontest2/src/grpc-api/config/config.go (23.9%)</option>
				
				<option value="file48">github.com/jmleefree/actiontest2/src/grpc-api/config/parser.go (37.5%)</option>
				
				<option value="file49">github.com/jmleefree/actiontest2/src/grpc-api/interceptors/accesslog/client_interceptors.go (0.0%)</option>
				
				<option value="file50">github.com/jmleefree/actiontest2/src/grpc-api/interceptors/accesslog/server_interceptors.go (55.0%)</option>
				
				<option value="file51">github.com/jmleefree/actiontest2/src/grpc-api/interceptors/authjwt/auth.go (0.0%)</option>
				
				<option value="file52">github.com/jmleefree/actiontest2/src/grpc-api/interceptors/authjwt/client_interceptors.go (0.0%)</option>
				
				<option value="file53">github.com/jmleefree/actiontest2/src/grpc-api/interceptors/authjwt/server_interceptors.go (0.0%)</option>
				
				<option value="file54">github.com/jmleefree/actiontest2/src/grpc-api/interceptors/jaegertracer/jaegertracer.go (0.0%)</option>
				
				<option value="file55">github.com/jmleefree/actiontest2/src/grpc-api/logger/logger.go (33.3%)</option>
				
				<option value="file56">github.com/jmleefree/actiontest2/src/grpc-api/request/mcar/cluster.go (18.8%)</option>
				
				<option value="file57">github.com/jmleefree/actiontest2/src/grpc-api/request/mcar/healthy.go (0.0%)</option>
				
				<option value="file58">github.com/jmleefree/actiontest2/src/grpc-api/request/mcar/node.go (0.0%)</option>
				
				<option value="file59">github.com/jmleefree/actiontest2/src/grpc-api/request/mcarapi.go (19.8%)</option>
				
				<option value="file60">github.com/jmleefree/actiontest2/src/grpc-api/server/mcar/cluster.go (27.8%)</option>
				
				<option value="file61">github.com/jmleefree/actiontest2/src/grpc-api/server/mcar/healthy.go (0.0%)</option>
				
				<option value="file62">github.com/jmleefree/actiontest2/src/grpc-api/server/mcar/mcar.go (37.5%)</option>
				
				<option value="file63">github.com/jmleefree/actiontest2/src/grpc-api/server/mcar/node.go (0.0%)</option>
				
				<option value="file64">github.com/jmleefree/actiontest2/src/rest-api/router/cluster.go (28.9%)</option>
				
				<option value="file65">github.com/jmleefree/actiontest2/src/rest-api/router/healthy.go (0.0%)</option>
				
				<option value="file66">github.com/jmleefree/actiontest2/src/rest-api/router/node.go (0.0%)</option>
				
				<option value="file67">github.com/jmleefree/actiontest2/src/rest-api/service/cluster.go (62.1%)</option>
				
				<option value="file68">github.com/jmleefree/actiontest2/src/rest-api/service/node.go (0.0%)</option>
				
				<option value="file69">github.com/jmleefree/actiontest2/src/utils/app/ack.go (36.0%)</option>
				
				<option value="file70">github.com/jmleefree/actiontest2/src/utils/app/client.go (100.0%)</option>
				
				<option value="file71">github.com/jmleefree/actiontest2/src/utils/config/config.go (0.0%)</option>
				
				<option value="file72">github.com/jmleefree/actiontest2/src/utils/lang/functions.go (60.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package common

import (
        cbstore "github.com/cloud-barista/cb-store"
        icbs "github.com/cloud-barista/cb-store/interfaces"
)

var CBStore icbs.Store

func init() <span class="cov8" title="1">{
        // cblog is a global variable.
        CBStore = cbstore.GetStore()
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package common

import (
        "net/http"

        "github.com/labstack/echo/v4"
)

func NsValidate() echo.MiddlewareFunc <span class="cov0" title="0">{
        return func(next echo.HandlerFunc) echo.HandlerFunc </span><span class="cov0" title="0">{
                return func(c echo.Context) error </span><span class="cov0" title="0">{
                        ns := c.Param("namespace")
                        if ns == "" </span><span class="cov0" title="0">{
                                return echo.NewHTTPError(http.StatusUnauthorized, "Namespace cannot be empty")
                        }</span>
                        <span class="cov0" title="0">return next(c)</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package model

import (
        "encoding/json"
        "errors"
        "fmt"
        "strings"

        "github.com/jmleefree/actiontest2/src/core/common"
        "github.com/jmleefree/actiontest2/src/utils/lang"
)

const (
        STATUS_CREATED      = "created"
        STATUS_PROVISIONING = "provisioning"
        STATUS_COMPLETED    = "completed"
        STATUS_FAILED       = "failed"
)

type Cluster struct {
        Model
        Status        string `json:"status"`
        UId           string `json:"uid"`
        MCIS          string `json:"mcis"`
        Namespace     string `json:"namespace"`
        ClusterConfig string `json:"clusterConfig"`
        CpLeader      string `json:"cpLeader"`
        NetworkCni    string `json:"networkCni"`
        Nodes         []Node `json:"nodes"`
}

type ClusterList struct {
        ListModel
        namespace string
        Items     []Cluster `json:"items"`
}

func NewCluster(namespace string, name string) *Cluster <span class="cov8" title="1">{
        return &amp;Cluster{
                Model:     Model{Kind: KIND_CLUSTER, Name: name},
                Namespace: namespace,
                Nodes:     []Node{},
        }
}</span>

func NewClusterList(namespace string) *ClusterList <span class="cov0" title="0">{
        return &amp;ClusterList{
                ListModel: ListModel{Kind: KIND_CLUSTER_LIST},
                namespace: namespace,
                Items:     []Cluster{},
        }
}</span>

func (self *Cluster) Insert() error <span class="cov8" title="1">{
        self.Status = STATUS_CREATED
        return self.putStore()
}</span>

func (self *Cluster) Update() error <span class="cov8" title="1">{
        self.Status = STATUS_PROVISIONING
        return self.putStore()
}</span>

func (self *Cluster) Complete() error <span class="cov8" title="1">{
        self.Status = STATUS_COMPLETED
        return self.putStore()
}</span>

func (self *Cluster) Fail() error <span class="cov0" title="0">{
        self.Status = STATUS_FAILED
        return self.putStore()
}</span>

func (self *Cluster) putStore() error <span class="cov8" title="1">{
        key := lang.GetStoreClusterKey(self.Namespace, self.Name)
        value, _ := json.Marshal(self)
        err := common.CBStore.Put(key, string(value))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (self *Cluster) Select() error <span class="cov0" title="0">{
        key := lang.GetStoreClusterKey(self.Namespace, self.Name)
        keyValue, err := common.CBStore.Get(key)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if keyValue == nil </span><span class="cov0" title="0">{
                return errors.New(fmt.Sprintf("%s not found", key))
        }</span>
        <span class="cov0" title="0">json.Unmarshal([]byte(keyValue.Value), &amp;self)

        err = getClusterNodes(self)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (self *Cluster) Delete() error <span class="cov0" title="0">{
        // delete node
        keyValues, err := common.CBStore.GetList(lang.GetStoreNodeKey(self.Namespace, self.Name, ""), true)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">for _, keyValue := range keyValues </span><span class="cov0" title="0">{
                err = common.CBStore.Delete(keyValue.Key)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // delete cluster
        <span class="cov0" title="0">key := lang.GetStoreClusterKey(self.Namespace, self.Name)
        err = common.CBStore.Delete(key)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (self *ClusterList) SelectList() error <span class="cov0" title="0">{
        keyValues, err := common.CBStore.GetList(lang.GetStoreClusterKey(self.namespace, ""), true)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">self.Items = []Cluster{}
        for _, keyValue := range keyValues </span><span class="cov0" title="0">{
                if !strings.Contains(keyValue.Key, "/nodes") </span><span class="cov0" title="0">{
                        cluster := &amp;Cluster{}
                        json.Unmarshal([]byte(keyValue.Value), &amp;cluster)

                        err = getClusterNodes(cluster)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">self.Items = append(self.Items, *cluster)</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

func getClusterNodes(cluster *Cluster) error <span class="cov0" title="0">{
        nodeKeyValues, err := common.CBStore.GetList(lang.GetStoreNodeKey(cluster.Namespace, cluster.Name, ""), true)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">for _, nodeKeyValue := range nodeKeyValues </span><span class="cov0" title="0">{
                node := &amp;Node{}
                json.Unmarshal([]byte(nodeKeyValue.Value), &amp;node)
                cluster.Nodes = append(cluster.Nodes, *node)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package model

import (
        "encoding/json"
        "errors"
        "fmt"

        "github.com/jmleefree/actiontest2/src/core/common"
        "github.com/jmleefree/actiontest2/src/utils/config"
        "github.com/jmleefree/actiontest2/src/utils/lang"
)

type Node struct {
        Model
        namespace   string
        clusterName string
        Credential  string     `json:"credential"`
        PublicIP    string     `json:"publicIp"`
        UId         string     `json:"uid"`
        Role        string     `json:"role"`
        Spec        string     `json:"spec"`
        Csp         config.CSP `json:"csp"`
}

type NodeList struct {
        ListModel
        namespace   string
        clusterName string
        Items       []Node `json:"items"`
}

func NewNodeVM(namespace string, clusterName string, vm VM) *Node <span class="cov8" title="1">{
        return &amp;Node{
                Model:       Model{Kind: KIND_NODE, Name: vm.Name},
                Credential:  vm.Credential,
                PublicIP:    vm.PublicIP,
                UId:         vm.UId,
                Role:        vm.Role,
                Spec:        vm.Spec,
                Csp:         vm.Csp,
                namespace:   namespace,
                clusterName: clusterName,
        }
}</span>

func NewNode(namespace string, clusterName string, nodeName string) *Node <span class="cov0" title="0">{
        return &amp;Node{
                Model:       Model{Kind: KIND_NODE, Name: nodeName},
                namespace:   namespace,
                clusterName: clusterName,
        }
}</span>

func NewNodeList(namespace string, clusterName string) *NodeList <span class="cov0" title="0">{
        return &amp;NodeList{
                ListModel:   ListModel{Kind: KIND_NODE_LIST},
                Items:       []Node{},
                namespace:   namespace,
                clusterName: clusterName,
        }
}</span>

func (self *Node) Select() error <span class="cov0" title="0">{
        key := lang.GetStoreNodeKey(self.namespace, self.clusterName, self.Name)
        keyValue, err := common.CBStore.Get(key)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if keyValue == nil </span><span class="cov0" title="0">{
                return errors.New(fmt.Sprintf("%s not found", key))
        }</span>

        <span class="cov0" title="0">json.Unmarshal([]byte(keyValue.Value), &amp;self)
        return nil</span>
}

func (self *Node) Insert() error <span class="cov8" title="1">{
        key := lang.GetStoreNodeKey(self.namespace, self.clusterName, self.Name)
        value, _ := json.Marshal(self)
        err := common.CBStore.Put(key, string(value))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (self *Node) Delete() error <span class="cov0" title="0">{
        key := lang.GetStoreNodeKey(self.namespace, self.clusterName, self.Name)
        err := common.CBStore.Delete(key)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (self *NodeList) SelectList() error <span class="cov0" title="0">{
        keyValues, err := common.CBStore.GetList(lang.GetStoreNodeKey(self.namespace, self.clusterName, ""), true)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">for _, keyValue := range keyValues </span><span class="cov0" title="0">{
                node := &amp;Node{}
                json.Unmarshal([]byte(keyValue.Value), &amp;node)
                self.Items = append(self.Items, *node)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package spider

import (
        "encoding/json"
        "errors"
        "net/http"

        "github.com/go-resty/resty/v2"
        "github.com/jmleefree/actiontest2/src/core/model"

        logger "github.com/sirupsen/logrus"
)

type Model struct {
}

// 결과 처리
func (m *Model) response(resp *resty.Response, err error) error <span class="cov8" title="1">{
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if resp.StatusCode() &gt; 300 &amp;&amp; resp.StatusCode() != http.StatusNotFound </span><span class="cov0" title="0">{
                logger.Warnf("Spider : statusCode=%d, url=%s, body=%s", resp.StatusCode(), resp.Request.URL, resp)
                status := model.Status{}
                json.Unmarshal(resp.Body(), &amp;status)
                return errors.New(status.Message)
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package spider

import (
        "fmt"
        "net/http"

        "github.com/jmleefree/actiontest2/src/utils/app"
        "github.com/jmleefree/actiontest2/src/utils/config"
        logger "github.com/sirupsen/logrus"
)

// connection config
type Connection struct {
        Model
        ConfigName     string `json:"ConfigName"`
        ProviderName   string `json:"ProviderName"`
        DriverName     string `json:"DriverName"`
        CredentialName string `json:"CredentialName"`
        RegionName     string `json:"RegionName"`
}

func NewConnection(name string) *Connection <span class="cov8" title="1">{
        return &amp;Connection{
                Model:      Model{},
                ConfigName: name,
        }
}</span>

// get connection config
func (self *Connection) GET() (bool, error) <span class="cov8" title="1">{

        url := fmt.Sprintf("%s/connectionconfig/%s", *config.Config.SpiderUrl, self.ConfigName)
        resp, err := app.ExecutHTTP(http.MethodGet, url, nil, &amp;self)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">if err = self.response(resp, err); err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">if resp.StatusCode() == http.StatusNotFound </span><span class="cov0" title="0">{
                logger.Infof("Not found data (status=404, method=%s, url=%s)", http.MethodGet, url)
                return false, nil
        }</span>

        <span class="cov8" title="1">return true, nil</span>

}
</pre>
		
		<pre class="file" id="file6" style="display: none">package spider

import (
        "fmt"
        "net/http"

        "github.com/jmleefree/actiontest2/src/utils/app"
        "github.com/jmleefree/actiontest2/src/utils/config"
        logger "github.com/sirupsen/logrus"
)

type Region struct {
        Model
        RegionName       string     `json:"RegionName"`
        ProviderName     string     `json:"ProviderName"`
        KeyValueInfoList []KeyValue `json:"KeyValueInfoList"`
}

type KeyValue struct {
        Key   string
        Value string
}

func NewRegion(name string) *Region <span class="cov8" title="1">{
        return &amp;Region{
                Model:      Model{},
                RegionName: name,
        }
}</span>

// get region
func (self *Region) GET() (bool, error) <span class="cov8" title="1">{

        url := fmt.Sprintf("%s/region/%s", *config.Config.SpiderUrl, self.RegionName)
        resp, err := app.ExecutHTTP(http.MethodGet, url, nil, &amp;self)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">if resp.StatusCode() == http.StatusNotFound </span><span class="cov0" title="0">{
                logger.Warnf("Not found data (status=404, method=%s, url=%s)", http.MethodGet, url)
                return false, nil
        }</span>

        <span class="cov8" title="1">return true, nil</span>

}
</pre>
		
		<pre class="file" id="file7" style="display: none">package model

const (
        STATUS_UNKNOWN   = 0
        STATUS_SUCCESS   = 1
        STATUS_NOT_EXIST = 404
        // STATUS_OK        = 200
        // STATUS_FAIL      = 500
)

type Status struct {
        Kind    string `json:"kind"`
        Code    int    `json:"code"`
        Message string `json:"message"`
}

func NewStatus() *Status <span class="cov0" title="0">{
        return &amp;Status{
                Kind: KIND_STATUS,
        }
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package tumblebug

import (
        "encoding/json"
        "errors"
        "fmt"
        "net/http"

        "github.com/beego/beego/v2/core/validation"
        "github.com/go-resty/resty/v2"
        "github.com/jmleefree/actiontest2/src/core/model"
        "github.com/jmleefree/actiontest2/src/utils/app"
        "github.com/jmleefree/actiontest2/src/utils/config"

        logger "github.com/sirupsen/logrus"
)

type KeyValue struct {
        Key   string
        Value string
}

type Model struct {
        Name      string `json:"name"`
        namespace string
}

func (self *Model) execute(method string, url string, body interface{}, result interface{}) (bool, error) <span class="cov8" title="1">{

        // validation
        if err := self.validate(validation.Validation{}); err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov8" title="1">resp, err := app.ExecutHTTP(method, *config.Config.TumblebugUrl+url, body, result)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        // response check
        <span class="cov8" title="1">if resp.StatusCode() &gt; 300 &amp;&amp; resp.StatusCode() != http.StatusNotFound </span><span class="cov0" title="0">{
                logger.Warnf("Tumblebug : statusCode=%d, url=%s, body=%s", resp.StatusCode(), resp.Request.URL, resp)
                status := model.Status{}
                json.Unmarshal(resp.Body(), &amp;status)
                // message &gt; message 로 리턴되는 경우가 있어서 한번더 unmarshal 작업
                if json.Valid([]byte(status.Message)) </span><span class="cov0" title="0">{
                        json.Unmarshal([]byte(status.Message), &amp;status)
                }</span>
                <span class="cov0" title="0">return false, errors.New(status.Message)</span>
        }

        <span class="cov8" title="1">if method == http.MethodGet &amp;&amp; resp.StatusCode() == http.StatusNotFound </span><span class="cov8" title="1">{
                logger.Infof("Not found data (status=404, method=%s, url=%s)", method, url)
                return false, nil
        }</span>

        <span class="cov8" title="1">return true, nil</span>

}

// // 결과 처리
// func (self *Model) response(resp *resty.Response, err error) error {
//         if err != nil {
//                 return err
//         }
//         if resp.StatusCode() &gt; 300 &amp;&amp; resp.StatusCode() != http.StatusNotFound {
//                 logger.Warnf("statusCode=%d, url=%s, body=%s", resp.StatusCode(), resp.Request.URL, resp)
//                 status := model.Status{}
//                 json.Unmarshal(resp.Body(), &amp;status)
//                 // message &gt; message 로 리턴되는 경우가 있어서 한번더 unmarshal 작업
//                 if json.Valid([]byte(status.Message)) {
//                         json.Unmarshal([]byte(status.Message), &amp;status)
//                 }
//                 return errors.New(status.Message)

//         }
//         return nil
// }

func (self *Model) validate(valid validation.Validation) error <span class="cov8" title="1">{
        valid.Required(self.namespace, "namespace")
        valid.Required(self.Name, "name")
        if valid.HasErrors() </span><span class="cov0" title="0">{
                for _, err := range valid.Errors </span><span class="cov0" title="0">{
                        return errors.New(fmt.Sprintf("[%s]%s", err.Key, err.Error()))
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// status :200 , body = {message: "Cannot find ..." }  형태의 response 에러처리
func (self *Model) hasResponseMessage(resp *resty.Response) error <span class="cov0" title="0">{
        var d map[string]interface{}
        json.Unmarshal(resp.Body(), &amp;d)
        if d["message"] != nil </span><span class="cov0" title="0">{
                return errors.New(fmt.Sprintf("%s", d["message"]))
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package tumblebug

import (
        "fmt"
        "net/http"

        "github.com/jmleefree/actiontest2/src/core/model"
        logger "github.com/sirupsen/logrus"
)

type Firewall struct {
        Model
        Config               string          `json:"connectionName"`
        VPCId                string          `json:"vNetId"`
        Description          string          `json:"description"`
        FirewallRules        []FirewallRules `json:"firewallRules"`
        CspSecurityGroupId   string          `json:"cspSecurityGroupId"`   // output
        CspSecurityGroupName string          `json:"cspSecurityGroupName"` // output
        KeyValueList         []KeyValue      `json:"keyValueList"`         // output
}

type FirewallRules struct {
        From      string `json:"fromPort"`
        To        string `json:"toPort"`
        Protocol  string `json:"ipProtocol"`
        Direction string `json:"direction"`
}

func NewFirewall(ns string, name string, conf string) *Firewall <span class="cov8" title="1">{
        return &amp;Firewall{
                Model:  Model{Name: name, namespace: ns},
                Config: conf,
                FirewallRules: []FirewallRules{
                        {Protocol: "tcp", Direction: "inbound", From: "1", To: "65535"},
                        {Protocol: "udp", Direction: "inbound", From: "1", To: "65535"},
                        {Protocol: "icmp", Direction: "inbound", From: "-1", To: "-1"},
                },
        }
}</span>

func (self *Firewall) GET() (bool, error) <span class="cov8" title="1">{

        return self.execute(http.MethodGet, fmt.Sprintf("/ns/%s/resources/securityGroup/%s", self.namespace, self.Name), fmt.Sprintf(`{"connectionName" : "%s"}`, self.Config), &amp;self)

}</span>

func (self *Firewall) POST() error <span class="cov8" title="1">{

        _, err := self.execute(http.MethodPost, fmt.Sprintf("/ns/%s/resources/securityGroup", self.namespace), self, &amp;self)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (self *Firewall) DELETE(ns string) error <span class="cov0" title="0">{

        exist, err := self.GET()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if exist </span><span class="cov0" title="0">{
                _, err := self.execute(http.MethodDelete, fmt.Sprintf("/ns/%s/resources/securityGroup/%s", self.namespace, self.Name), fmt.Sprintf(`{"connectionName" : "%s"}`, self.Config), model.Status{})
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov0" title="0"> {
                logger.Infof("delete firewall skip (name=%s, cause=not found)", self.Name)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package tumblebug

import (
        "fmt"
        "net/http"

        "github.com/jmleefree/actiontest2/src/core/model"
        logger "github.com/sirupsen/logrus"
)

type Image struct {
        Model
        Config       string     `json:"connectionName"`
        CspImageId   string     `json:"cspImageId"`
        CspImageName string     `json:"cspImageName"` // output
        CreationDate string     `json:"creationDate"` // output
        Description  string     `json:"description"`  //
        GuestOS      string     `json:"guestOS"`      //
        Status       string     `json:"status"`       // output
        KeyValueList []KeyValue `json:"keyValueList"` // output
}

func NewImage(ns string, name string, conf string) *Image <span class="cov8" title="1">{
        return &amp;Image{
                Model:        Model{Name: name, namespace: ns},
                Config:       conf,
                CspImageName: "Ubuntu, 18.04",
                Description:  "Canonical, Ubuntu, 18.04 LTS, amd64 bionic",
                GuestOS:      "ubuntu",
                KeyValueList: []KeyValue{},
        }
}</span>

func (self *Image) GET() (bool, error) <span class="cov8" title="1">{

        return self.execute(http.MethodGet, fmt.Sprintf("/ns/%s/resources/image/%s", self.namespace, self.Name), fmt.Sprintf(`{"connectionName" : "%s"}`, self.Config), &amp;self)
}</span>

func (self *Image) POST() error <span class="cov8" title="1">{

        _, err := self.execute(http.MethodPost, fmt.Sprintf("/ns/%s/resources/image?action=registerWithInfo", self.namespace), self, &amp;self)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (self *Image) DELETE(ns string) error <span class="cov0" title="0">{

        exist, err := self.GET()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if exist </span><span class="cov0" title="0">{
                _, err := self.execute(http.MethodDelete, fmt.Sprintf("/ns/%s/resources/image/%s", self.namespace, self.Name), fmt.Sprintf(`{"connectionName" : "%s"}`, self.Config), model.Status{})
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov0" title="0"> {
                logger.Infof("delete image skip (name=%s, cause=not found)", self.Name)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package tumblebug

import (
        "fmt"
        "net/http"

        "github.com/jmleefree/actiontest2/src/core/model"

        logger "github.com/sirupsen/logrus"
)

type MCIS struct {
        Model
        Description string     `json:"description"`
        VMs         []model.VM `json:"vm"` // output
}

func NewMCIS(ns string, name string) *MCIS <span class="cov8" title="1">{
        return &amp;MCIS{
                Model: Model{Name: name, namespace: ns},
                VMs:   []model.VM{},
        }
}</span>

func (self *MCIS) GET() (bool, error) <span class="cov8" title="1">{

        return self.execute(http.MethodGet, fmt.Sprintf("/ns/%s/mcis/%s", self.namespace, self.Name), nil, &amp;self)

        // if err = self.hasResponseMessage(resp); err != nil {
        //         // 이부분은 향후 tumblebug 에서 수정해야 할듯
        //         if strings.HasPrefix(err.Error(), "Cannot find") {
        //                 return false, nil
        //         } else {
        //                 return false, err
        //         }
        // }
}</span>

func (self *MCIS) POST() error <span class="cov8" title="1">{

        _, err := self.execute(http.MethodPost, fmt.Sprintf("/ns/%s/mcis", self.namespace), self, &amp;self)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (self *MCIS) DELETE() error <span class="cov0" title="0">{

        exist, err := self.GET()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if exist </span><span class="cov0" title="0">{
                _, err := self.execute(http.MethodDelete, fmt.Sprintf("/ns/%s/mcis/%s", self.namespace, self.Name), nil, model.Status{})
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov0" title="0"> {
                logger.Infof("delete MCIS skip (name=%s, cause=not found)", self.Name)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package tumblebug

import (
        "fmt"
        "net/http"

        "github.com/jmleefree/actiontest2/src/utils/app"
        "github.com/jmleefree/actiontest2/src/utils/config"
)

type NS struct {
        ID          string `json:"id"`
        Name        string `json:"name"`
        Description string `json:"description"`
}

func NewNS(ns string) *NS <span class="cov8" title="1">{
        return &amp;NS{
                Name: ns,
                ID:   ns,
        }
}</span>

func (self *NS) GET() (bool, error) <span class="cov8" title="1">{

        resp, err := app.ExecutHTTP(http.MethodGet, fmt.Sprintf("%s/ns/%s", *config.Config.TumblebugUrl, self.Name), nil, &amp;self)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">if resp.StatusCode() == http.StatusNotFound </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        <span class="cov8" title="1">return true, nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package tumblebug

import (
        "fmt"
        "net/http"

        "github.com/beego/beego/v2/core/validation"
        "github.com/jmleefree/actiontest2/src/core/model"

        logger "github.com/sirupsen/logrus"
)

type Spec struct {
        Model
        Config      string `json:"connectionName"`
        CspSpecName string `json:"cspSpecName"`
        Role        string `json:"role"`
}

func NewSpec(ns string, name string, conf string) *Spec <span class="cov8" title="1">{
        return &amp;Spec{
                Model:  Model{Name: name, namespace: ns},
                Config: conf,
        }
}</span>

func (self *Spec) GET() (bool, error) <span class="cov8" title="1">{

        return self.execute(http.MethodGet, fmt.Sprintf("/ns/%s/resources/spec/%s", self.namespace, self.Name), fmt.Sprintf(`{"connectionName" : "%s"}`, self.Config), &amp;self)

}</span>

func (self *Spec) POST() error <span class="cov8" title="1">{

        // validation
        valid := validation.Validation{}
        valid.Required(self.CspSpecName, "cspSpecName")
        if err := self.validate(valid); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">_, err := self.execute(http.MethodPost, fmt.Sprintf("/ns/%s/resources/spec", self.namespace), self, &amp;self)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>

}

func (self *Spec) DELETE(ns string) error <span class="cov0" title="0">{

        exist, err := self.GET()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if exist </span><span class="cov0" title="0">{
                _, err := self.execute(http.MethodDelete, fmt.Sprintf("/ns/%s/resources/spec/%s", self.namespace, self.Name), fmt.Sprintf(`{"connectionName" : "%s"}`, self.Config), model.Status{})
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

        } else<span class="cov0" title="0"> {
                logger.Infof("delete spec skip.. (name=%s, cause=not found)", self.Name)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package tumblebug

import (
        "fmt"
        "net/http"

        "github.com/beego/beego/v2/core/validation"
        "github.com/jmleefree/actiontest2/src/core/model"

        logger "github.com/sirupsen/logrus"
)

type SSHKey struct {
        Model
        Config     string `json:"connectionName"`
        Username   string `json:"username"`
        PrivateKey string `json:"privateKey"` // output
}

func NewSSHKey(ns string, name string, conf string) *SSHKey <span class="cov8" title="1">{
        return &amp;SSHKey{
                Model:  Model{Name: name, namespace: ns},
                Config: conf,
        }
}</span>

func (self *SSHKey) GET() (bool, error) <span class="cov8" title="1">{

        return self.execute(http.MethodGet, fmt.Sprintf("/ns/%s/resources/sshKey/%s", self.namespace, self.Name), fmt.Sprintf(`{"connectionName" : "%s"}`, self.Config), &amp;self)

}</span>

func (self *SSHKey) POST() error <span class="cov8" title="1">{
        // validation
        valid := validation.Validation{}
        valid.Required(self.Username, "username")
        if err := self.validate(valid); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">_, err := self.execute(http.MethodPost, fmt.Sprintf("/ns/%s/resources/sshKey", self.namespace), self, &amp;self)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>

}

func (self *SSHKey) DELETE(ns string) error <span class="cov0" title="0">{

        exist, err := self.GET()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if exist </span><span class="cov0" title="0">{
                _, err := self.execute(http.MethodDelete, fmt.Sprintf("/ns/%s/resources/sshKey/%s", self.namespace, self.Name), fmt.Sprintf(`{"connectionName" : "%s"}`, self.Config), model.Status{})
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov0" title="0"> {
                logger.Infof("delete sshkey skip (name=%s, cause=not found)", self.Name)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package tumblebug

import (
        "fmt"
        "net/http"

        "github.com/jmleefree/actiontest2/src/core/model"

        logger "github.com/sirupsen/logrus"
)

type TVM struct {
        Model
        VM model.VM
}

func NewTVm(ns string, mcisName string) *TVM <span class="cov0" title="0">{
        return &amp;TVM{
                Model: Model{namespace: ns, Name: mcisName},
        }
}</span>

func (self *TVM) GET() (bool, error) <span class="cov0" title="0">{

        return self.execute(http.MethodGet, fmt.Sprintf("/ns/%s/mcis/%s/vm/%s", self.namespace, self.Name, self.VM.Name), nil, &amp;self.VM)

}</span>

func (self *TVM) POST() error <span class="cov0" title="0">{

        _, err := self.execute(http.MethodPost, fmt.Sprintf("/ns/%s/mcis/%s/vm", self.namespace, self.Name), self.VM, &amp;self.VM)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>

}

func (self *TVM) DELETE() error <span class="cov0" title="0">{

        exist, err := self.GET()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if exist </span><span class="cov0" title="0">{
                _, err := self.execute(http.MethodDelete, fmt.Sprintf("/ns/%s/mcis/%s/vm/%s", self.namespace, self.Name, self.VM.Name), nil, model.Status{})
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov0" title="0"> {
                logger.Infof("delete VM skip (name=%s, cause=not found)", self.VM.Name)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package tumblebug

import (
        "fmt"
        "net/http"

        "github.com/jmleefree/actiontest2/src/core/model"
        logger "github.com/sirupsen/logrus"
)

type VPC struct {
        Model
        Config       string     `json:"connectionName"`
        CidrBlock    string     `json:"cidrBlock"`
        Subnets      []Subnet   `json:"subnetInfoList"`
        Description  string     `json:"description"`
        CspVNetId    string     `json:"cspVNetId"`    // output
        CspVNetName  string     `json:"cspVNetName"`  // output
        Status       string     `json:"status"`       // output
        KeyValueList []KeyValue `json:"keyValueList"` // output
}

type Subnet struct {
        Name      string `json:"Name"`
        CidrBlock string `json:"IPv4_CIDR"`
}

func NewVPC(ns string, name string, conf string) *VPC <span class="cov8" title="1">{
        return &amp;VPC{
                Model:     Model{Name: name, namespace: ns},
                Config:    conf,
                CidrBlock: "192.168.0.0/16",
                Subnets: []Subnet{
                        {
                                Name:      fmt.Sprintf("%s-subnet", name),
                                CidrBlock: "192.168.1.0/24"},
                },
        }
}</span>

func (self *VPC) GET() (bool, error) <span class="cov8" title="1">{

        return self.execute(http.MethodGet, fmt.Sprintf("/ns/%s/resources/vNet/%s", self.namespace, self.Name), fmt.Sprintf(`{"connectionName" : "%s"}`, self.Config), &amp;self)

}</span>

func (self *VPC) POST() error <span class="cov8" title="1">{

        _, err := self.execute(http.MethodPost, fmt.Sprintf("/ns/%s/resources/vNet", self.namespace), self, &amp;self)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>

}

func (self *VPC) DELETE() error <span class="cov0" title="0">{

        exist, err := self.GET()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if exist </span><span class="cov0" title="0">{
                _, err := self.execute(http.MethodDelete, fmt.Sprintf("/ns/%s/resources/vNet/%s", self.namespace, self.Name), fmt.Sprintf(`{"connectionName" : "%s"}`, self.Config), model.Status{})
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov0" title="0"> {
                logger.Infof("delete vpc skip.. (name=%s, cause=not found)", self.Name)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package model

import (
        "errors"
        "fmt"
        "regexp"
        "strings"

        ssh "github.com/cloud-barista/cb-spider/cloud-control-manager/vm-ssh"
        "github.com/jmleefree/actiontest2/src/utils/config"

        logger "github.com/sirupsen/logrus"
)

type VM struct {
        Name         string     `json:"name"`
        Config       string     `json:"connectionName"`
        VPC          string     `json:"vNetId"`
        Subnet       string     `json:"subnetId"`
        Firewall     []string   `json:"securityGroupIds"`
        SSHKey       string     `json:"sshKeyId"`
        Image        string     `json:"imageId"`
        Spec         string     `json:"specId"`
        UserAccount  string     `json:"vmUserAccount"`
        UserPassword string     `json:"vmUserPassword"`
        Description  string     `json:"description"`
        PublicIP     string     `json:"publicIP"` // output
        Credential   string     // private
        UId          string     `json:"uid"`
        Role         string     `json:"role"`
        Csp          config.CSP `json:"csp"`
        IsCPLeader   bool       `json:"isCPLeader"`
}

const (
        remoteTargetPath = "/tmp"
)

func (self *VM) ConnectionTest(sshInfo *ssh.SSHInfo) error <span class="cov8" title="1">{
        cmd := "/bin/hostname"
        _, err := ssh.SSHRun(*sshInfo, cmd)
        if err != nil </span><span class="cov0" title="0">{
                logger.Warnf("connection test error (server=%s, cause=%s)", sshInfo.ServerPort, err)
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (self *VM) CopyScripts(sshInfo *ssh.SSHInfo, networkCni string) error <span class="cov8" title="1">{
        sourcePath := fmt.Sprintf("%s/src/scripts", *config.Config.AppRootPath)
        sourceFile := []string{config.BOOTSTRAP_FILE}
        if self.Role == config.CONTROL_PLANE &amp;&amp; self.IsCPLeader </span><span class="cov8" title="1">{
                sourceFile = append(sourceFile, config.INIT_FILE)
                sourceFile = append(sourceFile, config.HA_PROXY_FILE)
        }</span>
        <span class="cov8" title="1">if networkCni == config.NETWORKCNI_CANAL </span><span class="cov0" title="0">{
                sourceFile = append(sourceFile, config.LADYBUG_BOOTSTRAP_CANAL_FILE)
        }</span> else<span class="cov8" title="1"> {
                sourceFile = append(sourceFile, config.LADYBUG_BOOTSTRAP_KILO_FILE)
        }</span>
        <span class="cov8" title="1">sourceFile = append(sourceFile, config.SYSTEMD_SERVICE_FILE)

        logger.Infof("start script file copy (vm=%s, src=%s, dest=%s)\n", self.Name, sourcePath, remoteTargetPath)
        for _, f := range sourceFile </span><span class="cov8" title="1">{
                src := fmt.Sprintf("%s/%s", sourcePath, f)
                dest := fmt.Sprintf("%s/%s", remoteTargetPath, f)
                if err := ssh.SSHCopy(*sshInfo, src, dest); err != nil </span><span class="cov0" title="0">{
                        return errors.New(fmt.Sprintf("copy scripts error (server=%s, cause=%s)", sshInfo.ServerPort, err))
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (self *VM) SetSystemd(sshInfo *ssh.SSHInfo, networkCni string) error <span class="cov8" title="1">{
        var bsFile string
        if networkCni == config.NETWORKCNI_CANAL </span><span class="cov0" title="0">{
                bsFile = config.LADYBUG_BOOTSTRAP_CANAL_FILE
        }</span> else<span class="cov8" title="1"> {
                bsFile = config.LADYBUG_BOOTSTRAP_KILO_FILE
        }</span>

        <span class="cov8" title="1">cmd := fmt.Sprintf("cd %s;./%s", remoteTargetPath, bsFile)
        _, err := ssh.SSHRun(*sshInfo, cmd)
        if err != nil </span><span class="cov0" title="0">{
                return errors.New(fmt.Sprintf("create ladybug-bootstrap error (name=%s)", self.Name))
        }</span>

        <span class="cov8" title="1">cmd = fmt.Sprintf("cd %s;./%s", remoteTargetPath, config.SYSTEMD_SERVICE_FILE)
        _, err = ssh.SSHRun(*sshInfo, cmd)
        if err != nil </span><span class="cov0" title="0">{
                return errors.New(fmt.Sprintf("set systemd service error (name=%s)", self.Name))
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (self *VM) Bootstrap(sshInfo *ssh.SSHInfo) error <span class="cov8" title="1">{
        cmd := fmt.Sprintf("cd %s;./%s", remoteTargetPath, config.BOOTSTRAP_FILE)

        result, err := ssh.SSHRun(*sshInfo, cmd)
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("k8s bootstrap error")
        }</span>
        <span class="cov8" title="1">if strings.Contains(result, "kubectl set on hold") </span><span class="cov8" title="1">{
                return nil
        }</span> else<span class="cov0" title="0"> {
                return errors.New(fmt.Sprintf("k8s bootstrap failed (name=%s)", self.Name))
        }</span>
}

func (self *VM) InstallHAProxy(sshInfo *ssh.SSHInfo, IPs []string) error <span class="cov8" title="1">{
        var servers string
        for i, ip := range IPs </span><span class="cov8" title="1">{
                servers += fmt.Sprintf("  server  api%d  %s:6443  check", i+1, ip)
                if i &lt; len(IPs)-1 </span><span class="cov0" title="0">{
                        servers += "\\n"
                }</span>
        }
        <span class="cov8" title="1">cmd := fmt.Sprintf("sudo sed 's/^{{SERVERS}}/%s/g' %s/%s", servers, remoteTargetPath, config.HA_PROXY_FILE)
        result, err := ssh.SSHRun(*sshInfo, cmd)
        if err != nil </span><span class="cov0" title="0">{
                logger.Warnf("get haproxy command error (name=%s, cause=%v)", self.Name, err)
                return err
        }</span>
        <span class="cov8" title="1">_, err = ssh.SSHRun(*sshInfo, result)
        if err != nil </span><span class="cov0" title="0">{
                logger.Warnf("install haproxy error (name=%s, cause=%v)", self.Name, err)
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (self *VM) ControlPlaneInit(sshInfo *ssh.SSHInfo, reqKubernetes Kubernetes) ([]string, string, error) <span class="cov8" title="1">{
        var joinCmd []string

        cmd := fmt.Sprintf("cd %s;./%s %s %s %s", remoteTargetPath, config.INIT_FILE, reqKubernetes.PodCidr, reqKubernetes.ServiceCidr, reqKubernetes.ServiceDnsDomain)
        cpInitResult, err := ssh.SSHRun(*sshInfo, cmd)
        if err != nil </span><span class="cov0" title="0">{
                logger.Warnf("control plane init error (name=%s, cause=%v)", self.Name, err)
                return nil, "", errors.New("k8s control plane node init error")
        }</span>
        <span class="cov8" title="1">if strings.Contains(cpInitResult, "Your Kubernetes control-plane has initialized successfully") </span><span class="cov8" title="1">{
                joinCmd = getJoinCmd(cpInitResult)
        }</span> else<span class="cov0" title="0"> {
                return nil, "", errors.New(fmt.Sprintf("control palne init failed (name=%s)", self.Name))
        }</span>

        <span class="cov8" title="1">cmd = "sudo cat /etc/kubernetes/admin.conf"
        clusterConfig, err := ssh.SSHRun(*sshInfo, cmd)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Error while running cmd %s (vm=%s, cause=%v)", cmd, self.Name, err)
        }</span>

        <span class="cov8" title="1">return joinCmd, clusterConfig, nil</span>
}

func (self *VM) InstallNetworkCNI(sshInfo *ssh.SSHInfo, networkCni string) error <span class="cov8" title="1">{
        var cmd string
        if networkCni == config.NETWORKCNI_CANAL </span><span class="cov0" title="0">{
                cmd = "sudo kubectl apply -f https://docs.projectcalico.org/manifests/canal.yaml --kubeconfig=/etc/kubernetes/admin.conf"
        }</span> else<span class="cov8" title="1"> {
                cmd = `sudo kubectl apply -f https://raw.githubusercontent.com/squat/kilo/master/manifests/kilo-kubeadm-flannel.yaml --kubeconfig=/etc/kubernetes/admin.conf;
                sudo kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml --kubeconfig=/etc/kubernetes/admin.conf;`
        }</span>

        <span class="cov8" title="1">_, err := ssh.SSHRun(*sshInfo, cmd)
        if err != nil </span><span class="cov0" title="0">{
                logger.Warnf("networkCNI install failed (name=%s, cause=%v)", self.Name, err)
                return errors.New("NetworkCNI Install error")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (self *VM) ControlPlaneJoin(sshInfo *ssh.SSHInfo, CPJoinCmd *string) error <span class="cov0" title="0">{
        if *CPJoinCmd == "" </span><span class="cov0" title="0">{
                return errors.New("control-plane node join command empty")
        }</span>
        <span class="cov0" title="0">cmd := fmt.Sprintf("sudo %s", *CPJoinCmd)
        result, err := ssh.SSHRun(*sshInfo, cmd)
        if err != nil </span><span class="cov0" title="0">{
                logger.Warnf("control-plane join error (name=%s, cause=%v)", self.Name, err)
                return errors.New("control-plane node join error")
        }</span>

        <span class="cov0" title="0">if strings.Contains(result, "This node has joined the cluster") </span><span class="cov0" title="0">{
                _, err = ssh.SSHRun(*sshInfo, "sudo systemctl restart ladybug-bootstrap")
                if err != nil </span><span class="cov0" title="0">{
                        logger.Warnf("ladybug-bootstrap restart error (name=%s, cause=%v)", self.Name, err)
                }</span>
                <span class="cov0" title="0">return nil</span>
        } else<span class="cov0" title="0"> {
                logger.Warnf("control-plane join failed (name=%s)", self.Name)
                return errors.New(fmt.Sprintf("control-plane join failed (name=%s)", self.Name))
        }</span>
}

func (self *VM) WorkerJoin(sshInfo *ssh.SSHInfo, workerJoinCmd *string) error <span class="cov8" title="1">{
        if *workerJoinCmd == "" </span><span class="cov0" title="0">{
                return errors.New("worker node join command empty")
        }</span>
        <span class="cov8" title="1">cmd := fmt.Sprintf("sudo %s", *workerJoinCmd)
        result, err := ssh.SSHRun(*sshInfo, cmd)
        if err != nil </span><span class="cov0" title="0">{
                logger.Warnf("worker join error (name=%s, cause=%v)", self.Name, err)
                return errors.New(fmt.Sprintf("worker node join error (name=%s)", self.Name))
        }</span>
        <span class="cov8" title="1">if strings.Contains(result, "This node has joined the cluster") </span><span class="cov8" title="1">{
                _, err = ssh.SSHRun(*sshInfo, "sudo systemctl restart ladybug-bootstrap")
                if err != nil </span><span class="cov0" title="0">{
                        logger.Warnf("ladybug-bootstrap restart error (name=%s, cause=%v)", self.Name, err)
                }</span>
                <span class="cov8" title="1">return nil</span>
        } else<span class="cov0" title="0"> {
                logger.Warnf("worker join failed (name=%s)", self.Name)
                return errors.New(fmt.Sprintf("worker node join failed (name=%s)", self.Name))
        }</span>
}

func getJoinCmd(cpInitResult string) []string <span class="cov8" title="1">{
        var join1, join2, join3 string
        joinRegex, _ := regexp.Compile("kubeadm\\sjoin\\s(.*?)\\s--token\\s(.*?)\\n")
        joinRegex2, _ := regexp.Compile("--discovery-token-ca-cert-hash\\ssha256:(.*?)\\n")
        joinRegex3, _ := regexp.Compile("--control-plane --certificate-key(.*?)\\n")

        if joinRegex.MatchString(cpInitResult) </span><span class="cov0" title="0">{
                join1 = joinRegex.FindString(cpInitResult)
        }</span>
        <span class="cov8" title="1">if joinRegex2.MatchString(cpInitResult) </span><span class="cov0" title="0">{
                join2 = joinRegex2.FindString(cpInitResult)
        }</span>
        <span class="cov8" title="1">if joinRegex3.MatchString(cpInitResult) </span><span class="cov0" title="0">{
                join3 = joinRegex3.FindString(cpInitResult)
        }</span>

        <span class="cov8" title="1">return []string{fmt.Sprintf("%s %s %s", join1, join2, join3), fmt.Sprintf("%s %s", join1, join2)}</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package service

import (
        "errors"
        "fmt"

        "github.com/jmleefree/actiontest2/src/core/model"
        "github.com/jmleefree/actiontest2/src/core/model/spider"
        "github.com/jmleefree/actiontest2/src/utils/config"
)

type NodeConfigInfo struct {
        model.NodeConfig
        Csp     config.CSP `json:"csp"`
        Role    string     `json:"role"`
        Region  string     `json:"region"`
        Account string     `json:"account"`
}

func SetNodeConfigInfos(nodeConfigs []model.NodeConfig, role string) ([]NodeConfigInfo, error) <span class="cov8" title="1">{
        var nodeConfigInfos []NodeConfigInfo

        for _, nodeConfig := range nodeConfigs </span><span class="cov8" title="1">{
                conn := spider.NewConnection(nodeConfig.Connection)
                exists, err := conn.GET()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.New(fmt.Sprintf("%s Connection connect error (connectionName=%s)", role, nodeConfig.Connection))
                }</span>
                <span class="cov8" title="1">if !exists </span><span class="cov0" title="0">{
                        return nil, errors.New(fmt.Sprintf("%s Connection does not exist (connectionName=%s)", role, nodeConfig.Connection))
                }</span>
                <span class="cov8" title="1">csp, err := GetCSPName(conn.ProviderName)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">region := spider.NewRegion(conn.RegionName)
                exists, err = region.GET()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.New(fmt.Sprintf("%s get region error (connectionName=%s)", role, nodeConfig.Connection))
                }</span>
                <span class="cov8" title="1">if !exists </span><span class="cov0" title="0">{
                        return nil, errors.New(fmt.Sprintf("%s region does not exist (connectionName=%s)", role, nodeConfig.Connection))
                }</span>
                <span class="cov8" title="1">regionName := GetRegionName(region.KeyValueInfoList)

                var nodeConfigInfo NodeConfigInfo
                nodeConfigInfo.Connection = nodeConfig.Connection
                nodeConfigInfo.Count = nodeConfig.Count
                nodeConfigInfo.Spec = nodeConfig.Spec
                nodeConfigInfo.Csp = csp
                nodeConfigInfo.Role = role
                nodeConfigInfo.Region = regionName
                nodeConfigInfo.Account = GetUserAccount(nodeConfigInfo.Csp)

                nodeConfigInfos = append(nodeConfigInfos, nodeConfigInfo)</span>
        }

        <span class="cov8" title="1">return nodeConfigInfos, nil</span>
}

func GetControlPlaneIPs(VMs []model.VM) []string <span class="cov8" title="1">{
        var IPs []string
        for _, vm := range VMs </span><span class="cov8" title="1">{
                if vm.Role == config.CONTROL_PLANE </span><span class="cov8" title="1">{
                        IPs = append(IPs, vm.PublicIP)
                }</span>
        }
        <span class="cov8" title="1">return IPs</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package service

import (
        "errors"
        "fmt"
        "strings"

        "github.com/jmleefree/actiontest2/src/core/model/spider"
        "github.com/jmleefree/actiontest2/src/utils/config"
        logger "github.com/sirupsen/logrus"
)

const (
        GCP_IMAGE_ID = "https://www.googleapis.com/compute/v1/projects/ubuntu-os-cloud/global/images/ubuntu-1804-bionic-v20201014"
)

// region별 AMI :  (AMI 이름 : ubuntu/images/hvm-ssd/ubuntu-bionic-18.04-amd64-server-20200908, 소유자:099720109477 )
var imageMap = map[string]string{
        "us-east-1":      "ami-0817d428a6fb68645", //미국 동부 (버지니아 북부)
        "us-east-2":      "ami-0e82959d4ed12de3f", //미국 동부 (오하이오)
        "us-west-1":      "ami-03fac5402e10ea93b", //미국서부 (캘리포니아)
        "us-west-2":      "ami-07a29e5e945228fa1", //미국서부 (오래곤)
        "af-south-1":     "",                      //아프리카 (케이프타운)
        "ap-east-1":      "",                      //아시아 태평양 (홍콩)
        "ap-south-1":     "ami-03f0fd1a2ba530e75", //아시아 태평양 (뭄바이)
        "ap-northeast-2": "ami-064ab8637cf33f1bb", //아시아 태평양 (서울)
        "ap-southeast-1": "ami-0c8e97a27be37adfd", //아시아 태평양 (싱가포르)
        "ap-southeast-2": "ami-099c1869f33464fde", //아시아 태평양 (시드니)
        "ap-northeast-1": "ami-02b658ac34935766f", //아시아 태평양 (도쿄)
        "ca-central-1":   "ami-0c27a26eca5dc74fc", //캐나다 (중부)
        "eu-central-1":   "ami-092391a11f8aa4b7b", //유럽 (프랑크푸르트)
        "eu-west-1":      "ami-0823c236601fef765", //유럽 (아일랜드)
        "eu-west-2":      "ami-09a1e275e350acf38", //유럽 (런던)
        "eu-south-1":     "",                      //유럽 (밀라노)
        "eu-west-3":      "ami-014d8dccd70fd2632", //유럽 (파리)
        "eu-north-1":     "ami-0ede7f804d699ea83", //유럽 (스톡홀름)
        "me-south-1":     "",                      //중동 (바레인)
        "sa-east-1":      "ami-0fd2c3d373788b726", //남아메리카 (상파울루)
}

// TODO [update/hard-coding] host user account
func GetUserAccount(csp config.CSP) string <span class="cov8" title="1">{

        if csp == config.CSP_AWS </span><span class="cov0" title="0">{
                return "ubuntu"
        }</span>

        <span class="cov8" title="1">return "cb-user"</span>
}

// get vm image-id
func GetVmImageId(csp config.CSP, configName string) (string, error) <span class="cov0" title="0">{

        if csp == config.CSP_GCP </span><span class="cov0" title="0">{
                return GCP_IMAGE_ID, nil
        }</span> else<span class="cov0" title="0"> if csp == config.CSP_AWS </span><span class="cov0" title="0">{
                // AWS : 리전별 AMI 가져오기
                conn := spider.NewConnection(configName)
                exists, err := conn.GET()
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">if !exists </span><span class="cov0" title="0">{
                        return "", errors.New(fmt.Sprintf("request not found AMI on AWS (cause = not found connection config `%s`)", configName))
                }</span>

                // http get region data
                <span class="cov0" title="0">region := spider.NewRegion(conn.RegionName)
                exists, err = region.GET()
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">if !exists </span><span class="cov0" title="0">{
                        return "", errors.New(fmt.Sprintf("request not found AMI on AWS (cause = not found region, connection='%s', region name='%s')", configName, conn.RegionName))
                }</span>

                // find region
                <span class="cov0" title="0">regionName := ""
                for i := 0; i &lt; len(region.KeyValueInfoList); i++ </span><span class="cov0" title="0">{
                        if region.KeyValueInfoList[i].Key == "Region" </span><span class="cov0" title="0">{
                                regionName = region.KeyValueInfoList[i].Value //get region name
                                break</span>
                        }
                }
                <span class="cov0" title="0">if regionName == "" </span><span class="cov0" title="0">{
                        return "", errors.New(fmt.Sprintf("request not found AMI on AWS (cause = region name is empty, connection='%s', region name='%s')", configName, conn.RegionName))
                }</span>

                // TODO [update/hard-coding] region별 image id
                <span class="cov0" title="0">imageId := imageMap[regionName]
                if imageId == "" </span><span class="cov0" title="0">{
                        return "", errors.New(fmt.Sprintf("request not found AMI on AWS image map (connection='%s', region='%s')", configName, regionName))
                }</span>

                <span class="cov0" title="0">logger.Infof("AMI find OK (ami='%s', region='%s')", imageId, regionName)
                return imageId, nil</span>

        } else<span class="cov0" title="0"> {
                return "", errors.New(fmt.Sprintf("CSP '%s' is not supported (Not found \"vm-machine-image\")", csp))
        }</span>

}

// get CSP Name
func GetCSPName(providerName string) (config.CSP, error) <span class="cov0" title="0">{
        switch strings.ToLower(providerName) </span>{
        case "aws":<span class="cov0" title="0">
                return config.CSP_AWS, nil</span>
        case "gcp":<span class="cov0" title="0">
                return config.CSP_GCP, nil</span>
        }
        <span class="cov0" title="0">return "", errors.New(providerName + "is not supported")</span>
}

// get Region Name
func GetRegionName(infoList []spider.KeyValue) string <span class="cov8" title="1">{
        regionName := ""
        for i := 0; i &lt; len(infoList); i++ </span><span class="cov8" title="1">{
                if infoList[i].Key == "Region" </span><span class="cov8" title="1">{
                        regionName = infoList[i].Value //get region name
                        break</span>
                }
        }
        <span class="cov8" title="1">return regionName</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package service

import (
        "fmt"
        "strings"

        "github.com/jmleefree/actiontest2/src/core/model/tumblebug"
        logger "github.com/sirupsen/logrus"
)

func (nodeConfigInfo *NodeConfigInfo) CreateVPC(namespace string, clusterName string) (*tumblebug.VPC, error) <span class="cov8" title="1">{
        vpcName := fmt.Sprintf("%s-%s-vpc", clusterName, nodeConfigInfo.Csp)
        logger.Infof("start create vpc (name=%s)", vpcName)
        vpc := tumblebug.NewVPC(namespace, vpcName, nodeConfigInfo.Connection)
        exists, e := vpc.GET()
        if e != nil </span><span class="cov0" title="0">{
                return nil, e
        }</span>
        <span class="cov8" title="1">if exists </span><span class="cov8" title="1">{
                logger.Infof("reuse vpc (name=%s, cause='already exists')", vpcName)
        }</span> else<span class="cov8" title="1"> {
                if e = vpc.POST(); e != nil </span><span class="cov0" title="0">{
                        return nil, e
                }</span>
                <span class="cov8" title="1">logger.Infof("create vpc OK.. (name=%s)", vpcName)</span>
        }
        <span class="cov8" title="1">return vpc, nil</span>
}

func (nodeConfigInfo *NodeConfigInfo) CreateFirewall(namespace string, clusterName string) (*tumblebug.Firewall, error) <span class="cov8" title="1">{
        firewallName := fmt.Sprintf("%s-%s-allow-external", clusterName, nodeConfigInfo.Csp)
        vpcName := fmt.Sprintf("%s-%s-vpc", clusterName, nodeConfigInfo.Csp)
        logger.Infof("start create firewall (name=%s)", firewallName)
        fw := tumblebug.NewFirewall(namespace, firewallName, nodeConfigInfo.Connection)
        fw.VPCId = vpcName
        exists, e := fw.GET()
        if e != nil </span><span class="cov0" title="0">{
                return nil, e
        }</span>
        <span class="cov8" title="1">if exists </span><span class="cov8" title="1">{
                logger.Infof("reuse firewall (name=%s, cause='already exists')", firewallName)
        }</span> else<span class="cov8" title="1"> {
                if e = fw.POST(); e != nil </span><span class="cov0" title="0">{
                        return nil, e
                }</span>
                <span class="cov8" title="1">logger.Infof("create firewall OK.. (name=%s)", firewallName)</span>
        }
        <span class="cov8" title="1">return fw, nil</span>
}

func (nodeConfigInfo *NodeConfigInfo) CreateSshKey(namespace string, clusterName string) (*tumblebug.SSHKey, error) <span class="cov8" title="1">{
        sshkeyName := fmt.Sprintf("%s-%s-sshkey", clusterName, nodeConfigInfo.Csp)
        logger.Infof("start create ssh key (name=%s)", sshkeyName)
        sshKey := tumblebug.NewSSHKey(namespace, sshkeyName, nodeConfigInfo.Connection)
        sshKey.Username = nodeConfigInfo.Account
        exists, e := sshKey.GET()
        if e != nil </span><span class="cov0" title="0">{
                return nil, e
        }</span>
        <span class="cov8" title="1">if exists </span><span class="cov8" title="1">{
                logger.Infof("reuse ssh key (name=%s, cause='already exists')", sshkeyName)
        }</span> else<span class="cov8" title="1"> {
                if e = sshKey.POST(); e != nil </span><span class="cov0" title="0">{
                        return nil, e
                }</span>
                <span class="cov8" title="1">logger.Infof("create ssh key OK.. (name=%s)", sshkeyName)</span>
        }
        <span class="cov8" title="1">return sshKey, nil</span>
}

func (nodeConfigInfo *NodeConfigInfo) CreateImage(namespace string, clusterName string) (*tumblebug.Image, error) <span class="cov8" title="1">{
        imageId, e := GetVmImageId(nodeConfigInfo.Csp, nodeConfigInfo.Connection)
        if e != nil </span><span class="cov0" title="0">{
                return nil, e
        }</span>

        <span class="cov8" title="1">imageName := fmt.Sprintf("%s-%s-ubuntu1804", nodeConfigInfo.Connection, nodeConfigInfo.Region)
        logger.Infof("start create image (name=%s)", imageName)
        image := tumblebug.NewImage(namespace, imageName, nodeConfigInfo.Connection)
        image.CspImageId = imageId
        exists, e := image.GET()
        if e != nil </span><span class="cov0" title="0">{
                return nil, e
        }</span>
        <span class="cov8" title="1">if exists </span><span class="cov8" title="1">{
                logger.Infof("reuse image (name=%s, cause='already exists')", imageName)
        }</span> else<span class="cov8" title="1"> {
                if e = image.POST(); e != nil </span><span class="cov0" title="0">{
                        return nil, e
                }</span>
                <span class="cov8" title="1">logger.Infof("create image OK.. (name=%s)", imageName)</span>
        }
        <span class="cov8" title="1">return image, nil</span>
}

func (nodeConfigInfo *NodeConfigInfo) CreateSpec(namespace string, clusterName string) (*tumblebug.Spec, error) <span class="cov8" title="1">{
        specName := fmt.Sprintf("%s-spec", strings.ReplaceAll(nodeConfigInfo.Spec, ".", "-"))
        logger.Infof("start create spec (name=%s)", specName)
        spec := tumblebug.NewSpec(namespace, specName, nodeConfigInfo.Connection)
        spec.CspSpecName = nodeConfigInfo.Spec
        spec.Role = nodeConfigInfo.Role
        exists, e := spec.GET()
        if e != nil </span><span class="cov0" title="0">{
                return nil, e
        }</span>
        <span class="cov8" title="1">if exists </span><span class="cov8" title="1">{
                logger.Infof("reuse spec (name=%s, cause='already exists')", specName)
        }</span> else<span class="cov8" title="1"> {
                if e = spec.POST(); e != nil </span><span class="cov0" title="0">{
                        return nil, e
                }</span>
                <span class="cov8" title="1">logger.Infof("create spec OK.. (name=%s)", specName)</span>
        }
        <span class="cov8" title="1">return spec, nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package cmd

import (
        "github.com/spf13/cobra"

        "github.com/jmleefree/actiontest2/src/grpc-api/logger"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// NewClusterCmd - Cloud Cluster 관리 기능을 수행하는 Cobra Command 생성
func NewClusterCmd() *cobra.Command <span class="cov0" title="0">{

        clusterCmd := &amp;cobra.Command{
                Use:   "cluster",
                Short: "This is a manageable command for cloud cluster",
                Long:  "This is a manageable command for cloud cluster",
        }

        //  Adds the commands for application.
        clusterCmd.AddCommand(NewClusterCreateCmd())
        clusterCmd.AddCommand(NewClusterListCmd())
        clusterCmd.AddCommand(NewClusterGetCmd())
        clusterCmd.AddCommand(NewClusterDeleteCmd())

        return clusterCmd
}</span>

// NewClusterCreateCmd - Cloud Cluster 생성 기능을 수행하는 Cobra Command 생성
func NewClusterCreateCmd() *cobra.Command <span class="cov0" title="0">{

        createCmd := &amp;cobra.Command{
                Use:   "create",
                Short: "This is create command for cloud cluster",
                Long:  "This is create command for cloud cluster",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        readInDataFromFile()
                        if inData == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --indata parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--indata parameter value : \n", inData)
                        logger.Debug("--infile parameter value : ", inFile)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">createCmd.PersistentFlags().StringVarP(&amp;inData, "indata", "d", "", "input string data")
        createCmd.PersistentFlags().StringVarP(&amp;inFile, "infile", "f", "", "input file path")

        return createCmd</span>
}

// NewClusterListCmd - Cloud Cluster 목록 기능을 수행하는 Cobra Command 생성
func NewClusterListCmd() *cobra.Command <span class="cov0" title="0">{

        listCmd := &amp;cobra.Command{
                Use:   "list",
                Short: "This is list command for cloud cluster",
                Long:  "This is list command for cloud cluster",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--ns parameter value : ", nameSpaceID)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">listCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")

        return listCmd</span>
}

// NewClusterGetCmd - Cloud Cluster 조회 기능을 수행하는 Cobra Command 생성
func NewClusterGetCmd() *cobra.Command <span class="cov0" title="0">{

        getCmd := &amp;cobra.Command{
                Use:   "get",
                Short: "This is get command for cloud cluster",
                Long:  "This is get command for cloud cluster",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">if clusterName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --cluster parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--ns parameter value : ", nameSpaceID)
                        logger.Debug("--cluster parameter value : ", clusterName)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">getCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")
        getCmd.PersistentFlags().StringVarP(&amp;clusterName, "cluster", "", "", "cluster name")

        return getCmd</span>
}

// NewClusterDeleteCmd - Cloud Cluster 삭제 기능을 수행하는 Cobra Command 생성
func NewClusterDeleteCmd() *cobra.Command <span class="cov0" title="0">{

        deleteCmd := &amp;cobra.Command{
                Use:   "delete",
                Short: "This is delete command for cloud cluster",
                Long:  "This is delete command for cloud cluster",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">if clusterName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --cluster parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--ns parameter value : ", nameSpaceID)
                        logger.Debug("--cluster parameter value : ", clusterName)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">deleteCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")
        deleteCmd.PersistentFlags().StringVarP(&amp;clusterName, "cluster", "", "", "cluster name")

        return deleteCmd</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package cmd

import (
        "github.com/spf13/cobra"

        "github.com/jmleefree/actiontest2/src/grpc-api/logger"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// NewConfigCmd - Config 관리 기능을 수행하는 Cobra Command 생성
func NewConfigCmd() *cobra.Command <span class="cov0" title="0">{

        configCmd := &amp;cobra.Command{
                Use:   "config",
                Short: "This is a manageable command for config",
                Long:  "This is a manageable command for config",
        }

        //  Adds the commands for application.
        configCmd.AddCommand(NewConfigCreateCmd())
        configCmd.AddCommand(NewConfigListCmd())
        configCmd.AddCommand(NewConfigGetCmd())
        configCmd.AddCommand(NewConfigDeleteAllCmd())

        return configCmd
}</span>

// NewConfigCreateCmd - Config 생성 기능을 수행하는 Cobra Command 생성
func NewConfigCreateCmd() *cobra.Command <span class="cov0" title="0">{

        createCmd := &amp;cobra.Command{
                Use:   "create",
                Short: "This is create command for config",
                Long:  "This is create command for config",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        readInDataFromFile()
                        if inData == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --indata parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--indata parameter value : \n", inData)
                        logger.Debug("--infile parameter value : ", inFile)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">createCmd.PersistentFlags().StringVarP(&amp;inData, "indata", "d", "", "input string data")
        createCmd.PersistentFlags().StringVarP(&amp;inFile, "infile", "f", "", "input file path")

        return createCmd</span>
}

// NewConfigListCmd - Config 목록 기능을 수행하는 Cobra Command 생성
func NewConfigListCmd() *cobra.Command <span class="cov0" title="0">{

        listCmd := &amp;cobra.Command{
                Use:   "list",
                Short: "This is list command for config",
                Long:  "This is list command for config",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        SetupAndRun(cmd, args)
                }</span>,
        }

        <span class="cov0" title="0">return listCmd</span>
}

// NewConfigGetCmd - Config 조회 기능을 수행하는 Cobra Command 생성
func NewConfigGetCmd() *cobra.Command <span class="cov0" title="0">{

        getCmd := &amp;cobra.Command{
                Use:   "get",
                Short: "This is get command for config",
                Long:  "This is get command for config",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        if configId == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --id parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--id parameter value : ", configId)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">getCmd.PersistentFlags().StringVarP(&amp;configId, "id", "", "", "config id")

        return getCmd</span>
}

// NewConfigDeleteAllCmd - Config 모든 삭제 기능을 수행하는 Cobra Command 생성
func NewConfigDeleteAllCmd() *cobra.Command <span class="cov0" title="0">{

        deleteAllCmd := &amp;cobra.Command{
                Use:   "delete-all",
                Short: "This is delete alll command for config",
                Long:  "This is delete all command for config",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{

                        SetupAndRun(cmd, args)
                }</span>,
        }

        <span class="cov0" title="0">return deleteAllCmd</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package cmd

import (
        "github.com/spf13/cobra"

        "github.com/jmleefree/actiontest2/src/grpc-api/logger"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// NewConnectInfosCmd - 연결설정 관리 기능을 수행하는 Cobra Command 생성
func NewConnectInfosCmd() *cobra.Command <span class="cov0" title="0">{

        connectionCmd := &amp;cobra.Command{
                Use:   "connect-info",
                Short: "This is a manageable command for connection config",
                Long:  "This is a manageable command for connection config",
        }

        //  Adds the commands for application.
        connectionCmd.AddCommand(NewConnectInfosCreateCmd())
        connectionCmd.AddCommand(NewConnectInfosListCmd())
        connectionCmd.AddCommand(NewCConnectInfosGetCmd())
        connectionCmd.AddCommand(NewConnectInfosDeleteCmd())

        return connectionCmd
}</span>

// NewConnectInfosCreateCmd - 연결설정 생성 기능을 수행하는 Cobra Command 생성
func NewConnectInfosCreateCmd() *cobra.Command <span class="cov0" title="0">{

        createCmd := &amp;cobra.Command{
                Use:   "create",
                Short: "This is create command for connection config",
                Long:  "This is create command for connection config",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        readInDataFromFile()
                        if inData == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --indata parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--indata parameter value : \n", inData)
                        logger.Debug("--infile parameter value : ", inFile)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">createCmd.PersistentFlags().StringVarP(&amp;inData, "indata", "d", "", "input string data")
        createCmd.PersistentFlags().StringVarP(&amp;inFile, "infile", "f", "", "input file path")

        return createCmd</span>
}

// NewConnectInfosListCmd - 연결설정 목록 기능을 수행하는 Cobra Command 생성
func NewConnectInfosListCmd() *cobra.Command <span class="cov0" title="0">{

        listCmd := &amp;cobra.Command{
                Use:   "list",
                Short: "This is list command for connection config",
                Long:  "This is list command for connection config",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        SetupAndRun(cmd, args)
                }</span>,
        }

        <span class="cov0" title="0">return listCmd</span>
}

// NewCConnectInfosGetCmd - 연결설정 조회 기능을 수행하는 Cobra Command 생성
func NewCConnectInfosGetCmd() *cobra.Command <span class="cov0" title="0">{

        getCmd := &amp;cobra.Command{
                Use:   "get",
                Short: "This is get command for connection config",
                Long:  "This is get command for connection config",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        if configName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --name parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--name parameter value : ", configName)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">getCmd.PersistentFlags().StringVarP(&amp;configName, "name", "n", "", "config name")

        return getCmd</span>
}

// NewConnectInfosDeleteCmd - 연결설정 삭제 기능을 수행하는 Cobra Command 생성
func NewConnectInfosDeleteCmd() *cobra.Command <span class="cov0" title="0">{

        deleteCmd := &amp;cobra.Command{
                Use:   "delete",
                Short: "This is delete command for connection config",
                Long:  "This is delete command for connection config",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        if configName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --name parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--name parameter value : ", configName)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">deleteCmd.PersistentFlags().StringVarP(&amp;configName, "name", "n", "", "config name")

        return deleteCmd</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package cmd

import (
        "github.com/spf13/cobra"

        "github.com/jmleefree/actiontest2/src/grpc-api/logger"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// NewCredentialCmd - Credential 관리 기능을 수행하는 Cobra Command 생성
func NewCredentialCmd() *cobra.Command <span class="cov0" title="0">{

        credentialCmd := &amp;cobra.Command{
                Use:   "credential",
                Short: "This is a manageable command for credential",
                Long:  "This is a manageable command for credential",
        }

        //  Adds the commands for application.
        credentialCmd.AddCommand(NewCredentialCreateCmd())
        credentialCmd.AddCommand(NewCredentialListCmd())
        credentialCmd.AddCommand(NewCredentialGetCmd())
        credentialCmd.AddCommand(NewCredentialDeleteCmd())

        return credentialCmd
}</span>

// NewCredentialCreateCmd -Credential 생성 기능을 수행하는 Cobra Command 생성
func NewCredentialCreateCmd() *cobra.Command <span class="cov0" title="0">{

        createCmd := &amp;cobra.Command{
                Use:   "create",
                Short: "This is create command for credential",
                Long:  "This is create command for credential",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        readInDataFromFile()
                        if inData == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --indata parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--indata parameter value : \n", inData)
                        logger.Debug("--infile parameter value : ", inFile)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">createCmd.PersistentFlags().StringVarP(&amp;inData, "indata", "d", "", "input string data")
        createCmd.PersistentFlags().StringVarP(&amp;inFile, "infile", "f", "", "input file path")

        return createCmd</span>
}

// NewCredentialListCmd - Credential 목록 기능을 수행하는 Cobra Command 생성
func NewCredentialListCmd() *cobra.Command <span class="cov0" title="0">{

        listCmd := &amp;cobra.Command{
                Use:   "list",
                Short: "This is list command for credential",
                Long:  "This is list command for credential",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        SetupAndRun(cmd, args)
                }</span>,
        }

        <span class="cov0" title="0">return listCmd</span>
}

// NewCredentialGetCmd - Credential 조회 기능을 수행하는 Cobra Command 생성
func NewCredentialGetCmd() *cobra.Command <span class="cov0" title="0">{

        getCmd := &amp;cobra.Command{
                Use:   "get",
                Short: "This is get command for credential",
                Long:  "This is get command for credential",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        if credentialName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --name parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--name parameter value : ", credentialName)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">getCmd.PersistentFlags().StringVarP(&amp;credentialName, "name", "n", "", "crendential name")

        return getCmd</span>
}

// NewCredentialDeleteCmd - Credential 삭제 기능을 수행하는 Cobra Command 생성
func NewCredentialDeleteCmd() *cobra.Command <span class="cov0" title="0">{

        deleteCmd := &amp;cobra.Command{
                Use:   "delete",
                Short: "This is delete command for credential",
                Long:  "This is delete command for credential",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        if credentialName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --name parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--name parameter value : ", credentialName)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">deleteCmd.PersistentFlags().StringVarP(&amp;credentialName, "name", "n", "", "crendential name")

        return deleteCmd</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package cmd

import (
        "github.com/spf13/cobra"

        "github.com/jmleefree/actiontest2/src/grpc-api/logger"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// NewDriverCmd - Cloud Driver 관리 기능을 수행하는 Cobra Command 생성
func NewDriverCmd() *cobra.Command <span class="cov0" title="0">{

        driverCmd := &amp;cobra.Command{
                Use:   "driver",
                Short: "This is a manageable command for cloud driver",
                Long:  "This is a manageable command for cloud driver",
        }

        //  Adds the commands for application.
        driverCmd.AddCommand(NewDriverCreateCmd())
        driverCmd.AddCommand(NewDriverListCmd())
        driverCmd.AddCommand(NewDriverGetCmd())
        driverCmd.AddCommand(NewDriverDeleteCmd())

        return driverCmd
}</span>

// NewDriverCreateCmd - Cloud Driver 생성 기능을 수행하는 Cobra Command 생성
func NewDriverCreateCmd() *cobra.Command <span class="cov0" title="0">{

        createCmd := &amp;cobra.Command{
                Use:   "create",
                Short: "This is create command for cloud driver",
                Long:  "This is create command for cloud driver",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        readInDataFromFile()
                        if inData == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --indata parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--indata parameter value : \n", inData)
                        logger.Debug("--infile parameter value : ", inFile)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">createCmd.PersistentFlags().StringVarP(&amp;inData, "indata", "d", "", "input string data")
        createCmd.PersistentFlags().StringVarP(&amp;inFile, "infile", "f", "", "input file path")

        return createCmd</span>
}

// NewDriverListCmd - Cloud Driver 목록 기능을 수행하는 Cobra Command 생성
func NewDriverListCmd() *cobra.Command <span class="cov0" title="0">{

        listCmd := &amp;cobra.Command{
                Use:   "list",
                Short: "This is list command for cloud driver",
                Long:  "This is list command for cloud driver",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        SetupAndRun(cmd, args)
                }</span>,
        }

        <span class="cov0" title="0">return listCmd</span>
}

// NewDriverGetCmd - Cloud Driver 조회 기능을 수행하는 Cobra Command 생성
func NewDriverGetCmd() *cobra.Command <span class="cov0" title="0">{

        getCmd := &amp;cobra.Command{
                Use:   "get",
                Short: "This is get command for cloud driver",
                Long:  "This is get command for cloud driver",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        if driverName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --name parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--name parameter value : ", driverName)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">getCmd.PersistentFlags().StringVarP(&amp;driverName, "name", "n", "", "driver name")

        return getCmd</span>
}

// NewDriverDeleteCmd - Cloud Driver 삭제 기능을 수행하는 Cobra Command 생성
func NewDriverDeleteCmd() *cobra.Command <span class="cov0" title="0">{

        deleteCmd := &amp;cobra.Command{
                Use:   "delete",
                Short: "This is delete command for cloud driver",
                Long:  "This is delete command for cloud driver",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        if driverName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --name parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--name parameter value : ", driverName)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">deleteCmd.PersistentFlags().StringVarP(&amp;driverName, "name", "n", "", "driver name")

        return deleteCmd</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package cmd

import (
        "fmt"
        "io/ioutil"

        "github.com/spf13/cobra"

        sp_api "github.com/cloud-barista/cb-spider/interface/api"
        tb_api "github.com/cloud-barista/cb-tumblebug/src/api/grpc/request"
        "github.com/jmleefree/actiontest2/src/grpc-api/cbadm/proc"
        "github.com/jmleefree/actiontest2/src/grpc-api/logger"
        lb_api "github.com/jmleefree/actiontest2/src/grpc-api/request"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

func readInDataFromFile() <span class="cov0" title="0">{
        logger := logger.NewLogger()
        if inData == "" </span><span class="cov0" title="0">{
                if inFile != "" </span><span class="cov0" title="0">{
                        dat, err := ioutil.ReadFile(inFile)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Error("failed to read file : ", inFile)
                                return
                        }</span>
                        <span class="cov0" title="0">inData = string(dat)</span>
                }
        }
}

// ===== [ Public Functions ] =====

// SetupAndRun - SPIDER GRPC CLI 구동
func SetupAndRun(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
        logger := logger.NewLogger()

        var (
                result string
                err    error

                cim    *sp_api.CIMApi     = nil
                ns     *tb_api.NSApi      = nil
                mcir   *tb_api.MCIRApi    = nil
                mcis   *tb_api.MCISApi    = nil
                tbutil *tb_api.UTILITYApi = nil
                mcar   *lb_api.MCARApi    = nil
        )

        // panic 처리
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        logger.Error("cbadm is stopped : ", r)
                }</span>
        }()

        <span class="cov0" title="0">if cmd.Parent().Name() == "driver" || cmd.Parent().Name() == "credential" || cmd.Parent().Name() == "region" || cmd.Parent().Name() == "connect-info" </span><span class="cov0" title="0">{
                // CIM API 설정
                cim = sp_api.NewCloudInfoManager()
                err = cim.SetConfigPath(configFile)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to set config : ", err)
                        return
                }</span>
                <span class="cov0" title="0">err = cim.Open()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("cim api open failed : ", err)
                        return
                }</span>
                <span class="cov0" title="0">defer cim.Close()</span>
        }

        <span class="cov0" title="0">if cmd.Parent().Name() == "namespace" </span><span class="cov0" title="0">{
                // NS API 설정
                ns = tb_api.NewNSManager()
                err = ns.SetConfigPath(configFile)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to set config : ", err)
                        return
                }</span>
                <span class="cov0" title="0">err = ns.Open()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("namespace api open failed : ", err)
                        return
                }</span>
                <span class="cov0" title="0">defer ns.Close()</span>
        }

        <span class="cov0" title="0">if cmd.Parent().Name() == "image" || cmd.Parent().Name() == "network" || cmd.Parent().Name() == "securitygroup" || cmd.Parent().Name() == "keypair" || cmd.Parent().Name() == "spec" </span><span class="cov0" title="0">{
                // MCIR API 설정
                mcir = tb_api.NewMCIRManager()
                err = mcir.SetConfigPath(configFile)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to set config : ", err)
                        return
                }</span>
                <span class="cov0" title="0">err = mcir.Open()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("namespace api open failed : ", err)
                        return
                }</span>
                <span class="cov0" title="0">defer mcir.Close()</span>
        }

        <span class="cov0" title="0">if cmd.Parent().Name() == "mcis" </span><span class="cov0" title="0">{
                // MCIS API 설정
                mcis = tb_api.NewMCISManager()
                err = mcis.SetConfigPath(configFile)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to set config : ", err)
                        return
                }</span>
                <span class="cov0" title="0">err = mcis.Open()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("mcis api open failed : ", err)
                        return
                }</span>
                <span class="cov0" title="0">defer mcis.Close()</span>
        }

        <span class="cov0" title="0">if cmd.Parent().Name() == "util" || cmd.Parent().Name() == "config" </span><span class="cov0" title="0">{
                // UTILITY API 설정
                tbutil = tb_api.NewUTILITYManager()
                err = tbutil.SetConfigPath(configFile)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to set config : ", err)
                        return
                }</span>
                <span class="cov0" title="0">err = tbutil.Open()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("mcis api open failed : ", err)
                        return
                }</span>
                <span class="cov0" title="0">defer tbutil.Close()</span>
        }

        <span class="cov0" title="0">if cmd.Parent().Name() == "cluster" || cmd.Parent().Name() == "node" || cmd.Parent().Name() == "healthy" </span><span class="cov0" title="0">{
                // LB API 설정
                mcar = lb_api.NewMCARManager()
                err = mcar.SetConfigPath(configFile)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to set config : ", err)
                        return
                }</span>
                <span class="cov0" title="0">err = mcar.Open()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("ladybug api open failed : ", err)
                        return
                }</span>
                <span class="cov0" title="0">defer mcar.Close()</span>
        }

        // 입력 파라미터 처리
        <span class="cov0" title="0">if outType != "json" &amp;&amp; outType != "yaml" </span><span class="cov0" title="0">{
                logger.Error("failed to validate --output parameter : ", outType)
                return
        }</span>
        <span class="cov0" title="0">if inType != "json" &amp;&amp; inType != "yaml" </span><span class="cov0" title="0">{
                logger.Error("failed to validate --input parameter : ", inType)
                return
        }</span>

        <span class="cov0" title="0">if cmd.Parent().Name() == "driver" || cmd.Parent().Name() == "credential" || cmd.Parent().Name() == "region" || cmd.Parent().Name() == "connect-info" </span><span class="cov0" title="0">{
                cim.SetInType(inType)
                cim.SetOutType(outType)
        }</span>
        <span class="cov0" title="0">if cmd.Parent().Name() == "namespace" </span><span class="cov0" title="0">{
                ns.SetInType(inType)
                ns.SetOutType(outType)
        }</span>
        <span class="cov0" title="0">if cmd.Parent().Name() == "image" || cmd.Parent().Name() == "network" || cmd.Parent().Name() == "securitygroup" || cmd.Parent().Name() == "keypair" || cmd.Parent().Name() == "spec" </span><span class="cov0" title="0">{
                mcir.SetInType(inType)
                mcir.SetOutType(outType)
        }</span>
        <span class="cov0" title="0">if cmd.Parent().Name() == "mcis" </span><span class="cov0" title="0">{
                mcis.SetInType(inType)
                mcis.SetOutType(outType)
        }</span>
        <span class="cov0" title="0">if cmd.Parent().Name() == "util" || cmd.Parent().Name() == "config" </span><span class="cov0" title="0">{
                tbutil.SetInType(inType)
                tbutil.SetOutType(outType)
        }</span>
        <span class="cov0" title="0">if cmd.Parent().Name() == "cluster" || cmd.Parent().Name() == "node" || cmd.Name() == "healthy" </span><span class="cov0" title="0">{
                mcar.SetInType(inType)
                mcar.SetOutType(outType)
        }</span>

        <span class="cov0" title="0">logger.Debug("--input parameter value : ", inType)
        logger.Debug("--output parameter value : ", outType)

        result = ""
        err = nil

        switch cmd.Parent().Name() </span>{
        case "cbadm":<span class="cov0" title="0">
                switch cmd.Name() </span>{
                case "healthy":<span class="cov0" title="0">
                        result, err = mcar.Healthy()</span>
                }
        case "driver":<span class="cov0" title="0">
                switch cmd.Name() </span>{
                case "create":<span class="cov0" title="0">
                        result, err = cim.CreateCloudDriver(inData)</span>
                case "list":<span class="cov0" title="0">
                        result, err = cim.ListCloudDriver()</span>
                case "get":<span class="cov0" title="0">
                        result, err = cim.GetCloudDriverByParam(driverName)</span>
                case "delete":<span class="cov0" title="0">
                        result, err = cim.DeleteCloudDriverByParam(driverName)</span>
                }
        case "credential":<span class="cov0" title="0">
                switch cmd.Name() </span>{
                case "create":<span class="cov0" title="0">
                        result, err = cim.CreateCredential(inData)</span>
                case "list":<span class="cov0" title="0">
                        result, err = cim.ListCredential()</span>
                case "get":<span class="cov0" title="0">
                        result, err = cim.GetCredentialByParam(credentialName)</span>
                case "delete":<span class="cov0" title="0">
                        result, err = cim.DeleteCredentialByParam(credentialName)</span>
                }
        case "region":<span class="cov0" title="0">
                switch cmd.Name() </span>{
                case "create":<span class="cov0" title="0">
                        result, err = cim.CreateRegion(inData)</span>
                case "list":<span class="cov0" title="0">
                        result, err = cim.ListRegion()</span>
                case "get":<span class="cov0" title="0">
                        result, err = cim.GetRegionByParam(regionName)</span>
                case "delete":<span class="cov0" title="0">
                        result, err = cim.DeleteRegionByParam(regionName)</span>
                }
        case "connect-info":<span class="cov0" title="0">
                switch cmd.Name() </span>{
                case "create":<span class="cov0" title="0">
                        result, err = cim.CreateConnectionConfig(inData)</span>
                case "list":<span class="cov0" title="0">
                        result, err = proc.ListConnectInfos(cim)</span>
                case "get":<span class="cov0" title="0">
                        result, err = proc.GetConnectInfos(cim, configName)</span>
                case "delete":<span class="cov0" title="0">
                        result, err = cim.DeleteConnectionConfigByParam(configName)</span>
                }
        case "namespace":<span class="cov0" title="0">
                switch cmd.Name() </span>{
                case "create":<span class="cov0" title="0">
                        result, err = ns.CreateNS(inData)</span>
                case "list":<span class="cov0" title="0">
                        result, err = ns.ListNS()</span>
                case "get":<span class="cov0" title="0">
                        result, err = ns.GetNSByParam(nameSpaceID)</span>
                case "delete":<span class="cov0" title="0">
                        result, err = ns.DeleteNSByParam(nameSpaceID)</span>
                }
        case "image":<span class="cov0" title="0">
                switch cmd.Name() </span>{
                case "create":<span class="cov0" title="0">
                        result, err = mcir.CreateImageWithInfo(inData)</span>
                case "create-id":<span class="cov0" title="0">
                        result, err = mcir.CreateImageWithID(inData)</span>
                case "list":<span class="cov0" title="0">
                        result, err = mcir.ListImageByParam(nameSpaceID)</span>
                case "get":<span class="cov0" title="0">
                        result, err = mcir.GetImageByParam(nameSpaceID, resourceID)</span>
                case "list-csp":<span class="cov0" title="0">
                        result, err = mcir.ListLookupImageByParam(connConfigName)</span>
                case "get-csp":<span class="cov0" title="0">
                        result, err = mcir.GetLookupImageByParam(connConfigName, cspImageId)</span>
                case "delete":<span class="cov0" title="0">
                        result, err = mcir.DeleteImageByParam(nameSpaceID, resourceID, force)</span>
                case "delete-all":<span class="cov0" title="0">
                        result, err = mcir.DeleteAllImageByParam(nameSpaceID, force)</span>
                case "fetch":<span class="cov0" title="0">
                        result, err = mcir.FetchImageByParam(nameSpaceID)</span>
                case "search":<span class="cov0" title="0">
                        result, err = mcir.SearchImage(inData)</span>
                }
        case "network":<span class="cov0" title="0">
                switch cmd.Name() </span>{
                case "create":<span class="cov0" title="0">
                        result, err = mcir.CreateVNet(inData)</span>
                case "list":<span class="cov0" title="0">
                        result, err = mcir.ListVNetByParam(nameSpaceID)</span>
                case "get":<span class="cov0" title="0">
                        result, err = mcir.GetVNetByParam(nameSpaceID, resourceID)</span>
                case "delete":<span class="cov0" title="0">
                        result, err = mcir.DeleteVNetByParam(nameSpaceID, resourceID, force)</span>
                case "delete-all":<span class="cov0" title="0">
                        result, err = mcir.DeleteAllVNetByParam(nameSpaceID, force)</span>
                }
        case "securitygroup":<span class="cov0" title="0">
                switch cmd.Name() </span>{
                case "create":<span class="cov0" title="0">
                        result, err = mcir.CreateSecurityGroup(inData)</span>
                case "list":<span class="cov0" title="0">
                        result, err = mcir.ListSecurityGroupByParam(nameSpaceID)</span>
                case "get":<span class="cov0" title="0">
                        result, err = mcir.GetSecurityGroupByParam(nameSpaceID, resourceID)</span>
                case "delete":<span class="cov0" title="0">
                        result, err = mcir.DeleteSecurityGroupByParam(nameSpaceID, resourceID, force)</span>
                case "delete-all":<span class="cov0" title="0">
                        result, err = mcir.DeleteAllSecurityGroupByParam(nameSpaceID, force)</span>
                }
        case "keypair":<span class="cov0" title="0">
                switch cmd.Name() </span>{
                case "create":<span class="cov0" title="0">
                        result, err = mcir.CreateSshKey(inData)</span>
                case "list":<span class="cov0" title="0">
                        result, err = mcir.ListSshKeyByParam(nameSpaceID)</span>
                case "get":<span class="cov0" title="0">
                        result, err = mcir.GetSshKeyByParam(nameSpaceID, resourceID)</span>
                case "save":<span class="cov0" title="0">
                        result, err = proc.SaveSshKey(mcir, nameSpaceID, resourceID, sshSaveFileName)</span>
                case "delete":<span class="cov0" title="0">
                        result, err = mcir.DeleteSshKeyByParam(nameSpaceID, resourceID, force)</span>
                case "delete-all":<span class="cov0" title="0">
                        result, err = mcir.DeleteAllSshKeyByParam(nameSpaceID, force)</span>
                }
        case "spec":<span class="cov0" title="0">
                switch cmd.Name() </span>{
                case "create":<span class="cov0" title="0">
                        result, err = mcir.CreateSpecWithInfo(inData)</span>
                case "create-id":<span class="cov0" title="0">
                        result, err = mcir.CreateSpecWithSpecName(inData)</span>
                case "list":<span class="cov0" title="0">
                        result, err = mcir.ListSpecByParam(nameSpaceID)</span>
                case "get":<span class="cov0" title="0">
                        result, err = mcir.GetSpecByParam(nameSpaceID, resourceID)</span>
                case "list-csp":<span class="cov0" title="0">
                        result, err = mcir.ListLookupSpecByParam(connConfigName)</span>
                case "get-csp":<span class="cov0" title="0">
                        result, err = mcir.GetLookupSpecByParam(connConfigName, cspSpecName)</span>
                case "delete":<span class="cov0" title="0">
                        result, err = mcir.DeleteSpecByParam(nameSpaceID, resourceID, force)</span>
                case "delete-all":<span class="cov0" title="0">
                        result, err = mcir.DeleteAllSpecByParam(nameSpaceID, force)</span>
                case "fetch":<span class="cov0" title="0">
                        result, err = mcir.FetchSpecByParam(nameSpaceID)</span>
                case "filter":<span class="cov0" title="0">
                        result, err = mcir.FilterSpec(inData)</span>
                case "filter-by-range":<span class="cov0" title="0">
                        result, err = mcir.FilterSpecsByRange(inData)</span>
                case "sort":<span class="cov0" title="0">
                        result, err = mcir.SortSpecs(inData)</span>
                case "update":<span class="cov0" title="0">
                        result, err = mcir.UpdateSpec(inData)</span>
                }
        case "mcis":<span class="cov0" title="0">
                switch cmd.Name() </span>{
                case "create":<span class="cov0" title="0">
                        result, err = mcis.CreateMcis(inData)</span>
                case "list":<span class="cov0" title="0">
                        result, err = mcis.ListMcisByParam(nameSpaceID)</span>
                case "get":<span class="cov0" title="0">
                        result, err = mcis.GetMcisInfoByParam(nameSpaceID, mcisID)</span>
                case "delete":<span class="cov0" title="0">
                        result, err = mcis.DeleteMcisByParam(nameSpaceID, mcisID)</span>
                case "delete-all":<span class="cov0" title="0">
                        result, err = mcis.DeleteAllMcisByParam(nameSpaceID)</span>
                case "status-list":<span class="cov0" title="0">
                        result, err = mcis.ListMcisStatusByParam(nameSpaceID)</span>
                case "status":<span class="cov0" title="0">
                        result, err = mcis.GetMcisStatusByParam(nameSpaceID, mcisID)</span>
                case "suspend":<span class="cov0" title="0">
                        result, err = mcis.ControlMcisByParam(nameSpaceID, mcisID, "suspend")</span>
                case "resume":<span class="cov0" title="0">
                        result, err = mcis.ControlMcisByParam(nameSpaceID, mcisID, "resume")</span>
                case "reboot":<span class="cov0" title="0">
                        result, err = mcis.ControlMcisByParam(nameSpaceID, mcisID, "reboot")</span>
                case "terminate":<span class="cov0" title="0">
                        result, err = mcis.ControlMcisByParam(nameSpaceID, mcisID, "terminate")</span>
                case "add-vm":<span class="cov0" title="0">
                        result, err = mcis.CreateMcisVM(inData)</span>
                case "group-vm":<span class="cov0" title="0">
                        result, err = mcis.CreateMcisVMGroup(inData)</span>
                case "list-vm":<span class="cov0" title="0">
                        result, err = proc.ListMcisVM(mcis, nameSpaceID, mcisID)</span>
                case "get-vm":<span class="cov0" title="0">
                        result, err = mcis.GetMcisVMInfoByParam(nameSpaceID, mcisID, vmID)</span>
                case "del-vm":<span class="cov0" title="0">
                        result, err = mcis.DeleteMcisVMByParam(nameSpaceID, mcisID, vmID)</span>
                case "status-vm":<span class="cov0" title="0">
                        result, err = mcis.GetMcisVMStatusByParam(nameSpaceID, mcisID, vmID)</span>
                case "suspend-vm":<span class="cov0" title="0">
                        result, err = mcis.ControlMcisVMByParam(nameSpaceID, mcisID, vmID, "suspend")</span>
                case "resume-vm":<span class="cov0" title="0">
                        result, err = mcis.ControlMcisVMByParam(nameSpaceID, mcisID, vmID, "resume")</span>
                case "reboot-vm":<span class="cov0" title="0">
                        result, err = mcis.ControlMcisVMByParam(nameSpaceID, mcisID, vmID, "reboot")</span>
                case "terminate-vm":<span class="cov0" title="0">
                        result, err = mcis.ControlMcisVMByParam(nameSpaceID, mcisID, vmID, "terminate")</span>
                case "command":<span class="cov0" title="0">
                        result, err = mcis.CmdMcis(inData)</span>
                case "command-vm":<span class="cov0" title="0">
                        result, err = mcis.CmdMcisVm(inData)</span>
                case "deploy-milkyway":<span class="cov0" title="0">
                        result, err = mcis.InstallAgentToMcis(inData)</span>
                case "benchmark":<span class="cov0" title="0">
                        if action == "all" </span><span class="cov0" title="0">{
                                result, err = mcis.GetAllBenchmarkByParam(nameSpaceID, mcisID, host)
                        }</span> else<span class="cov0" title="0"> {
                                result, err = mcis.GetBenchmarkByParam(nameSpaceID, mcisID, action, host)
                        }</span>
                case "install-mon":<span class="cov0" title="0">
                        result, err = mcis.InstallMonitorAgentToMcis(inData)</span>
                case "get-mon":<span class="cov0" title="0">
                        result, err = mcis.GetMonitorDataByParam(nameSpaceID, mcisID, metric)</span>
                case "create-policy":<span class="cov0" title="0">
                        result, err = mcis.CreateMcisPolicy(inData)</span>
                case "list-policy":<span class="cov0" title="0">
                        result, err = mcis.ListMcisPolicyByParam(nameSpaceID)</span>
                case "get-policy":<span class="cov0" title="0">
                        result, err = mcis.GetMcisPolicyByParam(nameSpaceID, mcisID)</span>
                case "delete-policy":<span class="cov0" title="0">
                        result, err = mcis.DeleteMcisPolicyByParam(nameSpaceID, mcisID)</span>
                case "delete-all-policy":<span class="cov0" title="0">
                        result, err = mcis.DeleteAllMcisPolicyByParam(nameSpaceID)</span>
                }
        case "util":<span class="cov0" title="0">
                switch cmd.Name() </span>{
                case "list-cc":<span class="cov0" title="0">
                        result, err = tbutil.ListConnConfig()</span>
                case "get-cc":<span class="cov0" title="0">
                        result, err = tbutil.GetConnConfigByParam(connConfigName)</span>
                case "list-region":<span class="cov0" title="0">
                        result, err = tbutil.ListRegion()</span>
                case "get-region":<span class="cov0" title="0">
                        result, err = tbutil.GetRegionByParam(regionName)</span>
                case "inspect-mcir":<span class="cov0" title="0">
                        result, err = tbutil.InspectMcirResourcesByParam(connConfigName, resourceType)</span>
                case "inspect-vm":<span class="cov0" title="0">
                        result, err = tbutil.InspectVmResourcesByParam(connConfigName)</span>
                case "list-obj":<span class="cov0" title="0">
                        result, err = tbutil.ListObjectByParam(objKey)</span>
                case "get-obj":<span class="cov0" title="0">
                        result, err = tbutil.GetObjectByParam(objKey)</span>
                case "delete-obj":<span class="cov0" title="0">
                        result, err = tbutil.DeleteObjectByParam(objKey)</span>
                case "delete-all-obj":<span class="cov0" title="0">
                        result, err = tbutil.DeleteAllObjectByParam(objKey)</span>
                }
        case "config":<span class="cov0" title="0">
                switch cmd.Name() </span>{
                case "create":<span class="cov0" title="0">
                        result, err = tbutil.CreateConfig(inData)</span>
                case "list":<span class="cov0" title="0">
                        result, err = tbutil.ListConfig()</span>
                case "get":<span class="cov0" title="0">
                        result, err = tbutil.GetConfigByParam(configId)</span>
                case "delete-all":<span class="cov0" title="0">
                        result, err = tbutil.DeleteAllConfig()</span>
                }
        case "cluster":<span class="cov0" title="0">
                switch cmd.Name() </span>{
                case "create":<span class="cov0" title="0">
                        result, err = mcar.CreateCluster(inData)</span>
                case "list":<span class="cov0" title="0">
                        result, err = mcar.ListClusterByParam(nameSpaceID)</span>
                case "get":<span class="cov0" title="0">
                        result, err = mcar.GetClusterByParam(nameSpaceID, clusterName)</span>
                case "delete":<span class="cov0" title="0">
                        result, err = mcar.DeleteClusterByParam(nameSpaceID, clusterName)</span>
                }
        case "node":<span class="cov0" title="0">
                switch cmd.Name() </span>{
                case "add":<span class="cov0" title="0">
                        result, err = mcar.AddNode(inData)</span>
                case "list":<span class="cov0" title="0">
                        result, err = mcar.ListNodeByParam(nameSpaceID, clusterName)</span>
                case "get":<span class="cov0" title="0">
                        result, err = mcar.GetNodeByParam(nameSpaceID, clusterName, nodeName)</span>
                case "remove":<span class="cov0" title="0">
                        result, err = mcar.RemoveNodeByParam(nameSpaceID, clusterName, nodeName)</span>
                }
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                if outType == "yaml" </span><span class="cov0" title="0">{
                        fmt.Fprintf(cmd.OutOrStdout(), "message: %v\n", err)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Fprintf(cmd.OutOrStdout(), "{\"message\": \"%v\"}\n", err)
                }</span>
        } else<span class="cov0" title="0"> {
                fmt.Fprintf(cmd.OutOrStdout(), "%s\n", result)
        }</span>

}
</pre>
		
		<pre class="file" id="file27" style="display: none">package cmd

import (
        "github.com/spf13/cobra"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// NewHealthyCmd - Ladybug 상태를 수행하는 Cobra Command 생성
func NewHealthyCmd() *cobra.Command <span class="cov0" title="0">{

        healthyCmd := &amp;cobra.Command{
                Use:   "healthy",
                Short: "This is a healthy command for checking ladybug",
                Long:  "This is a healthy command for checking ladybug",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        SetupAndRun(cmd, args)
                }</span>,
        }

        <span class="cov0" title="0">return healthyCmd</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package cmd

import (
        "github.com/spf13/cobra"

        "github.com/jmleefree/actiontest2/src/grpc-api/logger"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// NewImageCmd - Image 관리 기능을 수행하는 Cobra Command 생성
func NewImageCmd() *cobra.Command <span class="cov0" title="0">{

        imageCmd := &amp;cobra.Command{
                Use:   "image",
                Short: "This is a manageable command for image",
                Long:  "This is a manageable command for image",
        }

        //  Adds the commands for application.
        imageCmd.AddCommand(NewImageCreateWithInfoCmd())
        imageCmd.AddCommand(NewImageCreateWithIdCmd())
        imageCmd.AddCommand(NewImageListCmd())
        imageCmd.AddCommand(NewImageListCspCmd())
        imageCmd.AddCommand(NewImageGetCmd())
        imageCmd.AddCommand(NewImageGetCspCmd())
        imageCmd.AddCommand(NewImageDeleteCmd())
        imageCmd.AddCommand(NewImageDeleteAllCmd())
        imageCmd.AddCommand(NewImageFetchCmd())
        imageCmd.AddCommand(NewImageSearchCmd())

        return imageCmd
}</span>

// NewImageCreateWithInfoCmd - Image 생성 기능을 수행하는 Cobra Command 생성
func NewImageCreateWithInfoCmd() *cobra.Command <span class="cov0" title="0">{

        createWithInfoCmd := &amp;cobra.Command{
                Use:   "create",
                Short: "This is create command for image",
                Long:  "This is create command for image",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        readInDataFromFile()
                        if inData == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --indata parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--indata parameter value : \n", inData)
                        logger.Debug("--infile parameter value : ", inFile)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">createWithInfoCmd.PersistentFlags().StringVarP(&amp;inData, "indata", "d", "", "input string data")
        createWithInfoCmd.PersistentFlags().StringVarP(&amp;inFile, "infile", "f", "", "input file path")

        return createWithInfoCmd</span>
}

// NewImageCreateWithIdCmd - Image 생성 기능을 수행하는 Cobra Command 생성
func NewImageCreateWithIdCmd() *cobra.Command <span class="cov0" title="0">{

        createWithIdCmd := &amp;cobra.Command{
                Use:   "create-id",
                Short: "This is create-id command for image",
                Long:  "This is create-id command for image",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        readInDataFromFile()
                        if inData == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --indata parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--indata parameter value : \n", inData)
                        logger.Debug("--infile parameter value : ", inFile)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">createWithIdCmd.PersistentFlags().StringVarP(&amp;inData, "indata", "d", "", "input string data")
        createWithIdCmd.PersistentFlags().StringVarP(&amp;inFile, "infile", "f", "", "input file path")

        return createWithIdCmd</span>
}

// NewImageListCmd - Image 목록 기능을 수행하는 Cobra Command 생성
func NewImageListCmd() *cobra.Command <span class="cov0" title="0">{

        listCmd := &amp;cobra.Command{
                Use:   "list",
                Short: "This is list command for image",
                Long:  "This is list command for image",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--ns parameter value : ", nameSpaceID)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">listCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")

        return listCmd</span>
}

// NewImageListCspCmd - CSP Image 목록 기능을 수행하는 Cobra Command 생성
func NewImageListCspCmd() *cobra.Command <span class="cov0" title="0">{

        listCspCmd := &amp;cobra.Command{
                Use:   "list-csp",
                Short: "This is list-csp command for image",
                Long:  "This is list-csp command for image",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        if connConfigName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --cc parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--cc parameter value : ", connConfigName)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">listCspCmd.PersistentFlags().StringVarP(&amp;connConfigName, "cc", "", "", "connection name")

        return listCspCmd</span>
}

// NewImageGetCmd - Image 조회 기능을 수행하는 Cobra Command 생성
func NewImageGetCmd() *cobra.Command <span class="cov0" title="0">{

        getCmd := &amp;cobra.Command{
                Use:   "get",
                Short: "This is get command for image",
                Long:  "This is get command for image",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">if resourceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --id parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--ns parameter value : ", nameSpaceID)
                        logger.Debug("--id parameter value : ", resourceID)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">getCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")
        getCmd.PersistentFlags().StringVarP(&amp;resourceID, "id", "", "", "image id")

        return getCmd</span>
}

// NewImageGetCspCmd - CSP Image 조회 기능을 수행하는 Cobra Command 생성
func NewImageGetCspCmd() *cobra.Command <span class="cov0" title="0">{

        getCspCmd := &amp;cobra.Command{
                Use:   "get-csp",
                Short: "This is get-csp command for image",
                Long:  "This is get-csp command for image",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        if connConfigName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --cc parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">if cspImageId == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --image parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--cc parameter value : ", connConfigName)
                        logger.Debug("--image parameter value : ", cspImageId)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">getCspCmd.PersistentFlags().StringVarP(&amp;connConfigName, "cc", "", "", "connection name")
        getCspCmd.PersistentFlags().StringVarP(&amp;cspImageId, "image", "", "", "csp image id")

        return getCspCmd</span>
}

// NewImageDeleteCmd - Image 삭제 기능을 수행하는 Cobra Command 생성
func NewImageDeleteCmd() *cobra.Command <span class="cov0" title="0">{

        deleteCmd := &amp;cobra.Command{
                Use:   "delete",
                Short: "This is delete command for image",
                Long:  "This is delete command for image",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">if resourceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --id parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">if force == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --force parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--ns parameter value : ", nameSpaceID)
                        logger.Debug("--id parameter value : ", resourceID)
                        logger.Debug("--force parameter value : ", force)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">deleteCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")
        deleteCmd.PersistentFlags().StringVarP(&amp;resourceID, "id", "", "", "image id")
        deleteCmd.PersistentFlags().StringVarP(&amp;force, "force", "", "false", "force flag")

        return deleteCmd</span>
}

// NewImageDeleteAllCmd - 전체 Image 삭제 기능을 수행하는 Cobra Command 생성
func NewImageDeleteAllCmd() *cobra.Command <span class="cov0" title="0">{

        deleteAllCmd := &amp;cobra.Command{
                Use:   "delete-all",
                Short: "This is delete-all command for image",
                Long:  "This is delete-all command for image",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">if force == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --force parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--ns parameter value : ", nameSpaceID)
                        logger.Debug("--force parameter value : ", force)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">deleteAllCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")
        deleteAllCmd.PersistentFlags().StringVarP(&amp;force, "force", "", "false", "force flag")

        return deleteAllCmd</span>
}

// NewImageFetchCmd - Image Fetch 기능을 수행하는 Cobra Command 생성
func NewImageFetchCmd() *cobra.Command <span class="cov0" title="0">{

        fetchCmd := &amp;cobra.Command{
                Use:   "fetch",
                Short: "This is fetch command for image",
                Long:  "This is fetch command for image",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--ns parameter value : ", nameSpaceID)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">fetchCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")

        return fetchCmd</span>
}

// NewImageSearchCmd - Image 검색 기능을 수행하는 Cobra Command 생성
func NewImageSearchCmd() *cobra.Command <span class="cov0" title="0">{

        searchCmd := &amp;cobra.Command{
                Use:   "search",
                Short: "This is search command for image",
                Long:  "This is search command for image",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        readInDataFromFile()
                        if inData == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --indata parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--indata parameter value : \n", inData)
                        logger.Debug("--infile parameter value : ", inFile)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">searchCmd.PersistentFlags().StringVarP(&amp;inData, "indata", "d", "", "input string data")
        searchCmd.PersistentFlags().StringVarP(&amp;inFile, "infile", "f", "", "input file path")

        return searchCmd</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package cmd

import (
        "github.com/spf13/cobra"

        "github.com/jmleefree/actiontest2/src/grpc-api/logger"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// NewKeypairCmd - Keypair 관리 기능을 수행하는 Cobra Command 생성
func NewKeypairCmd() *cobra.Command <span class="cov0" title="0">{

        keypairCmd := &amp;cobra.Command{
                Use:   "keypair",
                Short: "This is a manageable command for keypair",
                Long:  "This is a manageable command for keypair",
        }

        //  Adds the commands for application.
        keypairCmd.AddCommand(NewKeypairCreateCmd())
        keypairCmd.AddCommand(NewKeypairListCmd())
        keypairCmd.AddCommand(NewKeypairGetCmd())
        keypairCmd.AddCommand(NewKeypairSaveCmd())
        keypairCmd.AddCommand(NewKeypairDeleteCmd())
        keypairCmd.AddCommand(NewKeypairDeleteAllCmd())

        return keypairCmd
}</span>

// NewKeypairCreateCmd - Keypair 생성 기능을 수행하는 Cobra Command 생성
func NewKeypairCreateCmd() *cobra.Command <span class="cov0" title="0">{

        createCmd := &amp;cobra.Command{
                Use:   "create",
                Short: "This is create command for keypair",
                Long:  "This is create command for keypair",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        readInDataFromFile()
                        if inData == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --indata parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--indata parameter value : \n", inData)
                        logger.Debug("--infile parameter value : ", inFile)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">createCmd.PersistentFlags().StringVarP(&amp;inData, "indata", "d", "", "input string data")
        createCmd.PersistentFlags().StringVarP(&amp;inFile, "infile", "f", "", "input file path")

        return createCmd</span>
}

// NewKeypairListCmd - Keypair 목록 기능을 수행하는 Cobra Command 생성
func NewKeypairListCmd() *cobra.Command <span class="cov0" title="0">{

        listCmd := &amp;cobra.Command{
                Use:   "list",
                Short: "This is list command for keypair",
                Long:  "This is list command for keypair",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--ns parameter value : ", nameSpaceID)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">listCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")

        return listCmd</span>
}

// NewKeypairGetCmd - Keypair 조회 기능을 수행하는 Cobra Command 생성
func NewKeypairGetCmd() *cobra.Command <span class="cov0" title="0">{

        getCmd := &amp;cobra.Command{
                Use:   "get",
                Short: "This is get command for keypair",
                Long:  "This is get command for keypair",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">if resourceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --id parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--ns parameter value : ", nameSpaceID)
                        logger.Debug("--id parameter value : ", resourceID)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">getCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")
        getCmd.PersistentFlags().StringVarP(&amp;resourceID, "id", "", "", "keypair id")

        return getCmd</span>
}

// NewKeypairSaveCmd - Keypair 저장 기능을 수행하는 Cobra Command 생성
func NewKeypairSaveCmd() *cobra.Command <span class="cov0" title="0">{

        saveCmd := &amp;cobra.Command{
                Use:   "save",
                Short: "This is save command for keypair",
                Long:  "This is save command for keypair",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">if resourceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --id parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">if sshSaveFileName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --fn parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--ns parameter value : ", nameSpaceID)
                        logger.Debug("--id parameter value : ", resourceID)
                        logger.Debug("--fn parameter value : ", sshSaveFileName)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">saveCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")
        saveCmd.PersistentFlags().StringVarP(&amp;resourceID, "id", "", "", "keypair id")
        saveCmd.PersistentFlags().StringVarP(&amp;sshSaveFileName, "fn", "", "", "ssh key save file name")

        return saveCmd</span>
}

// NewKeypairDeleteCmd - Keypair 삭제 기능을 수행하는 Cobra Command 생성
func NewKeypairDeleteCmd() *cobra.Command <span class="cov0" title="0">{

        deleteCmd := &amp;cobra.Command{
                Use:   "delete",
                Short: "This is delete command for keypair",
                Long:  "This is delete command for keypair",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">if resourceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --id parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">if force == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --force parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--ns parameter value : ", nameSpaceID)
                        logger.Debug("--id parameter value : ", resourceID)
                        logger.Debug("--force parameter value : ", force)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">deleteCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")
        deleteCmd.PersistentFlags().StringVarP(&amp;resourceID, "id", "", "", "keypair id")
        deleteCmd.PersistentFlags().StringVarP(&amp;force, "force", "", "false", "force flag")

        return deleteCmd</span>
}

// NewKeypairDeleteAllCmd - 전체 Keypair 삭제 기능을 수행하는 Cobra Command 생성
func NewKeypairDeleteAllCmd() *cobra.Command <span class="cov0" title="0">{

        deleteAllCmd := &amp;cobra.Command{
                Use:   "delete-all",
                Short: "This is delete-all command for keypair",
                Long:  "This is delete-all command for keypair",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">if force == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --force parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--ns parameter value : ", nameSpaceID)
                        logger.Debug("--force parameter value : ", force)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">deleteAllCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")
        deleteAllCmd.PersistentFlags().StringVarP(&amp;force, "force", "", "false", "force flag")

        return deleteAllCmd</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package cmd

import (
        "github.com/spf13/cobra"

        "github.com/jmleefree/actiontest2/src/grpc-api/logger"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// NewMcisCmd - Mcis 관리 기능을 수행하는 Cobra Command 생성
func NewMcisCmd() *cobra.Command <span class="cov0" title="0">{

        mcisCmd := &amp;cobra.Command{
                Use:   "mcis",
                Short: "This is a manageable command for mcis",
                Long:  "This is a manageable command for mcis",
        }

        //  Adds the commands for application.
        mcisCmd.AddCommand(NewMcisCreateCmd())
        mcisCmd.AddCommand(NewMcisListCmd())
        mcisCmd.AddCommand(NewMcisGetCmd())
        mcisCmd.AddCommand(NewMcisDeleteCmd())
        mcisCmd.AddCommand(NewMcisDeleteAllCmd())
        mcisCmd.AddCommand(NewMcisStatusListCmd())
        mcisCmd.AddCommand(NewMcisStatusCmd())
        mcisCmd.AddCommand(NewMcisSuspendCmd())
        mcisCmd.AddCommand(NewMcisResumeCmd())
        mcisCmd.AddCommand(NewMcisRebootCmd())
        mcisCmd.AddCommand(NewMcisTerminateCmd())

        mcisCmd.AddCommand(NewMcisVmAddCmd())
        mcisCmd.AddCommand(NewMcisVmGroupCmd())
        mcisCmd.AddCommand(NewMcisVmListCmd())
        mcisCmd.AddCommand(NewMcisVmGetCmd())
        mcisCmd.AddCommand(NewMcisVmDeleteCmd())
        mcisCmd.AddCommand(NewMcisVmStatusCmd())
        mcisCmd.AddCommand(NewMcisVmSuspendCmd())
        mcisCmd.AddCommand(NewMcisVmResumeCmd())
        mcisCmd.AddCommand(NewMcisVmRebootCmd())
        mcisCmd.AddCommand(NewMcisVmTerminateCmd())

        mcisCmd.AddCommand(NewCmdMcisCmd())
        mcisCmd.AddCommand(NewCmdMcisVmCmd())

        mcisCmd.AddCommand(NewDeployMilkywayCmd())

        mcisCmd.AddCommand(NewAccessVmCmd())
        mcisCmd.AddCommand(NewBenchmarkCmd())

        mcisCmd.AddCommand(NewInstallMonAgentCmd())
        mcisCmd.AddCommand(NewGetMonDataCmd())

        mcisCmd.AddCommand(NewMcisCreatePolicyCmd())
        mcisCmd.AddCommand(NewMcisListPolicyCmd())
        mcisCmd.AddCommand(NewMcisGetPolicyCmd())
        mcisCmd.AddCommand(NewMcisDeletePolicyCmd())
        mcisCmd.AddCommand(NewMcisDeleteAllPolicyCmd())

        return mcisCmd
}</span>

// NewMcisCreateCmd - Mcis 생성 기능을 수행하는 Cobra Command 생성
func NewMcisCreateCmd() *cobra.Command <span class="cov0" title="0">{

        createCmd := &amp;cobra.Command{
                Use:   "create",
                Short: "This is create command for mcis",
                Long:  "This is create command for mcis",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        readInDataFromFile()
                        if inData == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --indata parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--indata parameter value : \n", inData)
                        logger.Debug("--infile parameter value : ", inFile)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">createCmd.PersistentFlags().StringVarP(&amp;inData, "indata", "d", "", "input string data")
        createCmd.PersistentFlags().StringVarP(&amp;inFile, "infile", "f", "", "input file path")

        return createCmd</span>
}

// NewMcisListCmd - Mcis 목록 기능을 수행하는 Cobra Command 생성
func NewMcisListCmd() *cobra.Command <span class="cov0" title="0">{

        listCmd := &amp;cobra.Command{
                Use:   "list",
                Short: "This is list command for mcis",
                Long:  "This is list command for mcis",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--ns parameter value : ", nameSpaceID)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">listCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")

        return listCmd</span>
}

// NewMcisGetCmd - Mcis 조회 기능을 수행하는 Cobra Command 생성
func NewMcisGetCmd() *cobra.Command <span class="cov0" title="0">{

        getCmd := &amp;cobra.Command{
                Use:   "get",
                Short: "This is get command for mcis",
                Long:  "This is get command for mcis",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">if mcisID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --mcis parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--ns parameter value : ", nameSpaceID)
                        logger.Debug("--mcis parameter value : ", mcisID)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">getCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")
        getCmd.PersistentFlags().StringVarP(&amp;mcisID, "mcis", "", "", "mcis id")

        return getCmd</span>
}

// NewMcisDeleteCmd - Mcis 삭제 기능을 수행하는 Cobra Command 생성
func NewMcisDeleteCmd() *cobra.Command <span class="cov0" title="0">{

        deleteCmd := &amp;cobra.Command{
                Use:   "delete",
                Short: "This is delete command for mcis",
                Long:  "This is delete command for mcis",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">if mcisID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --mcis parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--ns parameter value : ", nameSpaceID)
                        logger.Debug("--mcis parameter value : ", mcisID)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">deleteCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")
        deleteCmd.PersistentFlags().StringVarP(&amp;mcisID, "mcis", "", "", "mcis id")

        return deleteCmd</span>
}

// NewMcisDeleteAllCmd - 전체 Mcis 삭제 기능을 수행하는 Cobra Command 생성
func NewMcisDeleteAllCmd() *cobra.Command <span class="cov0" title="0">{

        deleteAllCmd := &amp;cobra.Command{
                Use:   "delete-all",
                Short: "This is delete-all command for mcis",
                Long:  "This is delete-all command for mcis",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--ns parameter value : ", nameSpaceID)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">deleteAllCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")

        return deleteAllCmd</span>
}

// NewMcisStatusListCmd - Mcis 상태 목록 기능을 수행하는 Cobra Command 생성
func NewMcisStatusListCmd() *cobra.Command <span class="cov0" title="0">{

        statusListCmd := &amp;cobra.Command{
                Use:   "status-list",
                Short: "This is status-list command for mcis",
                Long:  "This is status-list command for mcis",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--ns parameter value : ", nameSpaceID)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">statusListCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")

        return statusListCmd</span>
}

// NewMcisStatusCmd - Mcis 상태 조회 기능을 수행하는 Cobra Command 생성
func NewMcisStatusCmd() *cobra.Command <span class="cov0" title="0">{

        statusCmd := &amp;cobra.Command{
                Use:   "status",
                Short: "This is status command for mcis",
                Long:  "This is status command for mcis",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">if mcisID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --mcis parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--ns parameter value : ", nameSpaceID)
                        logger.Debug("--mcis parameter value : ", mcisID)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">statusCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")
        statusCmd.PersistentFlags().StringVarP(&amp;mcisID, "mcis", "", "", "mcis id")

        return statusCmd</span>
}

// NewMcisSuspendCmd - Mcis Suspend 기능을 수행하는 Cobra Command 생성
func NewMcisSuspendCmd() *cobra.Command <span class="cov0" title="0">{

        suspendCmd := &amp;cobra.Command{
                Use:   "suspend",
                Short: "This is suspend command for mcis",
                Long:  "This is suspend command for mcis",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">if mcisID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --mcis parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--ns parameter value : ", nameSpaceID)
                        logger.Debug("--mcis parameter value : ", mcisID)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">suspendCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")
        suspendCmd.PersistentFlags().StringVarP(&amp;mcisID, "mcis", "", "", "mcis id")

        return suspendCmd</span>
}

// NewMcisResumeCmd - Mcis Resume 기능을 수행하는 Cobra Command 생성
func NewMcisResumeCmd() *cobra.Command <span class="cov0" title="0">{

        resumeCmd := &amp;cobra.Command{
                Use:   "resume",
                Short: "This is resume command for mcis",
                Long:  "This is resume command for mcis",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">if mcisID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --mcis parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--ns parameter value : ", nameSpaceID)
                        logger.Debug("--mcis parameter value : ", mcisID)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">resumeCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")
        resumeCmd.PersistentFlags().StringVarP(&amp;mcisID, "mcis", "", "", "mcis id")

        return resumeCmd</span>
}

// NewMcisRebootCmd - Mcis Reboot 기능을 수행하는 Cobra Command 생성
func NewMcisRebootCmd() *cobra.Command <span class="cov0" title="0">{

        rebootCmd := &amp;cobra.Command{
                Use:   "reboot",
                Short: "This is reboot command for mcis",
                Long:  "This is reboot command for mcis",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">if mcisID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --mcis parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--ns parameter value : ", nameSpaceID)
                        logger.Debug("--mcis parameter value : ", mcisID)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">rebootCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")
        rebootCmd.PersistentFlags().StringVarP(&amp;mcisID, "mcis", "", "", "mcis id")

        return rebootCmd</span>
}

// NewMcisTerminateCmd - Mcis Terminate 기능을 수행하는 Cobra Command 생성
func NewMcisTerminateCmd() *cobra.Command <span class="cov0" title="0">{

        terminateCmd := &amp;cobra.Command{
                Use:   "terminate",
                Short: "This is terminate command for mcis",
                Long:  "This is terminate command for mcis",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">if mcisID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --mcis parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--ns parameter value : ", nameSpaceID)
                        logger.Debug("--mcis parameter value : ", mcisID)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">terminateCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")
        terminateCmd.PersistentFlags().StringVarP(&amp;mcisID, "mcis", "", "", "mcis id")

        return terminateCmd</span>
}

// NewMcisVmAddCmd - Mcis VM 생성 기능을 수행하는 Cobra Command 생성
func NewMcisVmAddCmd() *cobra.Command <span class="cov0" title="0">{

        vmAddCmd := &amp;cobra.Command{
                Use:   "add-vm",
                Short: "This is add-vm command for mcis",
                Long:  "This is add-vm command for mcis",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        readInDataFromFile()
                        if inData == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --indata parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--indata parameter value : \n", inData)
                        logger.Debug("--infile parameter value : ", inFile)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">vmAddCmd.PersistentFlags().StringVarP(&amp;inData, "indata", "d", "", "input string data")
        vmAddCmd.PersistentFlags().StringVarP(&amp;inFile, "infile", "f", "", "input file path")

        return vmAddCmd</span>
}

// NewMcisVmGroupCmd - Mcis VM 그룹 생성 기능을 수행하는 Cobra Command 생성
func NewMcisVmGroupCmd() *cobra.Command <span class="cov0" title="0">{

        vmGroupCmd := &amp;cobra.Command{
                Use:   "group-vm",
                Short: "This is group-vm command for mcis",
                Long:  "This is group-vm command for mcis",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        readInDataFromFile()
                        if inData == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --indata parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--indata parameter value : \n", inData)
                        logger.Debug("--infile parameter value : ", inFile)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">vmGroupCmd.PersistentFlags().StringVarP(&amp;inData, "indata", "d", "", "input string data")
        vmGroupCmd.PersistentFlags().StringVarP(&amp;inFile, "infile", "f", "", "input file path")

        return vmGroupCmd</span>
}

// NewMcisVmListCmd - Mcis VM 목록 기능을 수행하는 Cobra Command 생성
func NewMcisVmListCmd() *cobra.Command <span class="cov0" title="0">{

        vmListCmd := &amp;cobra.Command{
                Use:   "list-vm",
                Short: "This is list-vm command for mcis",
                Long:  "This is list-vm command for mcis",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">if mcisID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --mcis parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--ns parameter value : ", nameSpaceID)
                        logger.Debug("--mcis parameter value : ", mcisID)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">vmListCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")
        vmListCmd.PersistentFlags().StringVarP(&amp;mcisID, "mcis", "", "", "mcis id")

        return vmListCmd</span>
}

// NewMcisVmGetCmd - Mcis VM 조회 기능을 수행하는 Cobra Command 생성
func NewMcisVmGetCmd() *cobra.Command <span class="cov0" title="0">{

        vmGetCmd := &amp;cobra.Command{
                Use:   "get-vm",
                Short: "This is get-vm command for mcis",
                Long:  "This is get-vm command for mcis",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">if mcisID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --mcis parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">if vmID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --vm parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--ns parameter value : ", nameSpaceID)
                        logger.Debug("--mcis parameter value : ", mcisID)
                        logger.Debug("--vm parameter value : ", vmID)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">vmGetCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")
        vmGetCmd.PersistentFlags().StringVarP(&amp;mcisID, "mcis", "", "", "mcis id")
        vmGetCmd.PersistentFlags().StringVarP(&amp;vmID, "vm", "", "", "mcis vm id")

        return vmGetCmd</span>
}

// NewMcisVmDeleteCmd - Mcis VM 삭제 기능을 수행하는 Cobra Command 생성
func NewMcisVmDeleteCmd() *cobra.Command <span class="cov0" title="0">{

        vmDeleteCmd := &amp;cobra.Command{
                Use:   "del-vm",
                Short: "This is del-vm command for mcis",
                Long:  "This is del-vm command for mcis",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">if mcisID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --mcis parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">if vmID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --vm parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--ns parameter value : ", nameSpaceID)
                        logger.Debug("--mcis parameter value : ", mcisID)
                        logger.Debug("--vm parameter value : ", vmID)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">vmDeleteCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")
        vmDeleteCmd.PersistentFlags().StringVarP(&amp;mcisID, "mcis", "", "", "mcis id")
        vmDeleteCmd.PersistentFlags().StringVarP(&amp;vmID, "vm", "", "", "mcis vm id")

        return vmDeleteCmd</span>
}

// NewMcisVmStatusCmd - Mcis VM 상태 조회 기능을 수행하는 Cobra Command 생성
func NewMcisVmStatusCmd() *cobra.Command <span class="cov0" title="0">{

        vmStatusCmd := &amp;cobra.Command{
                Use:   "status-vm",
                Short: "This is status-vm command for mcis",
                Long:  "This is status-vm command for mcis",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">if mcisID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --mcis parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">if vmID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --vm parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--ns parameter value : ", nameSpaceID)
                        logger.Debug("--mcis parameter value : ", mcisID)
                        logger.Debug("--vm parameter value : ", vmID)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">vmStatusCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")
        vmStatusCmd.PersistentFlags().StringVarP(&amp;mcisID, "mcis", "", "", "mcis id")
        vmStatusCmd.PersistentFlags().StringVarP(&amp;vmID, "vm", "", "", "mcis vm id")

        return vmStatusCmd</span>
}

// NewMcisVmSuspendCmd - Mcis VM Suspend 기능을 수행하는 Cobra Command 생성
func NewMcisVmSuspendCmd() *cobra.Command <span class="cov0" title="0">{

        vmSuspendCmd := &amp;cobra.Command{
                Use:   "suspend-vm",
                Short: "This is suspend-vm command for mcis",
                Long:  "This is suspend-vm command for mcis",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">if mcisID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --mcis parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">if vmID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --vm parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--ns parameter value : ", nameSpaceID)
                        logger.Debug("--mcis parameter value : ", mcisID)
                        logger.Debug("--vm parameter value : ", vmID)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">vmSuspendCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")
        vmSuspendCmd.PersistentFlags().StringVarP(&amp;mcisID, "mcis", "", "", "mcis id")
        vmSuspendCmd.PersistentFlags().StringVarP(&amp;vmID, "vm", "", "", "mcis vm id")

        return vmSuspendCmd</span>
}

// NewMcisVmResumeCmd - Mcis VM Resume 기능을 수행하는 Cobra Command 생성
func NewMcisVmResumeCmd() *cobra.Command <span class="cov0" title="0">{

        vmResumeCmd := &amp;cobra.Command{
                Use:   "resume-vm",
                Short: "This is resume-vm command for mcis",
                Long:  "This is resume-vm command for mcis",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">if mcisID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --mcis parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">if vmID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --vm parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--ns parameter value : ", nameSpaceID)
                        logger.Debug("--mcis parameter value : ", mcisID)
                        logger.Debug("--vm parameter value : ", vmID)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">vmResumeCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")
        vmResumeCmd.PersistentFlags().StringVarP(&amp;mcisID, "mcis", "", "", "mcis id")
        vmResumeCmd.PersistentFlags().StringVarP(&amp;vmID, "vm", "", "", "mcis vm id")

        return vmResumeCmd</span>
}

// NewMcisVmRebootCmd - Mcis VM Reboot 기능을 수행하는 Cobra Command 생성
func NewMcisVmRebootCmd() *cobra.Command <span class="cov0" title="0">{

        vmRebootCmd := &amp;cobra.Command{
                Use:   "reboot-vm",
                Short: "This is reboot-vm command for mcis",
                Long:  "This is reboot-vm command for mcis",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">if mcisID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --mcis parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">if vmID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --vm parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--ns parameter value : ", nameSpaceID)
                        logger.Debug("--mcis parameter value : ", mcisID)
                        logger.Debug("--vm parameter value : ", vmID)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">vmRebootCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")
        vmRebootCmd.PersistentFlags().StringVarP(&amp;mcisID, "mcis", "", "", "mcis id")
        vmRebootCmd.PersistentFlags().StringVarP(&amp;vmID, "vm", "", "", "mcis vm id")

        return vmRebootCmd</span>
}

// NewMcisVmTerminateCmd - Mcis VM Terminate 기능을 수행하는 Cobra Command 생성
func NewMcisVmTerminateCmd() *cobra.Command <span class="cov0" title="0">{

        vmTerminateCmd := &amp;cobra.Command{
                Use:   "terminate-vm",
                Short: "This is terminate-vm command for mcis",
                Long:  "This is terminate-vm command for mcis",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">if mcisID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --mcis parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">if vmID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --vm parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--ns parameter value : ", nameSpaceID)
                        logger.Debug("--mcis parameter value : ", mcisID)
                        logger.Debug("--vm parameter value : ", vmID)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">vmTerminateCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")
        vmTerminateCmd.PersistentFlags().StringVarP(&amp;mcisID, "mcis", "", "", "mcis id")
        vmTerminateCmd.PersistentFlags().StringVarP(&amp;vmID, "vm", "", "", "mcis vm id")

        return vmTerminateCmd</span>
}

// NewCmdMcisCmd - MCIS 명령 실행 기능을 수행하는 Cobra Command 생성
func NewCmdMcisCmd() *cobra.Command <span class="cov0" title="0">{

        mcisCmdCmd := &amp;cobra.Command{
                Use:   "command",
                Short: "This is execution command for mcis",
                Long:  "This is execution command for mcis",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        readInDataFromFile()
                        if inData == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --indata parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--indata parameter value : \n", inData)
                        logger.Debug("--infile parameter value : ", inFile)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">mcisCmdCmd.PersistentFlags().StringVarP(&amp;inData, "indata", "d", "", "input string data")
        mcisCmdCmd.PersistentFlags().StringVarP(&amp;inFile, "infile", "f", "", "input file path")

        return mcisCmdCmd</span>
}

// NewCmdMcisVmCmd - MCIS VM 명령 실행 기능을 수행하는 Cobra Command 생성
func NewCmdMcisVmCmd() *cobra.Command <span class="cov0" title="0">{

        vmCmdCmd := &amp;cobra.Command{
                Use:   "command-vm",
                Short: "This is command-vm command for mcis",
                Long:  "This is command-vm command for mcis",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        readInDataFromFile()
                        if inData == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --indata parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--indata parameter value : \n", inData)
                        logger.Debug("--infile parameter value : ", inFile)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">vmCmdCmd.PersistentFlags().StringVarP(&amp;inData, "indata", "d", "", "input string data")
        vmCmdCmd.PersistentFlags().StringVarP(&amp;inFile, "infile", "f", "", "input file path")

        return vmCmdCmd</span>
}

// NewDeployMilkywayCmd - MCIS Agent 설치 기능을 수행하는 Cobra Command 생성
func NewDeployMilkywayCmd() *cobra.Command <span class="cov0" title="0">{

        deployMilkywayCmd := &amp;cobra.Command{
                Use:   "deploy-milkyway",
                Short: "This is deploy-milkyway command for mcis",
                Long:  "This is deploy-milkyway command for mcis",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        readInDataFromFile()
                        if inData == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --indata parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--indata parameter value : \n", inData)
                        logger.Debug("--infile parameter value : ", inFile)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">deployMilkywayCmd.PersistentFlags().StringVarP(&amp;inData, "indata", "d", "", "input string data")
        deployMilkywayCmd.PersistentFlags().StringVarP(&amp;inFile, "infile", "f", "", "input file path")

        return deployMilkywayCmd</span>
}

// NewAccessVmCmd - MCIS VM 에 SSH 접속 기능을 수행하는 Cobra Command 생성
func NewAccessVmCmd() *cobra.Command <span class="cov0" title="0">{

        accessVmCmd := &amp;cobra.Command{
                Use:   "access-vm",
                Short: "This is access-vm command for mcis",
                Long:  "This is access-vm command for mcis",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        SetupAndRun(cmd, args)
                }</span>,
        }

        <span class="cov0" title="0">return accessVmCmd</span>
}

// NewBenchmarkCmd - MCIS VM 에 벤치마크 기능을 수행하는 Cobra Command 생성
func NewBenchmarkCmd() *cobra.Command <span class="cov0" title="0">{

        benchmarkCmd := &amp;cobra.Command{
                Use:   "benchmark",
                Short: "This is benchmark command for mcis",
                Long:  "This is benchmark command for mcis",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">if mcisID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --mcis parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--ns parameter value : ", nameSpaceID)
                        logger.Debug("--mcis parameter value : ", mcisID)
                        logger.Debug("--action parameter value : ", action)
                        logger.Debug("--host parameter value : ", host)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">benchmarkCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")
        benchmarkCmd.PersistentFlags().StringVarP(&amp;mcisID, "mcis", "", "", "mcis id")
        benchmarkCmd.PersistentFlags().StringVarP(&amp;action, "action", "", "all", "action name")
        benchmarkCmd.PersistentFlags().StringVarP(&amp;host, "host", "", "localhost", "target host ip address")

        return benchmarkCmd</span>
}

// NewInstallMonAgentCmd - MCIS Monitor Agent 설치 기능을 수행하는 Cobra Command 생성
func NewInstallMonAgentCmd() *cobra.Command <span class="cov0" title="0">{

        installMonCmd := &amp;cobra.Command{
                Use:   "install-mon",
                Short: "This is install-mon command for mcis",
                Long:  "This is install-mon command for mcis",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        readInDataFromFile()
                        if inData == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --indata parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--indata parameter value : \n", inData)
                        logger.Debug("--infile parameter value : ", inFile)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">installMonCmd.PersistentFlags().StringVarP(&amp;inData, "indata", "d", "", "input string data")
        installMonCmd.PersistentFlags().StringVarP(&amp;inFile, "infile", "f", "", "input file path")

        return installMonCmd</span>
}

// NewGetMonDataCmd - MCIS Monitor 정보 조회 기능을 수행하는 Cobra Command 생성
func NewGetMonDataCmd() *cobra.Command <span class="cov0" title="0">{

        getMonCmd := &amp;cobra.Command{
                Use:   "get-mon",
                Short: "This is get-mon command for mcis",
                Long:  "This is get-mon command for mcis",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">if mcisID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --mcis parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">if metric == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --metric parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--ns parameter value : ", nameSpaceID)
                        logger.Debug("--mcis parameter value : ", mcisID)
                        logger.Debug("--metric parameter value : ", metric)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">getMonCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")
        getMonCmd.PersistentFlags().StringVarP(&amp;mcisID, "mcis", "", "", "mcis id")
        getMonCmd.PersistentFlags().StringVarP(&amp;metric, "metric", "", "", "metric")

        return getMonCmd</span>
}

// NewMcisCreatePolicyCmd - Mcis Policy 생성 기능을 수행하는 Cobra Command 생성
func NewMcisCreatePolicyCmd() *cobra.Command <span class="cov0" title="0">{

        createPolicyCmd := &amp;cobra.Command{
                Use:   "create-policy",
                Short: "This is create-policy command for mcis",
                Long:  "This is create-policy command for mcis",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        readInDataFromFile()
                        if inData == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --indata parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--indata parameter value : \n", inData)
                        logger.Debug("--infile parameter value : ", inFile)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">createPolicyCmd.PersistentFlags().StringVarP(&amp;inData, "indata", "d", "", "input string data")
        createPolicyCmd.PersistentFlags().StringVarP(&amp;inFile, "infile", "f", "", "input file path")

        return createPolicyCmd</span>
}

// NewMcisListPolicyCmd - Mcis Policy 목록 기능을 수행하는 Cobra Command 생성
func NewMcisListPolicyCmd() *cobra.Command <span class="cov0" title="0">{

        listPolicyCmd := &amp;cobra.Command{
                Use:   "list-policy",
                Short: "This is list-policy command for mcis",
                Long:  "This is list-policy command for mcis",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>

                        <span class="cov0" title="0">logger.Debug("--ns parameter value : ", nameSpaceID)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">listPolicyCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")

        return listPolicyCmd</span>
}

// NewMcisGetPolicyCmd - Mcis Policy 조회 기능을 수행하는 Cobra Command 생성
func NewMcisGetPolicyCmd() *cobra.Command <span class="cov0" title="0">{

        getPolicyCmd := &amp;cobra.Command{
                Use:   "get-policy",
                Short: "This is get-policy command for mcis",
                Long:  "This is get-policy command for mcis",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">if mcisID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --mcis parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--ns parameter value : ", nameSpaceID)
                        logger.Debug("--mcis parameter value : ", mcisID)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">getPolicyCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")
        getPolicyCmd.PersistentFlags().StringVarP(&amp;mcisID, "mcis", "", "", "mcis id")

        return getPolicyCmd</span>
}

// NewMcisDeletePolicyCmd - Mcis Policy 삭제 기능을 수행하는 Cobra Command 생성
func NewMcisDeletePolicyCmd() *cobra.Command <span class="cov0" title="0">{

        deletePolicyCmd := &amp;cobra.Command{
                Use:   "delete-policy",
                Short: "This is delete-policy command for mcis",
                Long:  "This is delete-policy command for mcis",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">if mcisID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --mcis parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--ns parameter value : ", nameSpaceID)
                        logger.Debug("--mcis parameter value : ", mcisID)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">deletePolicyCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")
        deletePolicyCmd.PersistentFlags().StringVarP(&amp;mcisID, "mcis", "", "", "mcis id")

        return deletePolicyCmd</span>
}

// NewMcisDeleteAllPolicyCmd - 전체 Mcis Policy 삭제 기능을 수행하는 Cobra Command 생성
func NewMcisDeleteAllPolicyCmd() *cobra.Command <span class="cov0" title="0">{

        deleteAllPolicyCmd := &amp;cobra.Command{
                Use:   "delete-all-policy",
                Short: "This is delete-all-policy command for mcis",
                Long:  "This is delete-all-policy command for mcis",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--ns parameter value : ", nameSpaceID)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">deleteAllPolicyCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")

        return deleteAllPolicyCmd</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package cmd

import (
        "github.com/spf13/cobra"

        "github.com/jmleefree/actiontest2/src/grpc-api/logger"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// NewNameSpaceCmd - Namespace 관리 기능을 수행하는 Cobra Command 생성
func NewNameSpaceCmd() *cobra.Command <span class="cov0" title="0">{

        nameSpaceCmd := &amp;cobra.Command{
                Use:   "namespace",
                Short: "This is a manageable command for namespace",
                Long:  "This is a manageable command for namespace",
        }

        //  Adds the commands for application.
        nameSpaceCmd.AddCommand(NewNameSpaceCreateCmd())
        nameSpaceCmd.AddCommand(NewNameSpaceListCmd())
        nameSpaceCmd.AddCommand(NewNameSpaceGetCmd())
        nameSpaceCmd.AddCommand(NewNameSpaceDeleteCmd())

        return nameSpaceCmd
}</span>

// NewNameSpaceCreateCmd - Namespace 생성 기능을 수행하는 Cobra Command 생성
func NewNameSpaceCreateCmd() *cobra.Command <span class="cov0" title="0">{

        createCmd := &amp;cobra.Command{
                Use:   "create",
                Short: "This is create command for namespace",
                Long:  "This is create command for namespace",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        readInDataFromFile()
                        if inData == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --indata parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--indata parameter value : \n", inData)
                        logger.Debug("--infile parameter value : ", inFile)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">createCmd.PersistentFlags().StringVarP(&amp;inData, "indata", "d", "", "input string data")
        createCmd.PersistentFlags().StringVarP(&amp;inFile, "infile", "f", "", "input file path")

        return createCmd</span>
}

// NewNameSpaceListCmd - Namespace 목록 기능을 수행하는 Cobra Command 생성
func NewNameSpaceListCmd() *cobra.Command <span class="cov0" title="0">{

        listCmd := &amp;cobra.Command{
                Use:   "list",
                Short: "This is list command for namespace",
                Long:  "This is list command for namespace",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        SetupAndRun(cmd, args)
                }</span>,
        }

        <span class="cov0" title="0">return listCmd</span>
}

// NewNameSpaceGetCmd - Namespace 조회 기능을 수행하는 Cobra Command 생성
func NewNameSpaceGetCmd() *cobra.Command <span class="cov0" title="0">{

        getCmd := &amp;cobra.Command{
                Use:   "get",
                Short: "This is get command for namespace",
                Long:  "This is get command for namespace",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--ns parameter value : ", nameSpaceID)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">getCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")

        return getCmd</span>
}

// NewNameSpaceDeleteCmd - Namespace 삭제 기능을 수행하는 Cobra Command 생성
func NewNameSpaceDeleteCmd() *cobra.Command <span class="cov0" title="0">{

        deleteCmd := &amp;cobra.Command{
                Use:   "delete",
                Short: "This is delete command for namespace",
                Long:  "This is delete command for namespace",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--ns parameter value : ", nameSpaceID)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">deleteCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")

        return deleteCmd</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package cmd

import (
        "github.com/spf13/cobra"

        "github.com/jmleefree/actiontest2/src/grpc-api/logger"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// NewNetworkCmd - VNet 관리 기능을 수행하는 Cobra Command 생성
func NewNetworkCmd() *cobra.Command <span class="cov0" title="0">{

        networkCmd := &amp;cobra.Command{
                Use:   "network",
                Short: "This is a manageable command for network",
                Long:  "This is a manageable command for network",
        }

        //  Adds the commands for application.
        networkCmd.AddCommand(NewNetworkCreateCmd())
        networkCmd.AddCommand(NewNetworkListCmd())
        networkCmd.AddCommand(NewNetworkGetCmd())
        networkCmd.AddCommand(NewNetworkDeleteCmd())
        networkCmd.AddCommand(NewNetworkDeleteAllCmd())

        return networkCmd
}</span>

// NewNetworkCreateCmd - VNet 생성 기능을 수행하는 Cobra Command 생성
func NewNetworkCreateCmd() *cobra.Command <span class="cov0" title="0">{

        createCmd := &amp;cobra.Command{
                Use:   "create",
                Short: "This is create command for network",
                Long:  "This is create command for network",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        readInDataFromFile()
                        if inData == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --indata parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--indata parameter value : \n", inData)
                        logger.Debug("--infile parameter value : ", inFile)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">createCmd.PersistentFlags().StringVarP(&amp;inData, "indata", "d", "", "input string data")
        createCmd.PersistentFlags().StringVarP(&amp;inFile, "infile", "f", "", "input file path")

        return createCmd</span>
}

// NewNetworkListCmd - VNet 목록 기능을 수행하는 Cobra Command 생성
func NewNetworkListCmd() *cobra.Command <span class="cov0" title="0">{

        listCmd := &amp;cobra.Command{
                Use:   "list",
                Short: "This is list command for network",
                Long:  "This is list command for network",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--ns parameter value : ", nameSpaceID)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">listCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")

        return listCmd</span>
}

// NewNetworkGetCmd - VNet 조회 기능을 수행하는 Cobra Command 생성
func NewNetworkGetCmd() *cobra.Command <span class="cov0" title="0">{

        getCmd := &amp;cobra.Command{
                Use:   "get",
                Short: "This is get command for network",
                Long:  "This is get command for network",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">if resourceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --id parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--ns parameter value : ", nameSpaceID)
                        logger.Debug("--id parameter value : ", resourceID)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">getCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")
        getCmd.PersistentFlags().StringVarP(&amp;resourceID, "id", "", "", "network id")

        return getCmd</span>
}

// NewNetworkDeleteCmd - VNet 삭제 기능을 수행하는 Cobra Command 생성
func NewNetworkDeleteCmd() *cobra.Command <span class="cov0" title="0">{

        deleteCmd := &amp;cobra.Command{
                Use:   "delete",
                Short: "This is delete command for network",
                Long:  "This is delete command for network",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">if resourceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --id parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">if force == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --force parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--ns parameter value : ", nameSpaceID)
                        logger.Debug("--id parameter value : ", resourceID)
                        logger.Debug("--force parameter value : ", force)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">deleteCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")
        deleteCmd.PersistentFlags().StringVarP(&amp;resourceID, "id", "", "", "network id")
        deleteCmd.PersistentFlags().StringVarP(&amp;force, "force", "", "false", "force flag")

        return deleteCmd</span>
}

// NewNetworkDeleteAllCmd - 전체 VNet 삭제 기능을 수행하는 Cobra Command 생성
func NewNetworkDeleteAllCmd() *cobra.Command <span class="cov0" title="0">{

        deleteAllCmd := &amp;cobra.Command{
                Use:   "delete-all",
                Short: "This is delete-all command for network",
                Long:  "This is delete-all command for network",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">if force == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --force parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--ns parameter value : ", nameSpaceID)
                        logger.Debug("--force parameter value : ", force)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">deleteAllCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")
        deleteAllCmd.PersistentFlags().StringVarP(&amp;force, "force", "", "false", "force flag")

        return deleteAllCmd</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package cmd

import (
        "github.com/spf13/cobra"

        "github.com/jmleefree/actiontest2/src/grpc-api/logger"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// NewNodeCmd - Cloud Node 관리 기능을 수행하는 Cobra Command 생성
func NewNodeCmd() *cobra.Command <span class="cov0" title="0">{

        nodeCmd := &amp;cobra.Command{
                Use:   "node",
                Short: "This is a manageable command for cloud node",
                Long:  "This is a manageable command for cloud node",
        }

        //  Adds the commands for application.
        nodeCmd.AddCommand(NewNodeAddCmd())
        nodeCmd.AddCommand(NewNodeListCmd())
        nodeCmd.AddCommand(NewNodeGetCmd())
        nodeCmd.AddCommand(NewNodeRemoveCmd())

        return nodeCmd
}</span>

// NewNodeAddCmd - Cloud Node 생성 기능을 수행하는 Cobra Command 생성
func NewNodeAddCmd() *cobra.Command <span class="cov0" title="0">{

        addCmd := &amp;cobra.Command{
                Use:   "add",
                Short: "This is add command for cloud node",
                Long:  "This is add command for cloud node",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        readInDataFromFile()
                        if inData == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --indata parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--indata parameter value : \n", inData)
                        logger.Debug("--infile parameter value : ", inFile)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">addCmd.PersistentFlags().StringVarP(&amp;inData, "indata", "d", "", "input string data")
        addCmd.PersistentFlags().StringVarP(&amp;inFile, "infile", "f", "", "input file path")

        return addCmd</span>
}

// NewNodeListCmd - Cloud Node 목록 기능을 수행하는 Cobra Command 생성
func NewNodeListCmd() *cobra.Command <span class="cov0" title="0">{

        listCmd := &amp;cobra.Command{
                Use:   "list",
                Short: "This is list command for cloud node",
                Long:  "This is list command for cloud node",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">if clusterName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --cluster parameter")
                                return
                        }</span>

                        <span class="cov0" title="0">logger.Debug("--ns parameter value : ", nameSpaceID)
                        logger.Debug("--cluster parameter value : ", clusterName)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">listCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")
        listCmd.PersistentFlags().StringVarP(&amp;clusterName, "cluster", "", "", "cluster name")

        return listCmd</span>
}

// NewNodeGetCmd - Cloud Node 조회 기능을 수행하는 Cobra Command 생성
func NewNodeGetCmd() *cobra.Command <span class="cov0" title="0">{

        getCmd := &amp;cobra.Command{
                Use:   "get",
                Short: "This is get command for cloud node",
                Long:  "This is get command for cloud node",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">if clusterName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --cluster parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">if nodeName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --node parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--ns parameter value : ", nameSpaceID)
                        logger.Debug("--cluster parameter value : ", clusterName)
                        logger.Debug("--node parameter value : ", nodeName)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">getCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")
        getCmd.PersistentFlags().StringVarP(&amp;clusterName, "cluster", "", "", "cluster name")
        getCmd.PersistentFlags().StringVarP(&amp;nodeName, "node", "", "", "node name")

        return getCmd</span>
}

// NewNodeRemoveCmd - Cloud Node 삭제 기능을 수행하는 Cobra Command 생성
func NewNodeRemoveCmd() *cobra.Command <span class="cov0" title="0">{

        removeCmd := &amp;cobra.Command{
                Use:   "remove",
                Short: "This is remove command for cloud node",
                Long:  "This is remove command for cloud node",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">if clusterName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --cluster parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">if nodeName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --node parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--ns parameter value : ", nameSpaceID)
                        logger.Debug("--cluster parameter value : ", clusterName)
                        logger.Debug("--node parameter value : ", nodeName)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">removeCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")
        removeCmd.PersistentFlags().StringVarP(&amp;clusterName, "cluster", "", "", "cluster name")
        removeCmd.PersistentFlags().StringVarP(&amp;nodeName, "node", "", "", "node name")

        return removeCmd</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package cmd

import (
        "github.com/spf13/cobra"

        "github.com/jmleefree/actiontest2/src/grpc-api/logger"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// NewRegionCmd - Region 관리 기능을 수행하는 Cobra Command 생성
func NewRegionCmd() *cobra.Command <span class="cov0" title="0">{

        regionCmd := &amp;cobra.Command{
                Use:   "region",
                Short: "This is a manageable command for region",
                Long:  "This is a manageable command for region",
        }

        //  Adds the commands for application.
        regionCmd.AddCommand(NewRegionCreateCmd())
        regionCmd.AddCommand(NewRegionListCmd())
        regionCmd.AddCommand(NewRegionGetCmd())
        regionCmd.AddCommand(NewRegionDeleteCmd())

        return regionCmd
}</span>

// NewRegionCreateCmd - Region 생성 기능을 수행하는 Cobra Command 생성
func NewRegionCreateCmd() *cobra.Command <span class="cov0" title="0">{

        createCmd := &amp;cobra.Command{
                Use:   "create",
                Short: "This is create command for region",
                Long:  "This is create command for region",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        readInDataFromFile()
                        if inData == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --indata parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--indata parameter value : \n", inData)
                        logger.Debug("--infile parameter value : ", inFile)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">createCmd.PersistentFlags().StringVarP(&amp;inData, "indata", "d", "", "input string data")
        createCmd.PersistentFlags().StringVarP(&amp;inFile, "infile", "f", "", "input file path")

        return createCmd</span>
}

// NewRegionListCmd - Region 목록 기능을 수행하는 Cobra Command 생성
func NewRegionListCmd() *cobra.Command <span class="cov0" title="0">{

        listCmd := &amp;cobra.Command{
                Use:   "list",
                Short: "This is list command for region",
                Long:  "This is list command for region",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        SetupAndRun(cmd, args)
                }</span>,
        }

        <span class="cov0" title="0">return listCmd</span>
}

// NewRegionGetCmd - Region 조회 기능을 수행하는 Cobra Command 생성
func NewRegionGetCmd() *cobra.Command <span class="cov0" title="0">{

        getCmd := &amp;cobra.Command{
                Use:   "get",
                Short: "This is get command for region",
                Long:  "This is get command for region",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        if regionName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --name parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--name parameter value : ", regionName)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">getCmd.PersistentFlags().StringVarP(&amp;regionName, "name", "n", "", "region name")

        return getCmd</span>
}

// NewRegionDeleteCmd - Region 삭제 기능을 수행하는 Cobra Command 생성
func NewRegionDeleteCmd() *cobra.Command <span class="cov0" title="0">{

        deleteCmd := &amp;cobra.Command{
                Use:   "delete",
                Short: "This is delete command for region",
                Long:  "This is delete command for region",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        if regionName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --name parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--name parameter value : ", regionName)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">deleteCmd.PersistentFlags().StringVarP(&amp;regionName, "name", "n", "", "region name")

        return deleteCmd</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">// Package cmd - 어플리케이션 실행을 위한 Cobra 기반의 CLI Commands 기능 제공
package cmd

import (
        "github.com/jmleefree/actiontest2/src/grpc-api/config"
        "github.com/spf13/cobra"
)

// ===== [ Constants and Variables ] =====

const (
        // CLIVersion - cbadm cli 버전
        CLIVersion = "1.0"
)

var (
        configFile string
        inData     string
        inFile     string
        inType     string
        outType    string

        driverName     string
        credentialName string
        regionName     string
        configName     string

        nameSpaceID     string
        resourceID      string
        force           string
        sshSaveFileName string

        option string
        mcisID string
        vmID   string

        connConfigName string

        resourceType string
        cspSpecName  string
        cspImageId   string
        host         string
        action       string
        metric       string

        configId string
        objKey   string

        clusterName string
        nodeName    string

        parser config.Parser
)

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// NewRootCmd - 어플리케이션 진입점으로 사용할 Root Cobra Command 생성
func NewRootCmd() *cobra.Command <span class="cov0" title="0">{

        rootCmd := &amp;cobra.Command{
                Use:   "cbadm",
                Short: "cbadm is a lightweight grpc cli tool",
                Long:  "This is a lightweight grpc cli tool for Cloud-Barista",
        }

        // 옵션 플래그 설정
        rootCmd.PersistentFlags().StringVarP(&amp;configFile, "config", "c", "./grpc_conf.yaml", "config file")
        rootCmd.PersistentFlags().StringVarP(&amp;inType, "input", "i", "yaml", "input format (json/yaml)")
        rootCmd.PersistentFlags().StringVarP(&amp;outType, "output", "o", "yaml", "output format (json/yaml)")

        // Viper 를 사용하는 설정 파서 생성
        parser = config.MakeParser()

        //  Adds the commands for application.
        rootCmd.AddCommand(NewVersionCmd())

        rootCmd.AddCommand(NewDriverCmd())
        rootCmd.AddCommand(NewCredentialCmd())
        rootCmd.AddCommand(NewRegionCmd())
        rootCmd.AddCommand(NewConnectInfosCmd())

        rootCmd.AddCommand(NewNameSpaceCmd())
        rootCmd.AddCommand(NewImageCmd())
        rootCmd.AddCommand(NewNetworkCmd())
        rootCmd.AddCommand(NewSecurityCmd())
        rootCmd.AddCommand(NewKeypairCmd())
        rootCmd.AddCommand(NewSpecCmd())
        rootCmd.AddCommand(NewMcisCmd())

        rootCmd.AddCommand(NewHealthyCmd())
        rootCmd.AddCommand(NewClusterCmd())
        rootCmd.AddCommand(NewNodeCmd())

        return rootCmd
}</span>
</pre>
		
		<pre class="file" id="file36" style="display: none">package cmd

import (
        "github.com/spf13/cobra"

        "github.com/jmleefree/actiontest2/src/grpc-api/logger"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// NewSecurityCmd - Security Group 관리 기능을 수행하는 Cobra Command 생성
func NewSecurityCmd() *cobra.Command <span class="cov0" title="0">{

        securityCmd := &amp;cobra.Command{
                Use:     "securitygroup",
                Aliases: []string{"sg"},
                Short:   "This is a manageable command for securitygroup",
                Long:    "This is a manageable command for securitygroup",
        }

        //  Adds the commands for application.
        securityCmd.AddCommand(NewSecurityCreateCmd())
        securityCmd.AddCommand(NewSecurityListCmd())
        securityCmd.AddCommand(NewSecurityGetCmd())
        securityCmd.AddCommand(NewSecurityDeleteCmd())
        securityCmd.AddCommand(NewSecurityDeleteAllCmd())

        return securityCmd
}</span>

// NewSecurityCreateCmd - Security Group 생성 기능을 수행하는 Cobra Command 생성
func NewSecurityCreateCmd() *cobra.Command <span class="cov0" title="0">{

        createCmd := &amp;cobra.Command{
                Use:   "create",
                Short: "This is create command for securitygroup",
                Long:  "This is create command for securitygroup",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        readInDataFromFile()
                        if inData == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --indata parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--indata parameter value : \n", inData)
                        logger.Debug("--infile parameter value : ", inFile)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">createCmd.PersistentFlags().StringVarP(&amp;inData, "indata", "d", "", "input string data")
        createCmd.PersistentFlags().StringVarP(&amp;inFile, "infile", "f", "", "input file path")

        return createCmd</span>
}

// NewSecurityListCmd - Security Group 목록 기능을 수행하는 Cobra Command 생성
func NewSecurityListCmd() *cobra.Command <span class="cov0" title="0">{

        listCmd := &amp;cobra.Command{
                Use:   "list",
                Short: "This is list command for securitygroup",
                Long:  "This is list command for securitygroup",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--ns parameter value : ", nameSpaceID)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">listCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")

        return listCmd</span>
}

// NewSecurityGetCmd - Security Group 조회 기능을 수행하는 Cobra Command 생성
func NewSecurityGetCmd() *cobra.Command <span class="cov0" title="0">{

        getCmd := &amp;cobra.Command{
                Use:   "get",
                Short: "This is get command for securitygroup",
                Long:  "This is get command for securitygroup",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">if resourceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --id parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--ns parameter value : ", nameSpaceID)
                        logger.Debug("--id parameter value : ", resourceID)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">getCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")
        getCmd.PersistentFlags().StringVarP(&amp;resourceID, "id", "", "", "security id")

        return getCmd</span>
}

// NewSecurityDeleteCmd - Security Group 삭제 기능을 수행하는 Cobra Command 생성
func NewSecurityDeleteCmd() *cobra.Command <span class="cov0" title="0">{

        deleteCmd := &amp;cobra.Command{
                Use:   "delete",
                Short: "This is delete command for securitygroup",
                Long:  "This is delete command for securitygroup",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">if resourceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --id parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">if force == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --force parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--ns parameter value : ", nameSpaceID)
                        logger.Debug("--id parameter value : ", resourceID)
                        logger.Debug("--force parameter value : ", force)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">deleteCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")
        deleteCmd.PersistentFlags().StringVarP(&amp;resourceID, "id", "", "", "security id")
        deleteCmd.PersistentFlags().StringVarP(&amp;force, "force", "", "false", "force flag")

        return deleteCmd</span>
}

// NewSecurityDeleteAllCmd - 전체 Security Group 삭제 기능을 수행하는 Cobra Command 생성
func NewSecurityDeleteAllCmd() *cobra.Command <span class="cov0" title="0">{

        deleteAllCmd := &amp;cobra.Command{
                Use:   "delete-all",
                Short: "This is delete-all command for securitygroup",
                Long:  "This is delete-all command for securitygroup",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">if force == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --force parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--ns parameter value : ", nameSpaceID)
                        logger.Debug("--force parameter value : ", force)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">deleteAllCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")
        deleteAllCmd.PersistentFlags().StringVarP(&amp;force, "force", "", "false", "force flag")

        return deleteAllCmd</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package cmd

import (
        "github.com/spf13/cobra"

        "github.com/jmleefree/actiontest2/src/grpc-api/logger"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// NewSpecCmd - Spec 관리 기능을 수행하는 Cobra Command 생성
func NewSpecCmd() *cobra.Command <span class="cov0" title="0">{

        specCmd := &amp;cobra.Command{
                Use:   "spec",
                Short: "This is a manageable command for spec",
                Long:  "This is a manageable command for spec",
        }

        //  Adds the commands for application.
        specCmd.AddCommand(NewSpecWithInfoCreateCmd())
        specCmd.AddCommand(NewSpecWithIdCreateCmd())
        specCmd.AddCommand(NewSpecListCmd())
        specCmd.AddCommand(NewSpecListCspCmd())
        specCmd.AddCommand(NewSpecGetCmd())
        specCmd.AddCommand(NewSpecGetCspCmd())
        specCmd.AddCommand(NewSpecDeleteCmd())
        specCmd.AddCommand(NewSpecDeleteAllCmd())
        specCmd.AddCommand(NewSpecFetchCmd())
        specCmd.AddCommand(NewSpecFilterCmd())
        specCmd.AddCommand(NewSpecFilterByRangeCmd())
        specCmd.AddCommand(NewSpecSortCmd())
        specCmd.AddCommand(NewSpecUpdateCmd())

        return specCmd
}</span>

// NewSpecWithInfoCreateCmd - Spec 생성 기능을 수행하는 Cobra Command 생성
func NewSpecWithInfoCreateCmd() *cobra.Command <span class="cov0" title="0">{

        createWithInfoCmd := &amp;cobra.Command{
                Use:   "create",
                Short: "This is create command for spec",
                Long:  "This is create command for spec",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        readInDataFromFile()
                        if inData == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --indata parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--indata parameter value : \n", inData)
                        logger.Debug("--infile parameter value : ", inFile)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">createWithInfoCmd.PersistentFlags().StringVarP(&amp;inData, "indata", "d", "", "input string data")
        createWithInfoCmd.PersistentFlags().StringVarP(&amp;inFile, "infile", "f", "", "input file path")

        return createWithInfoCmd</span>
}

// NewSpecWithIdCreateCmd - Spec 생성 기능을 수행하는 Cobra Command 생성
func NewSpecWithIdCreateCmd() *cobra.Command <span class="cov0" title="0">{

        createWithIdCmd := &amp;cobra.Command{
                Use:   "create-id",
                Short: "This is create-id command for spec",
                Long:  "This is create-id command for spec",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        readInDataFromFile()
                        if inData == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --indata parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--indata parameter value : \n", inData)
                        logger.Debug("--infile parameter value : ", inFile)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">createWithIdCmd.PersistentFlags().StringVarP(&amp;inData, "indata", "d", "", "input string data")
        createWithIdCmd.PersistentFlags().StringVarP(&amp;inFile, "infile", "f", "", "input file path")

        return createWithIdCmd</span>
}

// NewSpecListCmd - Spec 목록 기능을 수행하는 Cobra Command 생성
func NewSpecListCmd() *cobra.Command <span class="cov0" title="0">{

        listCmd := &amp;cobra.Command{
                Use:   "list",
                Short: "This is list command for spec",
                Long:  "This is list command for spec",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--ns parameter value : ", nameSpaceID)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">listCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")

        return listCmd</span>
}

// NewSpecListCspCmd - CSP Spec 목록 기능을 수행하는 Cobra Command 생성
func NewSpecListCspCmd() *cobra.Command <span class="cov0" title="0">{

        listCspCmd := &amp;cobra.Command{
                Use:   "list-csp",
                Short: "This is list-csp command for spec",
                Long:  "This is list-csp command for spec",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        if connConfigName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --cc parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--cc parameter value : ", connConfigName)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">listCspCmd.PersistentFlags().StringVarP(&amp;connConfigName, "cc", "", "", "connection name")

        return listCspCmd</span>
}

// NewSpecGetCmd - Spec 조회 기능을 수행하는 Cobra Command 생성
func NewSpecGetCmd() *cobra.Command <span class="cov0" title="0">{

        getCmd := &amp;cobra.Command{
                Use:   "get",
                Short: "This is get command for spec",
                Long:  "This is get command for spec",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">if resourceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --id parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--ns parameter value : ", nameSpaceID)
                        logger.Debug("--id parameter value : ", resourceID)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">getCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")
        getCmd.PersistentFlags().StringVarP(&amp;resourceID, "id", "", "", "spec id")

        return getCmd</span>
}

// NewSpecGetCspCmd - CSP Spec 조회 기능을 수행하는 Cobra Command 생성
func NewSpecGetCspCmd() *cobra.Command <span class="cov0" title="0">{

        getCspCmd := &amp;cobra.Command{
                Use:   "get-csp",
                Short: "This is get-csp command for spec",
                Long:  "This is get-csp command for spec",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        if connConfigName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --cc parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">if cspSpecName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --spec parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--cc parameter value : ", connConfigName)
                        logger.Debug("--spec parameter value : ", cspSpecName)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">getCspCmd.PersistentFlags().StringVarP(&amp;connConfigName, "cc", "", "", "connection name")
        getCspCmd.PersistentFlags().StringVarP(&amp;cspSpecName, "spec", "", "", "csp spec name")

        return getCspCmd</span>
}

// NewSpecDeleteCmd - Spec 삭제 기능을 수행하는 Cobra Command 생성
func NewSpecDeleteCmd() *cobra.Command <span class="cov0" title="0">{

        deleteCmd := &amp;cobra.Command{
                Use:   "delete",
                Short: "This is delete command for spec",
                Long:  "This is delete command for spec",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">if resourceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --id parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">if force == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --force parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--ns parameter value : ", nameSpaceID)
                        logger.Debug("--id parameter value : ", resourceID)
                        logger.Debug("--force parameter value : ", force)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">deleteCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")
        deleteCmd.PersistentFlags().StringVarP(&amp;resourceID, "id", "", "", "spec id")
        deleteCmd.PersistentFlags().StringVarP(&amp;force, "force", "", "false", "force flag")

        return deleteCmd</span>
}

// NewSpecDeleteAllCmd - 전체 Spec 삭제 기능을 수행하는 Cobra Command 생성
func NewSpecDeleteAllCmd() *cobra.Command <span class="cov0" title="0">{

        deleteAllCmd := &amp;cobra.Command{
                Use:   "delete-all",
                Short: "This is delete-all command for spec",
                Long:  "This is delete-all command for spec",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">if force == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --force parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--ns parameter value : ", nameSpaceID)
                        logger.Debug("--force parameter value : ", force)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">deleteAllCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")
        deleteAllCmd.PersistentFlags().StringVarP(&amp;force, "force", "", "false", "force flag")

        return deleteAllCmd</span>
}

// NewSpecFetchCmd - Spec Fetch 기능을 수행하는 Cobra Command 생성
func NewSpecFetchCmd() *cobra.Command <span class="cov0" title="0">{

        fetchCmd := &amp;cobra.Command{
                Use:   "fetch",
                Short: "This is fetch command for spec",
                Long:  "This is fetch command for spec",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        if nameSpaceID == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --ns parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--ns parameter value : ", nameSpaceID)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">fetchCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")

        return fetchCmd</span>
}

// NewSpecFilterCmd
func NewSpecFilterCmd() *cobra.Command <span class="cov0" title="0">{

        filterCmd := &amp;cobra.Command{
                Use:   "filter",
                Short: "This is filter command for spec",
                Long:  "This is filter command for spec",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        /*
                                if nameSpaceID == "" {
                                        logger.Error("failed to validate --ns parameter")
                                        return
                                }
                                logger.Debug("--ns parameter value : ", nameSpaceID)
                        */
                        readInDataFromFile()
                        if inData == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --indata parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--indata parameter value : \n", inData)
                        logger.Debug("--infile parameter value : ", inFile)

                        SetupAndRun(cmd, args)</span>
                },
        }

        //filterCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")
        <span class="cov0" title="0">filterCmd.PersistentFlags().StringVarP(&amp;inData, "indata", "d", "", "input string data")
        filterCmd.PersistentFlags().StringVarP(&amp;inFile, "infile", "f", "", "input file path")

        return filterCmd</span>
}

// NewSpecFilterByRangeCmd
func NewSpecFilterByRangeCmd() *cobra.Command <span class="cov0" title="0">{

        filterByRangeCmd := &amp;cobra.Command{
                Use:   "filter-by-range",
                Short: "This is filter-by-range command for spec",
                Long:  "This is filter-by-range command for spec",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        /*
                                if nameSpaceID == "" {
                                        logger.Error("failed to validate --ns parameter")
                                        return
                                }
                                logger.Debug("--ns parameter value : ", nameSpaceID)
                        */
                        readInDataFromFile()
                        if inData == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --indata parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--indata parameter value : \n", inData)
                        logger.Debug("--infile parameter value : ", inFile)

                        SetupAndRun(cmd, args)</span>
                },
        }

        //filterByRangeCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")
        <span class="cov0" title="0">filterByRangeCmd.PersistentFlags().StringVarP(&amp;inData, "indata", "d", "", "input string data")
        filterByRangeCmd.PersistentFlags().StringVarP(&amp;inFile, "infile", "f", "", "input file path")

        return filterByRangeCmd</span>
}

// NewSpecSortCmd
func NewSpecSortCmd() *cobra.Command <span class="cov0" title="0">{

        sortCmd := &amp;cobra.Command{
                Use:   "sort",
                Short: "This is sort command for spec",
                Long:  "This is sort command for spec",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        /*
                                if nameSpaceID == "" {
                                        logger.Error("failed to validate --ns parameter")
                                        return
                                }
                                logger.Debug("--ns parameter value : ", nameSpaceID)
                        */
                        readInDataFromFile()
                        if inData == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --indata parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--indata parameter value : \n", inData)
                        logger.Debug("--infile parameter value : ", inFile)

                        SetupAndRun(cmd, args)</span>
                },
        }

        //sortCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")
        <span class="cov0" title="0">sortCmd.PersistentFlags().StringVarP(&amp;inData, "indata", "d", "", "input string data")
        sortCmd.PersistentFlags().StringVarP(&amp;inFile, "infile", "f", "", "input file path")

        return sortCmd</span>
}

// NewSpecUpdateCmd
func NewSpecUpdateCmd() *cobra.Command <span class="cov0" title="0">{

        updateCmd := &amp;cobra.Command{
                Use:   "update",
                Short: "This is update command for spec",
                Long:  "This is update command for spec",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        /*
                                if nameSpaceID == "" {
                                        logger.Error("failed to validate --ns parameter")
                                        return
                                }
                                logger.Debug("--ns parameter value : ", nameSpaceID)
                        */
                        readInDataFromFile()
                        if inData == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --indata parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--indata parameter value : \n", inData)
                        logger.Debug("--infile parameter value : ", inFile)

                        SetupAndRun(cmd, args)</span>
                },
        }

        //updateCmd.PersistentFlags().StringVarP(&amp;nameSpaceID, "ns", "", "", "namespace id")
        <span class="cov0" title="0">updateCmd.PersistentFlags().StringVarP(&amp;inData, "indata", "d", "", "input string data")
        updateCmd.PersistentFlags().StringVarP(&amp;inFile, "infile", "f", "", "input file path")

        return updateCmd</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package cmd

import (
        "github.com/spf13/cobra"

        "github.com/jmleefree/actiontest2/src/grpc-api/logger"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// NewUtilCmd - Tumblebug Util 관리 기능을 수행하는 Cobra Command 생성
func NewUtilCmd() *cobra.Command <span class="cov0" title="0">{

        utilCmd := &amp;cobra.Command{
                Use:   "util",
                Short: "This is a manageable command for tumblebug utility",
                Long:  "This is a manageable command for tumblebug utility",
        }

        //  Adds the commands for application.
        utilCmd.AddCommand(NewConnConfigListCmd())
        utilCmd.AddCommand(NewConnConfigGetCmd())

        utilCmd.AddCommand(NewRegionSpiderListCmd())
        utilCmd.AddCommand(NewRegionSpiderGetCmd())

        utilCmd.AddCommand(NewMcirResourcesInspectCmd())
        utilCmd.AddCommand(NewVmResourcesInspectCmd())

        utilCmd.AddCommand(NewObjectListCmd())
        utilCmd.AddCommand(NewObjectGetCmd())
        utilCmd.AddCommand(NewObjectDeleteCmd())
        utilCmd.AddCommand(NewObjectDeleteAllCmd())

        return utilCmd
}</span>

// NewConnConfigListCmd - Connection Config 목록 기능을 수행하는 Cobra Command 생성
func NewConnConfigListCmd() *cobra.Command <span class="cov0" title="0">{

        listCCCmd := &amp;cobra.Command{
                Use:   "list-cc",
                Short: "This is list-cc command for tumblebug utility",
                Long:  "This is list-cc command for tumblebug utility",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        SetupAndRun(cmd, args)
                }</span>,
        }

        <span class="cov0" title="0">return listCCCmd</span>
}

// NewConnConfigGetCmd -  Connection Config 조회 기능을 수행하는 Cobra Command 생성
func NewConnConfigGetCmd() *cobra.Command <span class="cov0" title="0">{

        getCCCmd := &amp;cobra.Command{
                Use:   "get-cc",
                Short: "This is get-cc command for tumblebug utility",
                Long:  "This is get-cc command for tumblebug utility",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        if connConfigName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --cc parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--cc parameter value : ", connConfigName)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">getCCCmd.PersistentFlags().StringVarP(&amp;connConfigName, "cc", "", "", "connection config name")

        return getCCCmd</span>
}

// NewRegionSpiderListCmd - Region 목록 기능을 수행하는 Cobra Command 생성
func NewRegionSpiderListCmd() *cobra.Command <span class="cov0" title="0">{

        listRegionCmd := &amp;cobra.Command{
                Use:   "list-region",
                Short: "This is list-region command for tumblebug utility",
                Long:  "This is list-region command for tumblebug utility",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        SetupAndRun(cmd, args)
                }</span>,
        }

        <span class="cov0" title="0">return listRegionCmd</span>
}

// NewRegionSpiderGetCmd - Region 조회 기능을 수행하는 Cobra Command 생성
func NewRegionSpiderGetCmd() *cobra.Command <span class="cov0" title="0">{

        getRegionCmd := &amp;cobra.Command{
                Use:   "get-region",
                Short: "This is get-region command for tumblebug utility",
                Long:  "This is get-region command for tumblebug utility",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        if regionName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --region parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--region parameter value : ", regionName)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">getRegionCmd.PersistentFlags().StringVarP(&amp;regionName, "region", "", "", "region name")

        return getRegionCmd</span>
}

// NewMcirResourcesInspectCmd - MCIR 리소스 점검 기능을 수행하는 Cobra Command 생성
func NewMcirResourcesInspectCmd() *cobra.Command <span class="cov0" title="0">{

        inspectMcirCmd := &amp;cobra.Command{
                Use:   "inspect-mcir",
                Short: "This is inspect-mcir command for tumblebug utility",
                Long:  "This is inspect-mcir command for tumblebug utility",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        if connConfigName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --cc parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">if resourceType == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --type parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--cc parameter value : ", connConfigName)
                        logger.Debug("--type parameter value : ", resourceType)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">inspectMcirCmd.PersistentFlags().StringVarP(&amp;connConfigName, "cc", "", "", "connection name")
        inspectMcirCmd.PersistentFlags().StringVarP(&amp;resourceType, "type", "", "", "resource type")

        return inspectMcirCmd</span>
}

// NewVmResourcesInspectCmd - VM 리소스 점검 기능을 수행하는 Cobra Command 생성
func NewVmResourcesInspectCmd() *cobra.Command <span class="cov0" title="0">{

        inspectVmCmd := &amp;cobra.Command{
                Use:   "inspect-vm",
                Short: "This is inspect-vm command for tumblebug utility",
                Long:  "This is inspect-vm command for tumblebug utility",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        if connConfigName == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --cc parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--cc parameter value : ", connConfigName)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">inspectVmCmd.PersistentFlags().StringVarP(&amp;connConfigName, "cc", "", "", "connection name")

        return inspectVmCmd</span>
}

// NewObjectListCmd - 객체 목록 기능을 수행하는 Cobra Command 생성
func NewObjectListCmd() *cobra.Command <span class="cov0" title="0">{

        listObjCmd := &amp;cobra.Command{
                Use:   "list-obj",
                Short: "This is list-obj command for tumblebug utility",
                Long:  "This is list-obj command for tumblebug utility",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        if objKey == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --key parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--key parameter value : ", objKey)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">listObjCmd.PersistentFlags().StringVarP(&amp;objKey, "key", "", "", "object key")

        return listObjCmd</span>
}

// NewObjectGetCmd - 객체 조회 기능을 수행하는 Cobra Command 생성
func NewObjectGetCmd() *cobra.Command <span class="cov0" title="0">{

        getObjCmd := &amp;cobra.Command{
                Use:   "get-obj",
                Short: "This is get-obj command for tumblebug utility",
                Long:  "This is get-obj command for tumblebug utility",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        if objKey == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --key parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--key parameter value : ", objKey)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">getObjCmd.PersistentFlags().StringVarP(&amp;objKey, "key", "", "", "object key")

        return getObjCmd</span>
}

// NewObjectDeleteCmd - 객체 삭제 기능을 수행하는 Cobra Command 생성
func NewObjectDeleteCmd() *cobra.Command <span class="cov0" title="0">{

        deleteObjCmd := &amp;cobra.Command{
                Use:   "delete-obj",
                Short: "This is delete-obj command for tumblebug utility",
                Long:  "This is delete-obj command for tumblebug utility",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        if objKey == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --key parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--key parameter value : ", objKey)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">deleteObjCmd.PersistentFlags().StringVarP(&amp;objKey, "key", "", "", "object key")

        return deleteObjCmd</span>
}

// NewObjectDeleteAllCmd - 객체 전체 삭제 기능을 수행하는 Cobra Command 생성
func NewObjectDeleteAllCmd() *cobra.Command <span class="cov0" title="0">{

        deleteAllObjCmd := &amp;cobra.Command{
                Use:   "delete-all-obj",
                Short: "This is delete-all-obj command for tumblebug utility",
                Long:  "This is delete-all-obj command for tumblebug utility",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        logger := logger.NewLogger()
                        if objKey == "" </span><span class="cov0" title="0">{
                                logger.Error("failed to validate --key parameter")
                                return
                        }</span>
                        <span class="cov0" title="0">logger.Debug("--key parameter value : ", objKey)

                        SetupAndRun(cmd, args)</span>
                },
        }

        <span class="cov0" title="0">deleteAllObjCmd.PersistentFlags().StringVarP(&amp;objKey, "key", "", "", "object key")

        return deleteAllObjCmd</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package cmd

import (
        "fmt"

        "github.com/spf13/cobra"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// NewVersionCmd - 버전 표시 기능을 수행하는 Cobra Command 생성
func NewVersionCmd() *cobra.Command <span class="cov0" title="0">{

        versionCmd := &amp;cobra.Command{
                Use:   "version",
                Short: "This is a version command for cbadm",
                Long:  "This is a version command for cbadm",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        fmt.Printf("CBADM CLI VERSION %s\n", CLIVersion)
                }</span>,
        }

        <span class="cov0" title="0">return versionCmd</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package proc

import (
        "encoding/json"
        "fmt"

        sp_api "github.com/cloud-barista/cb-spider/interface/api"
        gc "github.com/cloud-barista/cb-tumblebug/src/api/grpc/common"
)

// ===== [ Constants and Variables ] =====

const (
        // ConfigVersion - 설정 구조에 대한 버전
        ConfigVersion = 1
)

// ===== [ Types ] =====

// ConnectInfosConfig - 연결 정보 목록 구조 정의
type ConnectInfosConfig struct {
        Version         int           `yaml:"Version" json:"Version"`
        ConnectInfoList []ConnectInfo `yaml:"ConnectInfos" json:"ConnectInfos"`
}

// ConnectInfo - 연결 정보 구조 정의
type ConnectInfo struct {
        ConfigName   string         `yaml:"ConfigName" json:"ConfigName"`
        ProviderName string         `yaml:"ProviderName" json:"ProviderName"`
        Driver       DriverInfo     `yaml:"Driver" json:"Driver"`
        Credential   CredentialInfo `yaml:"Credential" json:"Credential"`
        Region       RegionInfo     `yaml:"Region" json:"Region"`
}

// DriverInfo - Driver 정보 구조 정의
type DriverInfo struct {
        DriverName        string `yaml:"DriverName" json:"DriverName"`
        DriverLibFileName string `yaml:"DriverLibFileName" json:"DriverLibFileName"`
}

// CredentialInfo - Credential 정보 구조 정의
type CredentialInfo struct {
        CredentialName   string         `yaml:"CredentialName" json:"CredentialName"`
        KeyValueInfoList []KeyValueInfo `yaml:"KeyValueInfoList" json:"KeyValueInfoList"`
}

// RegionInfo - Region 정보 구조 정의
type RegionInfo struct {
        RegionName       string         `yaml:"RegionName" json:"RegionName"`
        KeyValueInfoList []KeyValueInfo `yaml:"KeyValueInfoList" json:"KeyValueInfoList"`
}

// KeyValueInfo - Key Value 정보 구조 정의
type KeyValueInfo struct {
        Key   string `yaml:"Key" json:"Key"`
        Value string `yaml:"Value" json:"Value"`
}

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// ListConnectInfos - 연결정보 목록 통합 제공
func ListConnectInfos(cim *sp_api.CIMApi) (string, error) <span class="cov0" title="0">{

        holdType, _ := cim.GetOutType()
        cim.SetOutType("json")
        defer cim.SetOutType(holdType)

        result, err := cim.ListConnectionConfig()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">connectConfigList := make(map[string]interface{})
        err = json.Unmarshal([]byte(result), &amp;connectConfigList)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">connectInfoList := []ConnectInfo{}
        if connectConfigList["connectionconfig"] != nil </span><span class="cov0" title="0">{
                for _, m := range connectConfigList["connectionconfig"].([]interface{}) </span><span class="cov0" title="0">{

                        connectConfig := m.(map[string]interface{})

                        connectInfo := ConnectInfo{}
                        connectInfo.ConfigName = fmt.Sprintf("%v", connectConfig["ConfigName"])
                        connectInfo.ProviderName = fmt.Sprintf("%v", connectConfig["ProviderName"])

                        result, err := cim.GetCloudDriverByParam(fmt.Sprintf("%v", connectConfig["DriverName"]))
                        if err != nil </span><span class="cov0" title="0">{
                                return "", err
                        }</span>

                        <span class="cov0" title="0">driverItem := make(map[string]interface{})
                        err = json.Unmarshal([]byte(result), &amp;driverItem)
                        if err != nil </span><span class="cov0" title="0">{
                                return "", err
                        }</span>

                        <span class="cov0" title="0">connectInfo.Driver.DriverName = fmt.Sprintf("%v", driverItem["DriverName"])
                        connectInfo.Driver.DriverLibFileName = fmt.Sprintf("%v", driverItem["DriverLibFileName"])

                        result, err = cim.GetCredentialByParam(fmt.Sprintf("%v", connectConfig["CredentialName"]))
                        if err != nil </span><span class="cov0" title="0">{
                                return "", err
                        }</span>

                        <span class="cov0" title="0">credentialItem := make(map[string]interface{})
                        err = json.Unmarshal([]byte(result), &amp;credentialItem)
                        if err != nil </span><span class="cov0" title="0">{
                                return "", err
                        }</span>

                        <span class="cov0" title="0">connectInfo.Credential.CredentialName = fmt.Sprintf("%v", credentialItem["CredentialName"])
                        err = gc.CopySrcToDest(credentialItem["KeyValueInfoList"], &amp;connectInfo.Credential.KeyValueInfoList)
                        if err != nil </span><span class="cov0" title="0">{
                                return "", err
                        }</span>

                        <span class="cov0" title="0">result, err = cim.GetRegionByParam(fmt.Sprintf("%v", connectConfig["RegionName"]))
                        if err != nil </span><span class="cov0" title="0">{
                                return "", err
                        }</span>

                        <span class="cov0" title="0">regionItem := make(map[string]interface{})
                        err = json.Unmarshal([]byte(result), &amp;regionItem)
                        if err != nil </span><span class="cov0" title="0">{
                                return "", err
                        }</span>

                        <span class="cov0" title="0">connectInfo.Region.RegionName = fmt.Sprintf("%v", regionItem["RegionName"])
                        err = gc.CopySrcToDest(regionItem["KeyValueInfoList"], &amp;connectInfo.Region.KeyValueInfoList)
                        if err != nil </span><span class="cov0" title="0">{
                                return "", err
                        }</span>

                        <span class="cov0" title="0">connectInfoList = append(connectInfoList, connectInfo)</span>
                }
        }

        <span class="cov0" title="0">var cfg ConnectInfosConfig
        cfg.Version = ConfigVersion
        cfg.ConnectInfoList = connectInfoList

        return gc.ConvertToOutput(holdType, &amp;cfg)</span>
}

// GetConnectInfos - 연결정보 통합 제공
func GetConnectInfos(cim *sp_api.CIMApi, configName string) (string, error) <span class="cov0" title="0">{

        holdType, _ := cim.GetOutType()
        cim.SetOutType("json")
        defer cim.SetOutType(holdType)

        result, err := cim.GetConnectionConfigByParam(configName)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">connectConfig := make(map[string]interface{})
        err = json.Unmarshal([]byte(result), &amp;connectConfig)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">connectInfoList := []ConnectInfo{}

        connectInfo := ConnectInfo{}
        connectInfo.ConfigName = fmt.Sprintf("%v", connectConfig["ConfigName"])
        connectInfo.ProviderName = fmt.Sprintf("%v", connectConfig["ProviderName"])

        result, err = cim.GetCloudDriverByParam(fmt.Sprintf("%v", connectConfig["DriverName"]))
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">driverItem := make(map[string]interface{})
        err = json.Unmarshal([]byte(result), &amp;driverItem)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">connectInfo.Driver.DriverName = fmt.Sprintf("%v", driverItem["DriverName"])
        connectInfo.Driver.DriverLibFileName = fmt.Sprintf("%v", driverItem["DriverLibFileName"])

        result, err = cim.GetCredentialByParam(fmt.Sprintf("%v", connectConfig["CredentialName"]))
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">credentialItem := make(map[string]interface{})
        err = json.Unmarshal([]byte(result), &amp;credentialItem)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">connectInfo.Credential.CredentialName = fmt.Sprintf("%v", credentialItem["CredentialName"])
        err = gc.CopySrcToDest(credentialItem["KeyValueInfoList"], &amp;connectInfo.Credential.KeyValueInfoList)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">result, err = cim.GetRegionByParam(fmt.Sprintf("%v", connectConfig["RegionName"]))
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">regionItem := make(map[string]interface{})
        err = json.Unmarshal([]byte(result), &amp;regionItem)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">connectInfo.Region.RegionName = fmt.Sprintf("%v", regionItem["RegionName"])
        err = gc.CopySrcToDest(regionItem["KeyValueInfoList"], &amp;connectInfo.Region.KeyValueInfoList)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">connectInfoList = append(connectInfoList, connectInfo)

        var cfg ConnectInfosConfig
        cfg.Version = ConfigVersion
        cfg.ConnectInfoList = connectInfoList

        return gc.ConvertToOutput(holdType, &amp;cfg)</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package proc

import (
        "encoding/json"
        "fmt"
        "io/ioutil"

        tb_api "github.com/cloud-barista/cb-tumblebug/src/api/grpc/request"
)

// ===== [ Constants and Variables ] =====

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// SaveSshKey - Keypair 파일로 저장
func SaveSshKey(mcir *tb_api.MCIRApi, nameSpaceID string, resourceID string, sshSaveFileName string) (string, error) <span class="cov0" title="0">{

        holdType, _ := mcir.GetOutType()
        mcir.SetOutType("json")

        result, err := mcir.GetSshKeyByParam(nameSpaceID, resourceID)
        mcir.SetOutType(holdType)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">jsonMap := make(map[string]interface{})
        err = json.Unmarshal([]byte(result), &amp;jsonMap)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">privateKey := fmt.Sprintf("%v", jsonMap["privateKey"])
        err = ioutil.WriteFile(sshSaveFileName, []byte(privateKey), 0644)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return "ssh key file saved", nil</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package proc

import (
        "encoding/json"
        "fmt"

        tb_api "github.com/cloud-barista/cb-tumblebug/src/api/grpc/request"
        gc "github.com/jmleefree/actiontest2/src/grpc-api/common"
)

// ===== [ Constants and Variables ] =====

// VMListInfo - VM 목록 구조 정의
type VMListInfo struct {
        Id   string   `yaml:"id" json:"id"`
        Name string   `yaml:"name" json:"name"`
        Vm   []string `yaml:"vm" json:"vm"`
}

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// ListMcisVM - VM 목록
func ListMcisVM(mcis *tb_api.MCISApi, nameSpaceID string, mcisID string) (string, error) <span class="cov0" title="0">{

        holdType, _ := mcis.GetOutType()
        mcis.SetOutType("json")
        defer mcis.SetOutType(holdType)

        result, err := mcis.GetMcisInfoByParam(nameSpaceID, mcisID)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">jsonMap := make(map[string]interface{})
        err = json.Unmarshal([]byte(result), &amp;jsonMap)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">vmList := []string{}
        for _, m := range jsonMap["vm"].([]interface{}) </span><span class="cov0" title="0">{
                item := m.(map[string]interface{})
                vmList = append(vmList, fmt.Sprintf("%v", item["id"]))
        }</span>

        <span class="cov0" title="0">vmListInfo := VMListInfo{}
        vmListInfo.Id = fmt.Sprintf("%v", jsonMap["id"])
        vmListInfo.Name = fmt.Sprintf("%v", jsonMap["name"])
        vmListInfo.Vm = vmList

        outType, _ := mcis.GetOutType()
        return gc.ConvertToOutput(outType, &amp;vmListInfo)</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package common

import (
        "errors"
        "io"

        "google.golang.org/grpc"
        "google.golang.org/grpc/credentials"

        "github.com/jmleefree/actiontest2/src/grpc-api/interceptors/jaegertracer"
        "github.com/opentracing/opentracing-go"

        grpc_middleware "github.com/grpc-ecosystem/go-grpc-middleware"
        grpc_opentracing "github.com/grpc-ecosystem/go-grpc-middleware/tracing/opentracing"
        grpc_accesslog "github.com/jmleefree/actiontest2/src/grpc-api/interceptors/accesslog"
        grpc_authjwt "github.com/jmleefree/actiontest2/src/grpc-api/interceptors/authjwt"

        "github.com/jmleefree/actiontest2/src/grpc-api/config"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// CBConnection - CB-GRPC에서 사용하는 grpc 클라이언트를 위한 Wrapper 구조
type CBConnection struct {
        Conn *grpc.ClientConn
}

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// NewCBConnection - 초기화된 grpc 클라이언트의 인스턴스 생성
func NewCBConnection(gConf *config.GrpcClientConfig) (*CBConnection, io.Closer, error) <span class="cov0" title="0">{

        var (
                tracer opentracing.Tracer = nil
                closer io.Closer          = nil
        )

        if gConf == nil </span><span class="cov0" title="0">{
                return nil, nil, errors.New("grpc connection config is null")
        }</span>

        <span class="cov0" title="0">if gConf.ServerAddr == "" </span><span class="cov0" title="0">{
                return nil, nil, errors.New("server addr is empty")
        }</span>

        <span class="cov0" title="0">opts := []grpc.DialOption{}

        // TLS 설정
        if gConf.TLS != nil </span><span class="cov0" title="0">{
                creds, err := credentials.NewClientTLSFromFile(gConf.TLS.TLSCA, "")
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, err
                }</span>
                <span class="cov0" title="0">opts = append(opts, grpc.WithTransportCredentials(creds))</span>
        } else<span class="cov0" title="0"> {
                opts = append(opts, grpc.WithInsecure())
        }</span>

        // 인터셉터 설정
        <span class="cov0" title="0">unaryIntercepters := []grpc.UnaryClientInterceptor{}
        streamIntercepters := []grpc.StreamClientInterceptor{}

        // access 로그 인터셉터 기본 설정
        unaryIntercepters = append(unaryIntercepters, grpc_accesslog.UnaryClientInterceptor())
        streamIntercepters = append(streamIntercepters, grpc_accesslog.StreamClientInterceptor())

        if gConf.Interceptors != nil </span><span class="cov0" title="0">{

                // AuthJWT 인터셉터 설정
                if gConf.Interceptors.AuthJWT != nil </span><span class="cov0" title="0">{
                        unaryIntercepters = append(unaryIntercepters, grpc_authjwt.UnaryClientInterceptor(gConf.Interceptors.AuthJWT.JWTToken))
                        streamIntercepters = append(streamIntercepters, grpc_authjwt.StreamClientInterceptor(gConf.Interceptors.AuthJWT.JWTToken))
                }</span>

                // Opentracing 인터셉터 설정
                <span class="cov0" title="0">if gConf.Interceptors.Opentracing != nil </span><span class="cov0" title="0">{
                        tracer, closer = jaegertracer.InitJaeger(gConf.Interceptors.Opentracing.Jaeger)

                        tracingOpts := []grpc_opentracing.Option{}
                        tracingOpts = append(tracingOpts, grpc_opentracing.WithTracer(tracer))

                        unaryIntercepters = append(unaryIntercepters, grpc_opentracing.UnaryClientInterceptor(tracingOpts...))
                        streamIntercepters = append(streamIntercepters, grpc_opentracing.StreamClientInterceptor(tracingOpts...))
                }</span>

        }

        <span class="cov0" title="0">opts = append(opts, grpc.WithUnaryInterceptor(grpc_middleware.ChainUnaryClient(unaryIntercepters...)))
        opts = append(opts, grpc.WithStreamInterceptor(grpc_middleware.ChainStreamClient(streamIntercepters...)))
        conn, err := grpc.Dial(gConf.ServerAddr, opts...)

        return &amp;CBConnection{Conn: conn}, closer, err</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package common

import (
        "encoding/json"
        "strings"

        "github.com/jmleefree/actiontest2/src/grpc-api/logger"

        "gopkg.in/yaml.v2"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====s

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// ConvertToMessage - 입력 데이터를 grpc 메시지로 변환
func ConvertToMessage(inType string, inData string, obj interface{}) error <span class="cov8" title="1">{
        logger := logger.NewLogger()

        if inType == "yaml" </span><span class="cov0" title="0">{
                err := yaml.Unmarshal([]byte(inData), obj)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">logger.Debug("yaml Unmarshal: \n", obj)</span>
        }

        <span class="cov8" title="1">if inType == "json" </span><span class="cov8" title="1">{
                err := json.Unmarshal([]byte(inData), obj)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">logger.Debug("json Unmarshal: \n", obj)</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// ConvertToOutput - grpc 메시지를 출력포맷으로 변환
func ConvertToOutput(outType string, obj interface{}) (string, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        if outType == "yaml" </span><span class="cov0" title="0">{
                // 메시지 포맷에서 불필요한 필드(XXX_로 시작하는 필드)를 제거하기 위해 json 태그를 이용하여 마샬링
                j, err := json.Marshal(obj)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>

                // yaml 에서 지원하지 않는 control character 제거
                <span class="cov0" title="0">cleanStr := strings.Map(func(value rune) rune </span><span class="cov0" title="0">{
                        switch </span>{
                        case value == 0x09:<span class="cov0" title="0">
                                return value</span>
                        case value == 0x0A:<span class="cov0" title="0">
                                return value</span>
                        case value == 0x0D:<span class="cov0" title="0">
                                return value</span>
                        case value &gt;= 0x20 &amp;&amp; value &lt;= 0x7E:<span class="cov0" title="0">
                                return value</span>
                        case value == 0x85:<span class="cov0" title="0">
                                return value</span>
                        case value &gt;= 0xA0 &amp;&amp; value &lt;= 0xD7FF:<span class="cov0" title="0">
                                return value</span>
                        case value &gt;= 0xE000 &amp;&amp; value &lt;= 0xFFFD:<span class="cov0" title="0">
                                return value</span>
                        case value &gt;= 0x10000 &amp;&amp; value &lt;= 0x10FFFF:<span class="cov0" title="0">
                                return value</span>
                        default:<span class="cov0" title="0">
                                return -1</span> // control characters are not allowed
                        }
                }, string(j))

                // 필드를 소팅하지 않고 지정된 순서대로 출력하기 위해 MapSlice 이용
                <span class="cov0" title="0">jsonObj := yaml.MapSlice{}
                err2 := yaml.Unmarshal([]byte(cleanStr), &amp;jsonObj)
                if err2 != nil </span><span class="cov0" title="0">{
                        return "", err2
                }</span>

                // yaml 마샬링
                <span class="cov0" title="0">y, err3 := yaml.Marshal(jsonObj)
                if err3 != nil </span><span class="cov0" title="0">{
                        return "", err3
                }</span>
                <span class="cov0" title="0">logger.Debug("yaml Marshal: \n", string(y))

                return string(y), nil</span>
        }

        <span class="cov8" title="1">if outType == "json" </span><span class="cov8" title="1">{
                j, err := json.MarshalIndent(obj, "", "  ")
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov8" title="1">outStr := string(j)

                // json.Marshal 함수는  &lt;,&gt;, &amp; 문자를 escape 함.. 다시 원래대로 변환
                outStr = strings.Replace(outStr, "\\u003c", "&lt;", -1)
                outStr = strings.Replace(outStr, "\\u003e", "&gt;", -1)
                outStr = strings.Replace(outStr, "\\u0026", "&amp;", -1)

                logger.Debug("json Marshal: \n", outStr)
                return outStr, nil</span>
        }

        <span class="cov0" title="0">return "", nil</span>
}

// CopySrcToDest - 소스에서 타켓으로 데이터 복사
func CopySrcToDest(src interface{}, dest interface{}) error <span class="cov8" title="1">{
        logger := logger.NewLogger()

        j, err := json.MarshalIndent(src, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">logger.Debug("source value : \n", string(j))

        err = json.Unmarshal(j, dest)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">j, err = json.MarshalIndent(dest, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">logger.Debug("target value : \n", string(j))

        return nil</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">package common

import (
        "errors"
        "fmt"
        "io"
        "log"
        "net/http"

        "google.golang.org/grpc"
        "google.golang.org/grpc/credentials"

        "github.com/jmleefree/actiontest2/src/grpc-api/interceptors/jaegertracer"

        grpc_middleware "github.com/grpc-ecosystem/go-grpc-middleware"
        grpc_recovery "github.com/grpc-ecosystem/go-grpc-middleware/recovery"
        grpc_opentracing "github.com/grpc-ecosystem/go-grpc-middleware/tracing/opentracing"
        grpc_accesslog "github.com/jmleefree/actiontest2/src/grpc-api/interceptors/accesslog"
        grpc_authjwt "github.com/jmleefree/actiontest2/src/grpc-api/interceptors/authjwt"

        grpc_prometheus "github.com/grpc-ecosystem/go-grpc-prometheus"
        "github.com/prometheus/client_golang/prometheus"
        "github.com/prometheus/client_golang/prometheus/promhttp"

        opentracing "github.com/opentracing/opentracing-go"

        "github.com/jmleefree/actiontest2/src/grpc-api/config"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// CBServer - CB-GRPC에서 사용하는 grpc 서버를 위한 Wrapper 구조
type CBServer struct {
        Server *grpc.Server
}

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// NewCBServer - 초기화된 grpc 서버의 인스턴스 생성
func NewCBServer(gConf *config.GrpcServerConfig) (*CBServer, io.Closer, error) <span class="cov8" title="1">{

        var (
                tracer      opentracing.Tracer             = nil
                closer      io.Closer                      = nil
                reg         *prometheus.Registry           = nil
                grpcMetrics *grpc_prometheus.ServerMetrics = nil
        )

        if gConf == nil </span><span class="cov0" title="0">{
                return nil, nil, errors.New("grpc server config is null")
        }</span>

        <span class="cov8" title="1">opts := []grpc.ServerOption{}

        // TLS 설정
        if gConf.TLS != nil </span><span class="cov0" title="0">{
                creds, err := credentials.NewServerTLSFromFile(gConf.TLS.TLSCert, gConf.TLS.TLSKey)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, err
                }</span>
                <span class="cov0" title="0">opts = append(opts, grpc.Creds(creds))</span>
        }

        // 인터셉터 설정
        <span class="cov8" title="1">unaryIntercepters := []grpc.UnaryServerInterceptor{}
        streamIntercepters := []grpc.StreamServerInterceptor{}

        // access 로그 인터셉터 기본 설정
        unaryIntercepters = append(unaryIntercepters, grpc_accesslog.UnaryServerInterceptor())
        streamIntercepters = append(streamIntercepters, grpc_accesslog.StreamServerInterceptor())

        if gConf.Interceptors != nil </span><span class="cov0" title="0">{

                // AuthJWT 인터셉터 설정
                if gConf.Interceptors.AuthJWT != nil </span><span class="cov0" title="0">{
                        unaryIntercepters = append(unaryIntercepters, grpc_authjwt.UnaryServerInterceptor(gConf.Interceptors.AuthJWT.JWTKey))
                        streamIntercepters = append(streamIntercepters, grpc_authjwt.StreamServerInterceptor(gConf.Interceptors.AuthJWT.JWTKey))
                }</span>

                // Opentracing 인터셉터 설정
                <span class="cov0" title="0">if gConf.Interceptors.Opentracing != nil </span><span class="cov0" title="0">{
                        if gConf.Interceptors.Opentracing.Jaeger != nil </span><span class="cov0" title="0">{
                                tracer, closer = jaegertracer.InitJaeger(gConf.Interceptors.Opentracing.Jaeger)

                                tracingOpts := []grpc_opentracing.Option{}
                                tracingOpts = append(tracingOpts, grpc_opentracing.WithTracer(tracer))

                                unaryIntercepters = append(unaryIntercepters, grpc_opentracing.UnaryServerInterceptor(tracingOpts...))
                                streamIntercepters = append(streamIntercepters, grpc_opentracing.StreamServerInterceptor(tracingOpts...))
                        }</span>
                }

                // Prometheus Metrics 인터셉터 설정
                <span class="cov0" title="0">if gConf.Interceptors.PrometheusMetrics != nil </span><span class="cov0" title="0">{
                        grpcMetrics = grpc_prometheus.NewServerMetrics()
                        grpcMetrics.EnableHandlingTimeHistogram()

                        reg = prometheus.NewRegistry()
                        reg.MustRegister(grpcMetrics)
                        reg.MustRegister(prometheus.NewProcessCollector(prometheus.ProcessCollectorOpts{}))
                        reg.MustRegister(prometheus.NewGoCollector())

                        unaryIntercepters = append(unaryIntercepters, grpcMetrics.UnaryServerInterceptor())
                        streamIntercepters = append(streamIntercepters, grpcMetrics.StreamServerInterceptor())
                }</span>

        }

        // recovery 인터셉터 기본 설정
        <span class="cov8" title="1">unaryIntercepters = append(unaryIntercepters, grpc_recovery.UnaryServerInterceptor())
        streamIntercepters = append(streamIntercepters, grpc_recovery.StreamServerInterceptor())

        opts = append(opts, grpc.UnaryInterceptor(grpc_middleware.ChainUnaryServer(unaryIntercepters...)))
        opts = append(opts, grpc.StreamInterceptor(grpc_middleware.ChainStreamServer(streamIntercepters...)))
        gs := grpc.NewServer(opts...)

        if gConf.Interceptors != nil </span><span class="cov0" title="0">{
                if gConf.Interceptors.PrometheusMetrics != nil </span><span class="cov0" title="0">{

                        // Create a HTTP server for prometheus.
                        httpServer := &amp;http.Server{
                                Handler: promhttp.HandlerFor(reg, promhttp.HandlerOpts{}),
                                Addr:    fmt.Sprintf("0.0.0.0:%d", gConf.Interceptors.PrometheusMetrics.ListenPort),
                        }
                        // Initialize all metrics.
                        grpcMetrics.InitializeMetrics(gs)
                        // Start your http server for prometheus.
                        go func() </span><span class="cov0" title="0">{
                                if err := httpServer.ListenAndServe(); err != nil </span><span class="cov0" title="0">{
                                        log.Fatal("Unable to start a http server for prometheus.")
                                }</span>
                        }()

                }
        }

        <span class="cov8" title="1">return &amp;CBServer{Server: gs}, closer, nil</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">package common

import (
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"

        "github.com/jmleefree/actiontest2/src/grpc-api/logger"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// ConvGrpcStatusErr - GRPC 상태 코드 에러로 변환
func ConvGrpcStatusErr(err error, tag string, method string) error <span class="cov0" title="0">{
        logger := logger.NewLogger()

        if err != nil </span><span class="cov0" title="0">{
                if errStatus, ok := status.FromError(err); ok </span><span class="cov0" title="0">{
                        logger.Error(tag, " error while calling ", method, " method: ", errStatus.Message())
                        return status.Errorf(errStatus.Code(), "%s error while calling %s method: %v ", tag, method, errStatus.Message())
                }</span>
                <span class="cov0" title="0">logger.Error(tag, " error while calling ", method, " method: ", err)
                return status.Errorf(codes.Internal, "%s error while calling %s method: %v ", tag, method, err)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// NewGrpcStatusErr - GRPC 상태 코드 에러 생성
func NewGrpcStatusErr(msg string, tag string, method string) error <span class="cov0" title="0">{
        logger := logger.NewLogger()

        logger.Error(tag, " error while calling ", method, " method: ", msg)
        return status.Errorf(codes.Internal, "%s error while calling %s method: %s ", tag, method, msg)
}</span>
</pre>
		
		<pre class="file" id="file47" style="display: none">// Package config - Configuration for Cloud-Barista's GRPC and provides the required process
package config

import (
        "fmt"
        "log"
        "os"
        "strings"
        "time"
)

// ===== [ Constants and Variables ] =====

const (
        // ConfigVersion - 설정 구조에 대한 버전
        ConfigVersion = 1
)

// ===== [ Types ] =====

// GrpcConfig - CB-GRPC 서비스 설정 구조
type GrpcConfig struct {
        Version int             `mapstructure:"version"`
        GSL     GrpcServiceList `mapstructure:"grpc"`
}

// GrpcServiceList - CB-GRPC 서비스 목록
type GrpcServiceList struct {
        LadybugSrv *GrpcServerConfig `mapstructure:"ladybugsrv"`
        LadybugCli *GrpcClientConfig `mapstructure:"ladybugcli"`
}

// GrpcServerConfig - CB-GRPC 서버 설정 구조
type GrpcServerConfig struct {
        Addr         string              `mapstructure:"addr"`
        Reflection   string              `mapstructure:"reflection"`
        TLS          *TLSConfig          `mapstructure:"tls"`
        Interceptors *InterceptorsConfig `mapstructure:"interceptors"`
}

// GrpcClientConfig - CB-GRPC 클라이언트 설정 구조
type GrpcClientConfig struct {
        ServerAddr   string              `mapstructure:"server_addr"`
        Timeout      time.Duration       `mapstructure:"timeout"`
        TLS          *TLSConfig          `mapstructure:"tls"`
        Interceptors *InterceptorsConfig `mapstructure:"interceptors"`
}

// TLSConfig - TLS 설정 구조
type TLSConfig struct {
        TLSCert string `mapstructure:"tls_cert"`
        TLSKey  string `mapstructure:"tls_key"`
        TLSCA   string `mapstructure:"tls_ca"`
}

// InterceptorsConfig - GRPC 인터셉터 설정 구조
type InterceptorsConfig struct {
        AuthJWT           *AuthJWTConfig           `mapstructure:"auth_jwt"`
        PrometheusMetrics *PrometheusMetricsConfig `mapstructure:"prometheus_metrics"`
        Opentracing       *OpentracingConfig       `mapstructure:"opentracing"`
}

// AuthJWTConfig - AuthJWT 설정 구조
type AuthJWTConfig struct {
        JWTKey   string `mapstructure:"jwt_key"`
        JWTToken string `mapstructure:"jwt_token"`
}

// PrometheusMetricsConfig - Prometheus Metrics 설정 구조
type PrometheusMetricsConfig struct {
        ListenPort int `mapstructure:"listen_port"`
}

// OpentracingConfig - Opentracing 설정 구조
type OpentracingConfig struct {
        Jaeger *JaegerClientConfig `mapstructure:"jaeger"`
}

// JaegerClientConfig - Jaeger Client 설정 구조
type JaegerClientConfig struct {
        Endpoint    string  `mapstructure:"endpoint"`
        ServiceName string  `mapstructure:"service_name"`
        SampleRate  float64 `mapstructure:"sample_rate"`
}

// UnsupportedVersionError - 설정 초기화 과정에서 버전 검증을 통해 반환할 오류 구조
type UnsupportedVersionError struct {
        Have int
        Want int
}

// ===== [ Implementations ] =====

// Init - 설정에 대한 검사 및 초기화
func (gConf *GrpcConfig) Init() error <span class="cov8" title="1">{
        // 설정 파일 버전 검증
        if gConf.Version != ConfigVersion </span><span class="cov0" title="0">{
                return &amp;UnsupportedVersionError{
                        Have: gConf.Version,
                        Want: ConfigVersion,
                }
        }</span>
        // 전역변수 초기화
        <span class="cov8" title="1">gConf.initGlobalParams()

        return nil</span>
}

// initGlobalParams - 전역 설정 초기화
func (gConf *GrpcConfig) initGlobalParams() <span class="cov8" title="1">{

        if gConf.GSL.LadybugSrv != nil </span><span class="cov8" title="1">{

                if gConf.GSL.LadybugSrv.TLS != nil </span><span class="cov0" title="0">{
                        if gConf.GSL.LadybugSrv.TLS.TLSCert != "" </span><span class="cov0" title="0">{
                                gConf.GSL.LadybugSrv.TLS.TLSCert = ReplaceEnvPath(gConf.GSL.LadybugSrv.TLS.TLSCert)
                        }</span>
                        <span class="cov0" title="0">if gConf.GSL.LadybugSrv.TLS.TLSKey != "" </span><span class="cov0" title="0">{
                                gConf.GSL.LadybugSrv.TLS.TLSKey = ReplaceEnvPath(gConf.GSL.LadybugSrv.TLS.TLSKey)
                        }</span>
                }

                <span class="cov8" title="1">if gConf.GSL.LadybugSrv.Interceptors != nil </span><span class="cov0" title="0">{
                        if gConf.GSL.LadybugSrv.Interceptors.Opentracing != nil </span><span class="cov0" title="0">{
                                if gConf.GSL.LadybugSrv.Interceptors.Opentracing.Jaeger != nil </span><span class="cov0" title="0">{

                                        if gConf.GSL.LadybugSrv.Interceptors.Opentracing.Jaeger.ServiceName == "" </span><span class="cov0" title="0">{
                                                gConf.GSL.LadybugSrv.Interceptors.Opentracing.Jaeger.ServiceName = "grpc ladybug server"
                                        }</span>

                                        <span class="cov0" title="0">if gConf.GSL.LadybugSrv.Interceptors.Opentracing.Jaeger.SampleRate == 0 </span><span class="cov0" title="0">{
                                                gConf.GSL.LadybugSrv.Interceptors.Opentracing.Jaeger.SampleRate = 1
                                        }</span>

                                }
                        }
                }
        }

        <span class="cov8" title="1">if gConf.GSL.LadybugCli != nil </span><span class="cov8" title="1">{

                if gConf.GSL.LadybugCli.Timeout == 0 </span><span class="cov8" title="1">{
                        gConf.GSL.LadybugCli.Timeout = 90 * time.Second
                }</span>

                <span class="cov8" title="1">if gConf.GSL.LadybugCli.TLS != nil </span><span class="cov0" title="0">{
                        if gConf.GSL.LadybugCli.TLS.TLSCA != "" </span><span class="cov0" title="0">{
                                gConf.GSL.LadybugCli.TLS.TLSCA = ReplaceEnvPath(gConf.GSL.LadybugCli.TLS.TLSCA)
                        }</span>
                }

                <span class="cov8" title="1">if gConf.GSL.LadybugCli.Interceptors != nil </span><span class="cov0" title="0">{
                        if gConf.GSL.LadybugCli.Interceptors.Opentracing != nil </span><span class="cov0" title="0">{
                                if gConf.GSL.LadybugCli.Interceptors.Opentracing.Jaeger != nil </span><span class="cov0" title="0">{

                                        if gConf.GSL.LadybugCli.Interceptors.Opentracing.Jaeger.ServiceName == "" </span><span class="cov0" title="0">{
                                                gConf.GSL.LadybugCli.Interceptors.Opentracing.Jaeger.ServiceName = "grpc dragonfly client"
                                        }</span>

                                        <span class="cov0" title="0">if gConf.GSL.LadybugCli.Interceptors.Opentracing.Jaeger.SampleRate == 0 </span><span class="cov0" title="0">{
                                                gConf.GSL.LadybugCli.Interceptors.Opentracing.Jaeger.SampleRate = 1
                                        }</span>

                                }
                        }
                }
        }

}

// Error - 비 호환 버전에 대한 오류 문자열 반환
func (u *UnsupportedVersionError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("Unsupported version: %d (wanted: %d)", u.Have, u.Want)
}</span>

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// ReplaceEnvPath - $ABC/def ==&gt; /abc/def
func ReplaceEnvPath(str string) string <span class="cov0" title="0">{
        if strings.Index(str, "$") == -1 </span><span class="cov0" title="0">{
                return str
        }</span>

        // ex) input "$CBSTORE_ROOT/meta_db/dat"
        <span class="cov0" title="0">strList := strings.Split(str, "/")
        for n, one := range strList </span><span class="cov0" title="0">{
                if strings.Index(one, "$") != -1 </span><span class="cov0" title="0">{
                        cbstoreRootPath := os.Getenv(strings.Trim(one, "$"))
                        if cbstoreRootPath == "" </span><span class="cov0" title="0">{
                                log.Fatal(one + " is not set!")
                        }</span>
                        <span class="cov0" title="0">strList[n] = cbstoreRootPath</span>
                }
        }

        <span class="cov0" title="0">var resultStr string
        for _, one := range strList </span><span class="cov0" title="0">{
                resultStr = resultStr + one + "/"
        }</span>
        // ex) "/root/go/src/github.com/cloud-barista/cb-spider/meta_db/dat/"
        <span class="cov0" title="0">resultStr = strings.TrimRight(resultStr, "/")
        resultStr = strings.ReplaceAll(resultStr, "//", "/")
        return resultStr</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">package config

import (
        "fmt"
        "os"
        "reflect"
        "unsafe"

        "github.com/spf13/viper"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// Parser - Viper lib를 활용하기 위한 Parser 정의 구조 형식
type Parser struct {
        viper *viper.Viper
}

// ===== [ Implementations ] =====

// GrpcParse - Viper lib를 이용해서 지정된 CB-GRPC configuration 정보 파싱
func (p Parser) GrpcParse(configFile string) (GrpcConfig, error) <span class="cov8" title="1">{
        p.viper.SetConfigFile(configFile)
        p.viper.AutomaticEnv()
        p.viper.SetConfigType("yaml")

        var cfg GrpcConfig

        // Reading
        if err := p.viper.ReadInConfig(); err != nil </span><span class="cov0" title="0">{
                return cfg, checkErr(err, configFile)
        }</span>
        // Unmarshal to struct
        <span class="cov8" title="1">if err := p.viper.Unmarshal(&amp;cfg); err != nil </span><span class="cov0" title="0">{
                return cfg, checkErr(err, configFile)
        }</span>
        // Initialize
        <span class="cov8" title="1">if err := cfg.Init(); err != nil </span><span class="cov0" title="0">{
                return cfg, CheckErr(err, configFile)
        }</span>
        <span class="cov8" title="1">return cfg, nil</span>
}

// ===== [ Private Functions ] =====

// checkErr - Viper lib 처리에서 발생한 오류 반환 (Nested call)
func checkErr(err error, configFile string) error <span class="cov0" title="0">{
        switch e := err.(type) </span>{
        case viper.ConfigParseError:<span class="cov0" title="0">
                var subErr error
                re := reflect.ValueOf(&amp;e).Elem()
                rf := re.Field(0)
                rse := reflect.ValueOf(&amp;subErr).Elem()
                rf = reflect.NewAt(rf.Type(), unsafe.Pointer(rf.UnsafeAddr())).Elem()
                rse.Set(rf)
                return checkErr(subErr, configFile)</span>
        default:<span class="cov0" title="0">
                return CheckErr(err, configFile)</span>
        }
}

// ===== [ Public Functions ] =====

// CheckErr - 검증된 오류 정보 반환
func CheckErr(err error, configFile string) error <span class="cov0" title="0">{
        switch e := err.(type) </span>{
        case *os.PathError:<span class="cov0" title="0">
                return fmt.Errorf("'%s' (%s): %s", configFile, e.Op, e.Err.Error())</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("'%s': %v", configFile, err)</span>
        }
}

// MakeParser - Viber lib를 활용하는 설정 Parser 생성
func MakeParser() Parser <span class="cov8" title="1">{
        return Parser{viper.New()}
}</span>
</pre>
		
		<pre class="file" id="file49" style="display: none">package accesslog

import (
        "context"
        "time"

        "google.golang.org/grpc"

        "github.com/jmleefree/actiontest2/src/grpc-api/logger"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// UnaryClientInterceptor - rpc unary call 정보를 기록하는 클라이언트 인터셉터
func UnaryClientInterceptor() grpc.UnaryClientInterceptor <span class="cov0" title="0">{
        return func(ctx context.Context, method string, req, reply interface{}, cc *grpc.ClientConn, invoker grpc.UnaryInvoker, opts ...grpc.CallOption) error </span><span class="cov0" title="0">{
                startTime := time.Now()
                err := invoker(ctx, method, req, reply, cc, opts...)
                elapsed := time.Now().Sub(startTime)

                logger := logger.NewLogger()
                logger.Info("grpc client unary call : ", method, " service [", elapsed.Nanoseconds()/1000000, " ms]")

                return err
        }</span>
}

// StreamClientInterceptor - rpc stream call 정보를 기록하는 클라이언트 인터셉터
func StreamClientInterceptor() grpc.StreamClientInterceptor <span class="cov0" title="0">{
        return func(ctx context.Context, desc *grpc.StreamDesc, cc *grpc.ClientConn, method string, streamer grpc.Streamer, opts ...grpc.CallOption) (grpc.ClientStream, error) </span><span class="cov0" title="0">{
                startTime := time.Now()
                clientStream, err := streamer(ctx, desc, cc, method, opts...)
                elapsed := time.Now().Sub(startTime)

                logger := logger.NewLogger()
                logger.Info("grpc client stream call : ", method, " service [", elapsed.Nanoseconds()/1000000, " ms]")

                return clientStream, err
        }</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">package accesslog

import (
        "context"
        "time"

        "google.golang.org/grpc"
        "google.golang.org/grpc/peer"

        "github.com/jmleefree/actiontest2/src/grpc-api/logger"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// UnaryServerInterceptor - rpc unary receive 정보를 기록하는 서버 인터셉터
func UnaryServerInterceptor() grpc.UnaryServerInterceptor <span class="cov8" title="1">{
        return func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) </span><span class="cov8" title="1">{
                startTime := time.Now()
                resp, err := handler(ctx, req)
                elapsed := time.Now().Sub(startTime)

                clientIP := "unknown"
                if p, ok := peer.FromContext(ctx); ok </span><span class="cov8" title="1">{
                        clientIP = p.Addr.String()
                }</span>

                <span class="cov8" title="1">logger := logger.NewLogger()
                logger.Info("[", clientIP, "] grpc server unary received : ", info.FullMethod, " service [", elapsed.Nanoseconds()/1000000, " ms]")

                return resp, err</span>
        }
}

// StreamServerInterceptor - rpc stream receive 정보를 기록하는 서버 인터셉터
func StreamServerInterceptor() grpc.StreamServerInterceptor <span class="cov8" title="1">{
        return func(srv interface{}, stream grpc.ServerStream, info *grpc.StreamServerInfo, handler grpc.StreamHandler) error </span><span class="cov0" title="0">{
                startTime := time.Now()
                err := handler(srv, stream)
                elapsed := time.Now().Sub(startTime)

                clientIP := "unknown"
                if p, ok := peer.FromContext(stream.Context()); ok </span><span class="cov0" title="0">{
                        clientIP = p.Addr.String()
                }</span>

                <span class="cov0" title="0">logger := logger.NewLogger()
                logger.Info("[", clientIP, "] grpc server stream received : ", info.FullMethod, " service [", elapsed.Nanoseconds()/1000000, " ms]")
                return err</span>
        }
}
</pre>
		
		<pre class="file" id="file51" style="display: none">package authjwt

import (
        "context"
        "fmt"
        "time"

        "github.com/dgrijalva/jwt-go"
        "github.com/jmleefree/actiontest2/src/grpc-api/logger"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/metadata"
        "google.golang.org/grpc/status"
)

func validateToken(ctx context.Context) (bool, error) <span class="cov0" title="0">{

        md, ok := metadata.FromIncomingContext(ctx)
        if !ok </span><span class="cov0" title="0">{
                return false, status.Errorf(codes.InvalidArgument, "Retrieving metadata is failed")
        }</span>

        <span class="cov0" title="0">authHeader, ok := md["authorization"]
        if !ok </span><span class="cov0" title="0">{
                return false, status.Errorf(codes.Unauthenticated, "Authorization jwt token is not supplied")
        }</span>

        <span class="cov0" title="0">tokenStr := authHeader[0]

        claims := jwt.MapClaims{}
        token, err := jwt.ParseWithClaims(tokenStr, claims, func(token *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                return []byte(jwtKey), nil
        }</span>)

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return false, status.Errorf(codes.Unauthenticated, "Parsing jwt token is failed")
        }</span>

        <span class="cov0" title="0">if token.Valid </span><span class="cov0" title="0">{
                logger := logger.NewLogger()
                var tokenInfo string = "{"
                for key, val := range claims </span><span class="cov0" title="0">{
                        if key == "expire" </span><span class="cov0" title="0">{

                                if getTokenRemainingValidity(val) &lt; 0 </span><span class="cov0" title="0">{
                                        return false, status.Errorf(codes.Unauthenticated, "token is expired")
                                }</span>

                                <span class="cov0" title="0">var timestamp interface{} = val
                                t := time.Unix(int64(timestamp.(float64)), 0)
                                tokenInfo = tokenInfo + fmt.Sprintf(" %s: %d-%02d-%02dT%02d:%02d:%02d, remainder seconds: %d,", key,
                                        t.Year(), t.Month(), t.Day(),
                                        t.Hour(), t.Minute(), t.Second(),
                                        getTokenRemainingValidity(val),
                                )</span>

                        } else<span class="cov0" title="0"> {
                                tokenInfo = tokenInfo + fmt.Sprintf(" %s: %v,", key, val)
                        }</span>
                }
                <span class="cov0" title="0">tokenInfo = tokenInfo + " }"
                logger.Debug("token parsing result : ", tokenInfo)

                return true, nil</span>
        }

        <span class="cov0" title="0">return false, status.Errorf(codes.Unauthenticated, "Authorization is failed")</span>
}

func getTokenRemainingValidity(timestamp interface{}) int <span class="cov0" title="0">{
        if validity, ok := timestamp.(float64); ok </span><span class="cov0" title="0">{
                tm := time.Unix(int64(validity), 0)
                remainder := tm.Sub(time.Now())

                return int(remainder.Seconds())
        }</span>
        <span class="cov0" title="0">return -1</span>
}
</pre>
		
		<pre class="file" id="file52" style="display: none">package authjwt

import (
        "context"

        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/metadata"
        "google.golang.org/grpc/status"
)

// ===== [ Constants and Variables ] =====
var (
        jwtToken = ""
)

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// UnaryClientInterceptor - JWT 토큰을 전달하는 Unary 클라이언트 인터셉터
func UnaryClientInterceptor(token string) grpc.UnaryClientInterceptor <span class="cov0" title="0">{
        jwtToken = token
        return func(ctx context.Context, method string, req, reply interface{}, cc *grpc.ClientConn, invoker grpc.UnaryInvoker, opts ...grpc.CallOption) error </span><span class="cov0" title="0">{

                if jwtToken == "" </span><span class="cov0" title="0">{
                        return status.Errorf(codes.Unauthenticated, "jwt token is not supplied")
                }</span>

                <span class="cov0" title="0">ctx = metadata.AppendToOutgoingContext(ctx, "authorization", jwtToken)

                return invoker(ctx, method, req, reply, cc, opts...)</span>
        }
}

// StreamClientInterceptor - JWT 토큰을 전달하는 Stream 클라이언트 인터셉터
func StreamClientInterceptor(token string) grpc.StreamClientInterceptor <span class="cov0" title="0">{
        jwtToken = token
        return func(ctx context.Context, desc *grpc.StreamDesc, cc *grpc.ClientConn, method string, streamer grpc.Streamer, opts ...grpc.CallOption) (grpc.ClientStream, error) </span><span class="cov0" title="0">{

                if jwtToken == "" </span><span class="cov0" title="0">{
                        return nil, status.Errorf(codes.Unauthenticated, "jwt token is not supplied")
                }</span>

                <span class="cov0" title="0">ctx = metadata.AppendToOutgoingContext(ctx, "authorization", jwtToken)

                return streamer(ctx, desc, cc, method, opts...)</span>
        }
}
</pre>
		
		<pre class="file" id="file53" style="display: none">package authjwt

import (
        "context"

        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

// ===== [ Constants and Variables ] =====
var (
        jwtKey = ""
)

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// UnaryServerInterceptor - authentication 을 처리하는 Unary 서버 인터셉터
func UnaryServerInterceptor(key string) grpc.UnaryServerInterceptor <span class="cov0" title="0">{
        jwtKey = key
        return func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) </span><span class="cov0" title="0">{

                if jwtKey == "" </span><span class="cov0" title="0">{
                        return nil, status.Errorf(codes.Unauthenticated, "jwt key is not supplied")
                }</span>

                <span class="cov0" title="0">_, err := validateToken(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return handler(ctx, req)</span>
        }
}

// StreamServerInterceptor - authentication 을 처리하는 Stream 서버 인터셉터
func StreamServerInterceptor(key string) grpc.StreamServerInterceptor <span class="cov0" title="0">{
        jwtKey = key
        return func(srv interface{}, stream grpc.ServerStream, info *grpc.StreamServerInfo, handler grpc.StreamHandler) error </span><span class="cov0" title="0">{

                if jwtKey == "" </span><span class="cov0" title="0">{
                        return status.Errorf(codes.Unauthenticated, "jwt key is not supplied")
                }</span>

                <span class="cov0" title="0">_, err := validateToken(stream.Context())
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">return handler(srv, stream)</span>
        }
}
</pre>
		
		<pre class="file" id="file54" style="display: none">package jaegertracer

import (
        "fmt"
        "io"

        opentracing "github.com/opentracing/opentracing-go"
        jaeger "github.com/uber/jaeger-client-go"
        config "github.com/uber/jaeger-client-go/config"

        grpcconfig "github.com/jmleefree/actiontest2/src/grpc-api/config"
)

// InitJaeger - Jaeger Tracer 초기화
func InitJaeger(jcConf *grpcconfig.JaegerClientConfig) (opentracing.Tracer, io.Closer) <span class="cov0" title="0">{
        cfg := &amp;config.Configuration{
                Sampler: &amp;config.SamplerConfig{
                        Type:  "probabilistic",
                        Param: jcConf.SampleRate,
                },
                Reporter: &amp;config.ReporterConfig{
                        LocalAgentHostPort: jcConf.Endpoint,
                },
        }
        tracer, closer, err := cfg.New(jcConf.ServiceName, config.Logger(jaeger.NullLogger))
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("ERROR: cannot init Jaeger: %v\n", err))</span>
        }
        <span class="cov0" title="0">return tracer, closer</span>
}
</pre>
		
		<pre class="file" id="file55" style="display: none">package logger

import (
        "io"
        "io/ioutil"
        "os"

        cblog "github.com/cloud-barista/cb-log"
        "github.com/sirupsen/logrus"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// Logger - CB-LOG에서 사용하는 "logrus" Logger를 위한 Wrapper 구조
type Logger struct {
        *logrus.Logger
}

// ===== [ Implementations ] =====

// SetOutput - 로그 출력기 설정
func (l *Logger) SetOutput(w io.Writer) <span class="cov0" title="0">{
        l.Logger.Out = w
}</span>

// DisableOutput - 로그 출력 비활성화
func (l *Logger) DisableOutput() <span class="cov0" title="0">{
        l.SetOutput(ioutil.Discard)
}</span>

// SetFormatter - 로그 포맷터 설정
func (l *Logger) SetFormatter(f logrus.Formatter) <span class="cov0" title="0">{
        l.Logger.Formatter = f
}</span>

// SetLogLevel - 로그 레벨 설정
func (l *Logger) SetLogLevel(lv logrus.Level) <span class="cov0" title="0">{
        l.Logger.SetLevel(lv)
}</span>

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// NewLogger - 초기화된 Logger의 인스턴스 생성
func NewLogger() *Logger <span class="cov8" title="1">{
        // CBLOG_ROOT 환경변수가 설정되어 있지 않으면 현재 경로로 환경변수 설정)
        env := os.Getenv("CBLOG_ROOT")
        if env == "" </span><span class="cov0" title="0">{
                if dir, err := os.Getwd(); err == nil </span><span class="cov0" title="0">{
                        os.Setenv("CBLOG_ROOT", dir)
                }</span>
        }

        <span class="cov8" title="1">return &amp;Logger{
                Logger: cblog.GetLogger("CB-GRPC"),
        }</span>
}
</pre>
		
		<pre class="file" id="file56" style="display: none">package mcar

import (
        "context"
        "errors"

        gc "github.com/jmleefree/actiontest2/src/grpc-api/common"
        pb "github.com/jmleefree/actiontest2/src/grpc-api/protobuf/cbladybug"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// CreateCluster - Cluster 생성
func (r *MCARRequest) CreateCluster() (string, error) <span class="cov8" title="1">{
        // 입력데이터 검사
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // 입력데이터 언마샬링
        <span class="cov8" title="1">var item pb.ClusterCreateRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 서버에 요청
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.CreateCluster(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 결과값 마샬링
        <span class="cov8" title="1">return gc.ConvertToOutput(r.OutType, &amp;resp.Item)</span>
}

// ListCluster - Cluster 목록
func (r *MCARRequest) ListCluster() (string, error) <span class="cov0" title="0">{
        // 입력데이터 검사
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // 입력데이터 언마샬링
        <span class="cov0" title="0">var item pb.ClusterAllQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 서버에 요청
        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.ListCluster(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 결과값 마샬링
        <span class="cov0" title="0">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// GetCluster - Cluster 조회
func (r *MCARRequest) GetCluster() (string, error) <span class="cov0" title="0">{
        // 입력데이터 검사
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // 입력데이터 언마샬링
        <span class="cov0" title="0">var item pb.ClusterQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 서버에 요청
        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.GetCluster(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 결과값 마샬링
        <span class="cov0" title="0">return gc.ConvertToOutput(r.OutType, &amp;resp.Item)</span>
}

// DeleteCluster - Cluster 삭제
func (r *MCARRequest) DeleteCluster() (string, error) <span class="cov0" title="0">{
        // 입력데이터 검사
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // 입력데이터 언마샬링
        <span class="cov0" title="0">var item pb.ClusterQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 서버에 요청
        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.DeleteCluster(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 결과값 마샬링
        <span class="cov0" title="0">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====
</pre>
		
		<pre class="file" id="file57" style="display: none">package mcar

import (
        "context"

        gc "github.com/jmleefree/actiontest2/src/grpc-api/common"
        pb "github.com/jmleefree/actiontest2/src/grpc-api/protobuf/cbladybug"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// Healthy - 상태확인
func (r *MCARRequest) Healthy() (string, error) <span class="cov0" title="0">{
        // 서버에 요청
        ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.Healthy(ctx, &amp;pb.Empty{})

        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 결과값 마샬링
        <span class="cov0" title="0">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====
</pre>
		
		<pre class="file" id="file58" style="display: none">package mcar

import (
        "context"
        "errors"

        gc "github.com/jmleefree/actiontest2/src/grpc-api/common"
        pb "github.com/jmleefree/actiontest2/src/grpc-api/protobuf/cbladybug"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// AddNode - Node 추가
func (r *MCARRequest) AddNode() (string, error) <span class="cov0" title="0">{
        // 입력데이터 검사
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // 입력데이터 언마샬링
        <span class="cov0" title="0">var item pb.NodeCreateRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 서버에 요청
        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.AddNode(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 결과값 마샬링
        <span class="cov0" title="0">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// ListNode - Node 목록
func (r *MCARRequest) ListNode() (string, error) <span class="cov0" title="0">{
        // 입력데이터 검사
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // 입력데이터 언마샬링
        <span class="cov0" title="0">var item pb.NodeAllQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 서버에 요청
        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.ListNode(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 결과값 마샬링
        <span class="cov0" title="0">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// GetNode - Node 조회
func (r *MCARRequest) GetNode() (string, error) <span class="cov0" title="0">{
        // 입력데이터 검사
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // 입력데이터 언마샬링
        <span class="cov0" title="0">var item pb.NodeQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 서버에 요청
        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.GetNode(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 결과값 마샬링
        <span class="cov0" title="0">return gc.ConvertToOutput(r.OutType, &amp;resp.Item)</span>
}

// RemoveNode - Node 삭제
func (r *MCARRequest) RemoveNode() (string, error) <span class="cov0" title="0">{
        // 입력데이터 검사
        if r.InData == "" </span><span class="cov0" title="0">{
                return "", errors.New("input data required")
        }</span>

        // 입력데이터 언마샬링
        <span class="cov0" title="0">var item pb.NodeQryRequest
        err := gc.ConvertToMessage(r.InType, r.InData, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 서버에 요청
        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(context.Background(), r.Timeout)
        defer cancel()

        resp, err := r.Client.RemoveNode(ctx, &amp;item)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // 결과값 마샬링
        <span class="cov0" title="0">return gc.ConvertToOutput(r.OutType, &amp;resp)</span>
}

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====
</pre>
		
		<pre class="file" id="file59" style="display: none">package request

import (
        "encoding/json"
        "errors"
        "io"
        "time"

        gc "github.com/jmleefree/actiontest2/src/grpc-api/common"
        "github.com/jmleefree/actiontest2/src/grpc-api/config"
        "github.com/jmleefree/actiontest2/src/grpc-api/logger"
        pb "github.com/jmleefree/actiontest2/src/grpc-api/protobuf/cbladybug"
        "github.com/jmleefree/actiontest2/src/grpc-api/request/mcar"

        "google.golang.org/grpc"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// MCARApi - LADYBUG API 구조 정의
type MCARApi struct {
        gConf        *config.GrpcConfig
        conn         *grpc.ClientConn
        jaegerCloser io.Closer
        clientMCAR   pb.MCARClient
        requestMCAR  *mcar.MCARRequest
        inType       string
        outType      string
}

// ClusterCreateRequest - CLUSTER 생성 요청 구조 Wrapper 정의
type ClusterCreateRequest struct {
        Namespace string     `yaml:"namespace" json:"namespace"`
        Item      ClusterReq `yaml:"ReqInfo" json:"ReqInfo"`
}

// ClusterReq - CLUSTER 생성 요청 구조 정의
type ClusterReq struct {
        Name         string       `yaml:"name" json:"name"`
        ControlPlane []NodeConfig `yaml:"controlPlane" json:"controlPlane"`
        Worker       []NodeConfig `yaml:"worker" json:"worker"`
        Config       Config       `yaml:"config" json:"config"`
}

// NodeConfig - Node 환경설정 구조 정의
type NodeConfig struct {
        Connection string `yaml:"connection" json:"connection"`
        Count      int    `yaml:"count" json:"count"`
        Spec       string `yaml:"spec" json:"spec"`
}

// Config - 클러스터 환경설정 구조 정의
type Config struct {
        Kubernetes Kubernetes `yaml:"kubernetes" json:"kubernetes"`
}

// Kubernetes - 쿠버네티스 환경설정 구조 정의
type Kubernetes struct {
        NetworkCni       string `yaml:"networkCni" json:"networkCni"`
        PodCidr          string `yaml:"podCidr" json:"podCidr"`
        ServiceCidr      string `yaml:"serviceCidr" json:"serviceCidr"`
        ServiceDnsDomain string `yaml:"serviceDnsDomain" json:"serviceDnsDomain"`
}

// NodeCreateRequest - NODE 생성 요청 구조 Wrapper 정의
type NodeCreateRequest struct {
        Namespace string  `yaml:"namespace" json:"namespace"`
        Cluster   string  `yaml:"cluster" json:"cluster"`
        Item      NodeReq `yaml:"ReqInfo" json:"ReqInfo"`
}

// NodeReq - NODE 생성 요청 구조 정의
type NodeReq struct {
        ControlPlane []NodeConfig `yaml:"controlPlane" json:"controlPlane"`
        Worker       []NodeConfig `yaml:"worker" json:"worker"`
}

// ===== [ Implementations ] =====

// SetServerAddr - Ladybug 서버 주소 설정
func (m *MCARApi) SetServerAddr(addr string) error <span class="cov0" title="0">{
        if addr == "" </span><span class="cov0" title="0">{
                return errors.New("parameter is empty")
        }</span>

        <span class="cov0" title="0">m.gConf.GSL.LadybugCli.ServerAddr = addr
        return nil</span>
}

// GetServerAddr - Ladybug 서버 주소 값 조회
func (m *MCARApi) GetServerAddr() (string, error) <span class="cov0" title="0">{
        return m.gConf.GSL.LadybugCli.ServerAddr, nil
}</span>

// SetTLSCA - TLS CA 설정
func (m *MCARApi) SetTLSCA(tlsCAFile string) error <span class="cov0" title="0">{
        if tlsCAFile == "" </span><span class="cov0" title="0">{
                return errors.New("parameter is empty")
        }</span>

        <span class="cov0" title="0">if m.gConf.GSL.LadybugCli.TLS == nil </span><span class="cov0" title="0">{
                m.gConf.GSL.LadybugCli.TLS = &amp;config.TLSConfig{}
        }</span>

        <span class="cov0" title="0">m.gConf.GSL.LadybugCli.TLS.TLSCA = tlsCAFile
        return nil</span>
}

// GetTLSCA - TLS CA 값 조회
func (m *MCARApi) GetTLSCA() (string, error) <span class="cov0" title="0">{
        if m.gConf.GSL.LadybugCli.TLS == nil </span><span class="cov0" title="0">{
                return "", nil
        }</span>

        <span class="cov0" title="0">return m.gConf.GSL.LadybugCli.TLS.TLSCA, nil</span>
}

// SetTimeout - Timeout 설정
func (m *MCARApi) SetTimeout(timeout time.Duration) error <span class="cov0" title="0">{
        m.gConf.GSL.LadybugCli.Timeout = timeout
        return nil
}</span>

// GetTimeout - Timeout 값 조회
func (m *MCARApi) GetTimeout() (time.Duration, error) <span class="cov0" title="0">{
        return m.gConf.GSL.LadybugCli.Timeout, nil
}</span>

// SetJWTToken - JWT 인증 토큰 설정
func (m *MCARApi) SetJWTToken(token string) error <span class="cov0" title="0">{
        if token == "" </span><span class="cov0" title="0">{
                return errors.New("parameter is empty")
        }</span>

        <span class="cov0" title="0">if m.gConf.GSL.LadybugCli.Interceptors == nil </span><span class="cov0" title="0">{
                m.gConf.GSL.LadybugCli.Interceptors = &amp;config.InterceptorsConfig{}
                m.gConf.GSL.LadybugCli.Interceptors.AuthJWT = &amp;config.AuthJWTConfig{}
        }</span>
        <span class="cov0" title="0">if m.gConf.GSL.LadybugCli.Interceptors.AuthJWT == nil </span><span class="cov0" title="0">{
                m.gConf.GSL.LadybugCli.Interceptors.AuthJWT = &amp;config.AuthJWTConfig{}
        }</span>

        <span class="cov0" title="0">m.gConf.GSL.LadybugCli.Interceptors.AuthJWT.JWTToken = token
        return nil</span>
}

// GetJWTToken - JWT 인증 토큰 값 조회
func (m *MCARApi) GetJWTToken() (string, error) <span class="cov0" title="0">{
        if m.gConf.GSL.LadybugCli.Interceptors == nil </span><span class="cov0" title="0">{
                return "", nil
        }</span>
        <span class="cov0" title="0">if m.gConf.GSL.LadybugCli.Interceptors.AuthJWT == nil </span><span class="cov0" title="0">{
                return "", nil
        }</span>

        <span class="cov0" title="0">return m.gConf.GSL.LadybugCli.Interceptors.AuthJWT.JWTToken, nil</span>
}

// SetConfigPath - 환경설정 파일 설정
func (m *MCARApi) SetConfigPath(configFile string) error <span class="cov8" title="1">{
        logger := logger.NewLogger()

        // Viper 를 사용하는 설정 파서 생성
        parser := config.MakeParser()

        var (
                gConf config.GrpcConfig
                err   error
        )

        if configFile == "" </span><span class="cov0" title="0">{
                logger.Error("Please, provide the path to your configuration file")
                return errors.New("configuration file are not specified")
        }</span>

        <span class="cov8" title="1">logger.Debug("Parsing configuration file: ", configFile)
        if gConf, err = parser.GrpcParse(configFile); err != nil </span><span class="cov0" title="0">{
                logger.Error("ERROR - Parsing the configuration file.\n", err.Error())
                return err
        }</span>

        // LADYBUG CLIENT 필수 입력 항목 체크
        <span class="cov8" title="1">ladybugcli := gConf.GSL.LadybugCli

        if ladybugcli == nil </span><span class="cov0" title="0">{
                return errors.New("ladybugcli field are not specified")
        }</span>

        <span class="cov8" title="1">if ladybugcli.ServerAddr == "" </span><span class="cov0" title="0">{
                return errors.New("ladybugcli.server_addr field are not specified")
        }</span>

        <span class="cov8" title="1">if ladybugcli.Timeout == 0 </span><span class="cov0" title="0">{
                ladybugcli.Timeout = 90 * time.Second
        }</span>

        <span class="cov8" title="1">if ladybugcli.TLS != nil </span><span class="cov0" title="0">{
                if ladybugcli.TLS.TLSCA == "" </span><span class="cov0" title="0">{
                        return errors.New("ladybugcli.tls.tls_ca field are not specified")
                }</span>
        }

        <span class="cov8" title="1">if ladybugcli.Interceptors != nil </span><span class="cov0" title="0">{
                if ladybugcli.Interceptors.AuthJWT != nil </span><span class="cov0" title="0">{
                        if ladybugcli.Interceptors.AuthJWT.JWTToken == "" </span><span class="cov0" title="0">{
                                return errors.New("ladybugcli.interceptors.auth_jwt.jwt_token field are not specified")
                        }</span>
                }
                <span class="cov0" title="0">if ladybugcli.Interceptors.Opentracing != nil </span><span class="cov0" title="0">{
                        if ladybugcli.Interceptors.Opentracing.Jaeger != nil </span><span class="cov0" title="0">{
                                if ladybugcli.Interceptors.Opentracing.Jaeger.Endpoint == "" </span><span class="cov0" title="0">{
                                        return errors.New("ladybugcli.interceptors.opentracing.jaeger.endpoint field are not specified")
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">m.gConf = &amp;gConf
        return nil</span>
}

// Open - 연결 설정
func (m *MCARApi) Open() error <span class="cov8" title="1">{

        ladybugcli := m.gConf.GSL.LadybugCli

        // grpc 커넥션 생성
        cbconn, closer, err := gc.NewCBConnection(ladybugcli)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if closer != nil </span><span class="cov0" title="0">{
                m.jaegerCloser = closer
        }</span>

        <span class="cov8" title="1">m.conn = cbconn.Conn

        // grpc 클라이언트 생성
        m.clientMCAR = pb.NewMCARClient(m.conn)

        // grpc 호출 Wrapper
        m.requestMCAR = &amp;mcar.MCARRequest{Client: m.clientMCAR, Timeout: ladybugcli.Timeout, InType: m.inType, OutType: m.outType}

        return nil</span>
}

// Close - 연결 종료
func (m *MCARApi) Close() <span class="cov8" title="1">{
        if m.conn != nil </span><span class="cov8" title="1">{
                m.conn.Close()
        }</span>
        <span class="cov8" title="1">if m.jaegerCloser != nil </span><span class="cov0" title="0">{
                m.jaegerCloser.Close()
        }</span>

        <span class="cov8" title="1">m.jaegerCloser = nil
        m.conn = nil
        m.clientMCAR = nil
        m.requestMCAR = nil</span>
}

// SetInType - 입력 문서 타입 설정 (json/yaml)
func (m *MCARApi) SetInType(in string) error <span class="cov0" title="0">{
        if in == "json" </span><span class="cov0" title="0">{
                m.inType = in
        }</span> else<span class="cov0" title="0"> if in == "yaml" </span><span class="cov0" title="0">{
                m.inType = in
        }</span> else<span class="cov0" title="0"> {
                return errors.New("input type is not supported")
        }</span>

        <span class="cov0" title="0">if m.requestMCAR != nil </span><span class="cov0" title="0">{
                m.requestMCAR.InType = m.inType
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetInType - 입력 문서 타입 값 조회
func (m *MCARApi) GetInType() (string, error) <span class="cov0" title="0">{
        return m.inType, nil
}</span>

// SetOutType - 출력 문서 타입 설정 (json/yaml)
func (m *MCARApi) SetOutType(out string) error <span class="cov0" title="0">{
        if out == "json" </span><span class="cov0" title="0">{
                m.outType = out
        }</span> else<span class="cov0" title="0"> if out == "yaml" </span><span class="cov0" title="0">{
                m.outType = out
        }</span> else<span class="cov0" title="0"> {
                return errors.New("output type is not supported")
        }</span>

        <span class="cov0" title="0">if m.requestMCAR != nil </span><span class="cov0" title="0">{
                m.requestMCAR.OutType = m.outType
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetOutType - 출력 문서 타입 값 조회
func (m *MCARApi) GetOutType() (string, error) <span class="cov0" title="0">{
        return m.outType, nil
}</span>

// Healthy - 상태확인
func (m *MCARApi) Healthy() (string, error) <span class="cov0" title="0">{
        if m.requestMCAR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov0" title="0">return m.requestMCAR.Healthy()</span>
}

// CreateCluster - Cluster 생성
func (m *MCARApi) CreateCluster(doc string) (string, error) <span class="cov8" title="1">{
        if m.requestMCAR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov8" title="1">m.requestMCAR.InData = doc
        return m.requestMCAR.CreateCluster()</span>
}

// CreateClusterByParam - Cluster 생성
func (m *MCARApi) CreateClusterByParam(req *ClusterCreateRequest) (string, error) <span class="cov0" title="0">{
        if m.requestMCAR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov0" title="0">holdType, _ := m.GetInType()
        m.SetInType("json")
        j, err := json.Marshal(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">m.requestMCAR.InData = string(j)
        result, err := m.requestMCAR.CreateCluster()
        m.SetInType(holdType)

        return result, err</span>
}

// ListCluster - Cluster 목록
func (m *MCARApi) ListCluster(doc string) (string, error) <span class="cov0" title="0">{
        if m.requestMCAR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov0" title="0">m.requestMCAR.InData = doc
        return m.requestMCAR.ListCluster()</span>
}

// ListClusterByParam - Cluster 목록
func (m *MCARApi) ListClusterByParam(namespace string) (string, error) <span class="cov0" title="0">{
        if m.requestMCAR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov0" title="0">holdType, _ := m.GetInType()
        m.SetInType("json")
        m.requestMCAR.InData = `{"namespace":"` + namespace + `"}`
        result, err := m.requestMCAR.ListCluster()
        m.SetInType(holdType)

        return result, err</span>
}

// GetCluster - Cluster 조회
func (m *MCARApi) GetCluster(doc string) (string, error) <span class="cov0" title="0">{
        if m.requestMCAR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov0" title="0">m.requestMCAR.InData = doc
        return m.requestMCAR.GetCluster()</span>
}

// GetClusterByParam - Cluster 조회
func (m *MCARApi) GetClusterByParam(namespace string, cluster string) (string, error) <span class="cov0" title="0">{
        if m.requestMCAR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov0" title="0">holdType, _ := m.GetInType()
        m.SetInType("json")
        m.requestMCAR.InData = `{"namespace":"` + namespace + `", "cluster":"` + cluster + `"}`
        result, err := m.requestMCAR.GetCluster()
        m.SetInType(holdType)

        return result, err</span>
}

// DeleteCluster - Cluster 삭제
func (m *MCARApi) DeleteCluster(doc string) (string, error) <span class="cov0" title="0">{
        if m.requestMCAR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov0" title="0">m.requestMCAR.InData = doc
        return m.requestMCAR.DeleteCluster()</span>
}

// DeleteClusterByParam - Cluster 삭제
func (m *MCARApi) DeleteClusterByParam(namespace string, cluster string) (string, error) <span class="cov0" title="0">{
        if m.requestMCAR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov0" title="0">holdType, _ := m.GetInType()
        m.SetInType("json")
        m.requestMCAR.InData = `{"namespace":"` + namespace + `", "cluster":"` + cluster + `"}`
        result, err := m.requestMCAR.DeleteCluster()
        m.SetInType(holdType)

        return result, err</span>
}

// AddNode - Node 추가
func (m *MCARApi) AddNode(doc string) (string, error) <span class="cov0" title="0">{
        if m.requestMCAR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov0" title="0">m.requestMCAR.InData = doc
        return m.requestMCAR.AddNode()</span>
}

// AddNodeByParam - Node 추가
func (m *MCARApi) AddNodeByParam(req *NodeCreateRequest) (string, error) <span class="cov0" title="0">{
        if m.requestMCAR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov0" title="0">holdType, _ := m.GetInType()
        m.SetInType("json")
        j, err := json.Marshal(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">m.requestMCAR.InData = string(j)
        result, err := m.requestMCAR.AddNode()
        m.SetInType(holdType)

        return result, err</span>
}

// ListNode - Node 목록
func (m *MCARApi) ListNode(doc string) (string, error) <span class="cov0" title="0">{
        if m.requestMCAR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov0" title="0">m.requestMCAR.InData = doc
        return m.requestMCAR.ListNode()</span>
}

// ListNodeByParam - Node 목록
func (m *MCARApi) ListNodeByParam(namespace string, cluster string) (string, error) <span class="cov0" title="0">{
        if m.requestMCAR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov0" title="0">holdType, _ := m.GetInType()
        m.SetInType("json")
        m.requestMCAR.InData = `{"namespace":"` + namespace + `", "cluster":"` + cluster + `"}`
        result, err := m.requestMCAR.ListNode()
        m.SetInType(holdType)

        return result, err</span>
}

// GetNode - Node 조회
func (m *MCARApi) GetNode(doc string) (string, error) <span class="cov0" title="0">{
        if m.requestMCAR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov0" title="0">m.requestMCAR.InData = doc
        return m.requestMCAR.GetNode()</span>
}

// GetNodeByParam - Node 조회
func (m *MCARApi) GetNodeByParam(namespace string, cluster string, node string) (string, error) <span class="cov0" title="0">{
        if m.requestMCAR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov0" title="0">holdType, _ := m.GetInType()
        m.SetInType("json")
        m.requestMCAR.InData = `{"namespace":"` + namespace + `", "cluster":"` + cluster + `", "node":"` + node + `"}`
        result, err := m.requestMCAR.GetNode()
        m.SetInType(holdType)

        return result, err</span>
}

// RemoveNode - Node 삭제
func (m *MCARApi) RemoveNode(doc string) (string, error) <span class="cov0" title="0">{
        if m.requestMCAR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov0" title="0">m.requestMCAR.InData = doc
        return m.requestMCAR.RemoveNode()</span>
}

// RemoveNodeByParam - Node 삭제
func (m *MCARApi) RemoveNodeByParam(namespace string, cluster string, node string) (string, error) <span class="cov0" title="0">{
        if m.requestMCAR == nil </span><span class="cov0" title="0">{
                return "", errors.New("The Open() function must be called")
        }</span>

        <span class="cov0" title="0">holdType, _ := m.GetInType()
        m.SetInType("json")
        m.requestMCAR.InData = `{"namespace":"` + namespace + `", "cluster":"` + cluster + `", "node":"` + node + `"}`
        result, err := m.requestMCAR.RemoveNode()
        m.SetInType(holdType)

        return result, err</span>
}

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====

// NewMCARManager - MCAR API 객체 생성
func NewMCARManager() (m *MCARApi) <span class="cov8" title="1">{

        m = &amp;MCARApi{}
        m.gConf = &amp;config.GrpcConfig{}
        m.gConf.GSL.LadybugCli = &amp;config.GrpcClientConfig{}

        m.jaegerCloser = nil
        m.conn = nil
        m.clientMCAR = nil
        m.requestMCAR = nil

        m.inType = "json"
        m.outType = "json"

        return
}</span>
</pre>
		
		<pre class="file" id="file60" style="display: none">package mcar

import (
        "context"

        gc "github.com/jmleefree/actiontest2/src/grpc-api/common"
        "github.com/jmleefree/actiontest2/src/grpc-api/logger"
        pb "github.com/jmleefree/actiontest2/src/grpc-api/protobuf/cbladybug"

        "github.com/jmleefree/actiontest2/src/core/model"
        "github.com/jmleefree/actiontest2/src/rest-api/service"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// CreateCluster - Cluster 생성
func (s *MCARService) CreateCluster(ctx context.Context, req *pb.ClusterCreateRequest) (*pb.ClusterInfoResponse, error) <span class="cov8" title="1">{
        logger := logger.NewLogger()

        logger.Debug("calling MCARService.CreateCluster()")

        // GRPC 메시지에서 LADYBUG 객체로 복사
        var mcarObj model.ClusterReq
        err := gc.CopySrcToDest(&amp;req.Item, &amp;mcarObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCARService.CreateCluster()")
        }</span>

        <span class="cov8" title="1">s.ClusterReqDef(&amp;mcarObj)

        err = s.ClusterReqValidate(mcarObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCARService.CreateCluster()")
        }</span>

        <span class="cov8" title="1">cluster, err := service.CreateCluster(req.Namespace, &amp;mcarObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCARService.CreateCluster()")
        }</span>

        // LADYBUG 객체에서 GRPC 메시지로 복사
        <span class="cov8" title="1">var grpcObj pb.ClusterInfo
        err = gc.CopySrcToDest(&amp;cluster, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCARService.CreateCluster()")
        }</span>

        <span class="cov8" title="1">resp := &amp;pb.ClusterInfoResponse{Item: &amp;grpcObj}
        return resp, nil</span>
}

// ListCluster - Cluster 목록
func (s *MCARService) ListCluster(ctx context.Context, req *pb.ClusterAllQryRequest) (*pb.ListClusterInfoResponse, error) <span class="cov0" title="0">{
        logger := logger.NewLogger()

        logger.Debug("calling MCARService.ListCluster()")

        clusterList, err := service.ListCluster(req.Namespace)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCARService.ListCluster()")
        }</span>

        // LADYBUG 객체에서 GRPC 메시지로 복사
        <span class="cov0" title="0">var grpcObj pb.ListClusterInfoResponse
        err = gc.CopySrcToDest(&amp;clusterList, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCARService.ListCluster()")
        }</span>

        <span class="cov0" title="0">return &amp;grpcObj, nil</span>
}

// GetCluster - Cluster 조회
func (s *MCARService) GetCluster(ctx context.Context, req *pb.ClusterQryRequest) (*pb.ClusterInfoResponse, error) <span class="cov0" title="0">{
        logger := logger.NewLogger()

        logger.Debug("calling MCARService.GetCluster()")

        if err := s.Validate(map[string]string{"namespace": req.Namespace, "cluster": req.Cluster}); err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCARService.GetCluster()")
        }</span>

        <span class="cov0" title="0">cluster, err := service.GetCluster(req.Namespace, req.Cluster)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCARService.GetCluster()")
        }</span>

        // LADYBUG 객체에서 GRPC 메시지로 복사
        <span class="cov0" title="0">var grpcObj pb.ClusterInfo
        err = gc.CopySrcToDest(&amp;cluster, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCARService.GetCluster()")
        }</span>

        <span class="cov0" title="0">resp := &amp;pb.ClusterInfoResponse{Item: &amp;grpcObj}
        return resp, nil</span>
}

// DeleteCluster - Cluster 삭제
func (s *MCARService) DeleteCluster(ctx context.Context, req *pb.ClusterQryRequest) (*pb.StatusResponse, error) <span class="cov0" title="0">{
        logger := logger.NewLogger()

        logger.Debug("calling MCARService.DeleteCluster()")

        if err := s.Validate(map[string]string{"namespace": req.Namespace, "cluster": req.Cluster}); err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCARService.DeleteCluster()")
        }</span>

        <span class="cov0" title="0">status, err := service.DeleteCluster(req.Namespace, req.Cluster)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCARService.DeleteCluster()")
        }</span>

        // LADYBUG 객체에서 GRPC 메시지로 복사
        <span class="cov0" title="0">var grpcObj pb.StatusResponse
        err = gc.CopySrcToDest(&amp;status, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCARService.DeleteCluster()")
        }</span>

        <span class="cov0" title="0">return &amp;grpcObj, nil</span>
}

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====
</pre>
		
		<pre class="file" id="file61" style="display: none">package mcar

import (
        "context"

        "github.com/jmleefree/actiontest2/src/grpc-api/logger"
        pb "github.com/jmleefree/actiontest2/src/grpc-api/protobuf/cbladybug"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// Healthy - 상태확인
func (s *MCARService) Healthy(ctx context.Context, req *pb.Empty) (*pb.MessageResponse, error) <span class="cov0" title="0">{
        logger := logger.NewLogger()

        logger.Debug("calling MCARService.Healthy()")

        resp := &amp;pb.MessageResponse{Message: "cb-barista cb-ladybug"}
        return resp, nil
}</span>

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====
</pre>
		
		<pre class="file" id="file62" style="display: none">package mcar

import (
        "errors"
        "fmt"

        "github.com/beego/beego/v2/core/validation"
        "github.com/jmleefree/actiontest2/src/core/model"
        "github.com/jmleefree/actiontest2/src/utils/config"
        "github.com/jmleefree/actiontest2/src/utils/lang"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// MCARService - LADYBUG 서비스 구현
type MCARService struct {
}

// ===== [ Implementations ] =====

func (s *MCARService) Validate(params map[string]string) error <span class="cov0" title="0">{
        valid := validation.Validation{}

        for key, element := range params </span><span class="cov0" title="0">{
                valid.Required(element, key)
        }</span>

        <span class="cov0" title="0">if valid.HasErrors() </span><span class="cov0" title="0">{
                for _, err := range valid.Errors </span><span class="cov0" title="0">{
                        return errors.New(fmt.Sprintf("[%s]%s", err.Key, err.Error()))
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (s *MCARService) ClusterReqDef(clusterReq *model.ClusterReq) error <span class="cov8" title="1">{
        clusterReq.Config.Kubernetes.NetworkCni = lang.NVL(clusterReq.Config.Kubernetes.NetworkCni, config.NETWORKCNI_KILO)
        clusterReq.Config.Kubernetes.PodCidr = lang.NVL(clusterReq.Config.Kubernetes.PodCidr, config.POD_CIDR)
        clusterReq.Config.Kubernetes.ServiceCidr = lang.NVL(clusterReq.Config.Kubernetes.ServiceCidr, config.SERVICE_CIDR)
        clusterReq.Config.Kubernetes.ServiceDnsDomain = lang.NVL(clusterReq.Config.Kubernetes.ServiceDnsDomain, config.SERVICE_DOMAIN)

        return nil
}</span>

func (s *MCARService) ClusterReqValidate(req model.ClusterReq) error <span class="cov8" title="1">{
        if len(req.ControlPlane) == 0 </span><span class="cov0" title="0">{
                return errors.New("control plane node count must be one")
        }</span>
        <span class="cov8" title="1">if len(req.Worker) == 0 </span><span class="cov0" title="0">{
                return errors.New("worker node count must be at least one")
        }</span>
        <span class="cov8" title="1">if !(req.Config.Kubernetes.NetworkCni == config.NETWORKCNI_CANAL || req.Config.Kubernetes.NetworkCni == config.NETWORKCNI_KILO) </span><span class="cov0" title="0">{
                return errors.New("network cni allows only Kilo or Canal")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (s *MCARService) NodeReqValidate(req model.NodeReq) error <span class="cov0" title="0">{
        if len(req.ControlPlane) &gt; 0 </span><span class="cov0" title="0">{
                return errors.New("control plane node not supported")
        }</span>
        <span class="cov0" title="0">if len(req.Worker) == 0 </span><span class="cov0" title="0">{
                return errors.New("worker node count must be at least one")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====
</pre>
		
		<pre class="file" id="file63" style="display: none">package mcar

import (
        "context"

        gc "github.com/jmleefree/actiontest2/src/grpc-api/common"
        "github.com/jmleefree/actiontest2/src/grpc-api/logger"
        pb "github.com/jmleefree/actiontest2/src/grpc-api/protobuf/cbladybug"

        "github.com/jmleefree/actiontest2/src/core/model"
        "github.com/jmleefree/actiontest2/src/rest-api/service"
)

// ===== [ Constants and Variables ] =====

// ===== [ Types ] =====

// ===== [ Implementations ] =====

// AddNode - Node 추가
func (s *MCARService) AddNode(ctx context.Context, req *pb.NodeCreateRequest) (*pb.ListNodeInfoResponse, error) <span class="cov0" title="0">{
        logger := logger.NewLogger()

        logger.Debug("calling MCARService.AddNode()")

        if err := s.Validate(map[string]string{"cluster": req.Cluster}); err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCARService.AddNode()")
        }</span>

        // GRPC 메시지에서 LADYBUG 객체로 복사
        <span class="cov0" title="0">var mcarObj model.NodeReq
        err := gc.CopySrcToDest(&amp;req.Item, &amp;mcarObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCARService.AddNode()")
        }</span>

        <span class="cov0" title="0">err = s.NodeReqValidate(mcarObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCARService.AddNode()")
        }</span>

        <span class="cov0" title="0">node, err := service.AddNode(req.Namespace, req.Cluster, &amp;mcarObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCARService.AddNode()")
        }</span>

        // LADYBUG 객체에서 GRPC 메시지로 복사
        <span class="cov0" title="0">var grpcObj pb.ListNodeInfoResponse
        err = gc.CopySrcToDest(&amp;node, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCARService.ListCluster()")
        }</span>

        <span class="cov0" title="0">return &amp;grpcObj, nil</span>
}

// ListNode - Node 목록
func (s *MCARService) ListNode(ctx context.Context, req *pb.NodeAllQryRequest) (*pb.ListNodeInfoResponse, error) <span class="cov0" title="0">{
        logger := logger.NewLogger()

        logger.Debug("calling MCARService.ListNode()")

        if err := s.Validate(map[string]string{"cluster": req.Cluster}); err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCARService.ListNode()")
        }</span>

        <span class="cov0" title="0">nodeList, err := service.ListNode(req.Namespace, req.Cluster)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCARService.ListNode()")
        }</span>

        // LADYBUG 객체에서 GRPC 메시지로 복사
        <span class="cov0" title="0">var grpcObj pb.ListNodeInfoResponse
        err = gc.CopySrcToDest(&amp;nodeList, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCARService.ListNode()")
        }</span>

        <span class="cov0" title="0">return &amp;grpcObj, nil</span>
}

// GetNode - Node 조회
func (s *MCARService) GetNode(ctx context.Context, req *pb.NodeQryRequest) (*pb.NodeInfoResponse, error) <span class="cov0" title="0">{
        logger := logger.NewLogger()

        logger.Debug("calling MCARService.GetNode()")

        if err := s.Validate(map[string]string{"cluster": req.Cluster, "node": req.Node}); err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCARService.GetNode()")
        }</span>

        <span class="cov0" title="0">node, err := service.GetNode(req.Namespace, req.Cluster, req.Node)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCARService.GetNode()")
        }</span>

        // LADYBUG 객체에서 GRPC 메시지로 복사
        <span class="cov0" title="0">var grpcObj pb.NodeInfo
        err = gc.CopySrcToDest(&amp;node, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCARService.GetNode()")
        }</span>

        <span class="cov0" title="0">resp := &amp;pb.NodeInfoResponse{Item: &amp;grpcObj}
        return resp, nil</span>
}

// RemoveNode - Node 삭제
func (s *MCARService) RemoveNode(ctx context.Context, req *pb.NodeQryRequest) (*pb.StatusResponse, error) <span class="cov0" title="0">{
        logger := logger.NewLogger()

        logger.Debug("calling MCARService.RemoveNode()")

        if err := s.Validate(map[string]string{"cluster": req.Cluster, "node": req.Node}); err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCARService.GetNode()")
        }</span>

        <span class="cov0" title="0">status, err := service.RemoveNode(req.Namespace, req.Cluster, req.Node)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCARService.RemoveNode()")
        }</span>

        // LADYBUG 객체에서 GRPC 메시지로 복사
        <span class="cov0" title="0">var grpcObj pb.StatusResponse
        err = gc.CopySrcToDest(&amp;status, &amp;grpcObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, gc.ConvGrpcStatusErr(err, "", "MCARService.RemoveNode()")
        }</span>

        <span class="cov0" title="0">return &amp;grpcObj, nil</span>
}

// ===== [ Private Functions ] =====

// ===== [ Public Functions ] =====
</pre>
		
		<pre class="file" id="file64" style="display: none">package router

import (
        "net/http"
        "time"

        "github.com/jmleefree/actiontest2/src/core/model"
        "github.com/jmleefree/actiontest2/src/rest-api/service"
        "github.com/jmleefree/actiontest2/src/utils/app"
        "github.com/labstack/echo/v4"

        logger "github.com/sirupsen/logrus"
)

// ListCluster
// @Tags Cluster
// @Summary List Cluster
// @Description List Cluster
// @ID ListCluster
// @Accept json
// @Produce json
// @Param        namespace        path        string        true  "namespace"
// @Success 200 {object} model.ClusterList
// @Router /ns/{namespace}/clusters [get]
func ListCluster(c echo.Context) error <span class="cov0" title="0">{
        clusterList, err := service.ListCluster(c.Param("namespace"))
        if err != nil </span><span class="cov0" title="0">{
                logger.Error(err)
                return app.SendMessage(c, http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov0" title="0">return app.Send(c, http.StatusOK, clusterList)</span>
}

// GetCluster
// @Tags Cluster
// @Summary Get Cluster
// @Description Get Cluster
// @ID GetCluster
// @Accept json
// @Produce json
// @Param        namespace        path        string        true  "namespace"
// @Param        cluster        path        string        true  "cluster"
// @Success 200 {object} model.Cluster
// @Router /ns/{namespace}/clusters/{cluster} [get]
func GetCluster(c echo.Context) error <span class="cov0" title="0">{
        if err := app.Validate(c, []string{"namespace", "cluster"}); err != nil </span><span class="cov0" title="0">{
                logger.Error(err)
                return app.SendMessage(c, http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov0" title="0">cluster, err := service.GetCluster(c.Param("namespace"), c.Param("cluster"))
        if err != nil </span><span class="cov0" title="0">{
                logger.Infof("not found a cluster (namespace=%s, cluster=%s, cause=%s)", c.Param("namespace"), c.Param("cluster"), err)
                return app.SendMessage(c, http.StatusNotFound, err.Error())
        }</span>

        <span class="cov0" title="0">return app.Send(c, http.StatusOK, cluster)</span>
}

// CreateCluster
// @Tags Cluster
// @Summary Create Cluster
// @Description Create Cluster
// @ID CreateCluster
// @Accept json
// @Produce json
// @Param        namespace        path        string        true  "namespace"
// @Param json body model.ClusterReq true "Reuest json"
// @Success 200 {object} model.Cluster
// @Router /ns/{namespace}/clusters [post]
func CreateCluster(c echo.Context) error <span class="cov8" title="1">{
        start := time.Now()
        clusterReq := &amp;model.ClusterReq{}
        if err := c.Bind(clusterReq); err != nil </span><span class="cov0" title="0">{
                logger.Error(err)
                return app.SendMessage(c, http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov8" title="1">app.ClusterReqDef(*clusterReq)

        err := app.ClusterReqValidate(*clusterReq)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error(err)
                return app.SendMessage(c, http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov8" title="1">cluster, err := service.CreateCluster(c.Param("namespace"), clusterReq)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error(err)
                return app.SendMessage(c, http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov8" title="1">duration := time.Since(start)
        logger.Info("duration := ", duration)
        return app.Send(c, http.StatusOK, cluster)</span>
}

// DeleteCluster
// @Tags Cluster
// @Summary Delete a cluster
// @Description Delete a cluster
// @ID DeleteCluster
// @Accept json
// @Produce json
// @Param        namespace        path        string        true  "namespace"
// @Param        cluster        path        string        true  "cluster"
// @Success 200 {object} model.Status
// @Router /ns/{namespace}/clusters/{cluster} [delete]
func DeleteCluster(c echo.Context) error <span class="cov0" title="0">{
        if err := app.Validate(c, []string{"namespace", "cluster"}); err != nil </span><span class="cov0" title="0">{
                logger.Error(err)
                return app.SendMessage(c, http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov0" title="0">status, err := service.DeleteCluster(c.Param("namespace"), c.Param("cluster"))
        if err != nil </span><span class="cov0" title="0">{
                logger.Error(err)
                return app.SendMessage(c, http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov0" title="0">return app.Send(c, http.StatusOK, status)</span>
}
</pre>
		
		<pre class="file" id="file65" style="display: none">package router

import (
        "net/http"

        "github.com/labstack/echo/v4"
)

// Healthy Method
// @Tags Default
// @Summary Health Check
// @Description for health check
// @ID Healthy
// @Accept json
// @Produce json
// @Success 200 {string} string "ok"
// @Router /healthy [get]
func Healthy(c echo.Context) error <span class="cov0" title="0">{
        return c.String(http.StatusOK, "cb-barista cb-ladybug")
}</span>
</pre>
		
		<pre class="file" id="file66" style="display: none">package router

import (
        "net/http"
        "time"

        "github.com/jmleefree/actiontest2/src/core/model"
        "github.com/jmleefree/actiontest2/src/rest-api/service"
        "github.com/jmleefree/actiontest2/src/utils/app"

        "github.com/labstack/echo/v4"
        logger "github.com/sirupsen/logrus"
)

// ListNode
// @Tags Node
// @Summary List Node
// @Description List Node
// @ID ListNode
// @Accept json
// @Produce json
// @Param        namespace        path        string        true  "namespace"
// @Param        cluster        path        string        true  "cluster"
// @Success 200 {object} model.NodeList
// @Router /ns/{namespace}/clusters/{cluster}/nodes [get]
func ListNode(c echo.Context) error <span class="cov0" title="0">{
        if err := app.Validate(c, []string{"cluster"}); err != nil </span><span class="cov0" title="0">{
                logger.Error(err)
                return app.SendMessage(c, http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov0" title="0">nodeList, err := service.ListNode(c.Param("namespace"), c.Param("cluster"))
        if err != nil </span><span class="cov0" title="0">{
                logger.Error(err)
                return app.SendMessage(c, http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov0" title="0">return app.Send(c, http.StatusOK, nodeList)</span>
}

// GetNode
// @Tags Node
// @Summary Get Node
// @Description Get Node
// @ID GetNode
// @Accept json
// @Produce json
// @Param        namespace        path        string        true  "namespace"
// @Param        cluster        path        string        true  "cluster"
// @Param        node        path        string        true  "node"
// @Success 200 {object} model.Node
// @Router /ns/{namespace}/clusters/{cluster}/nodes/{node} [get]
func GetNode(c echo.Context) error <span class="cov0" title="0">{
        if err := app.Validate(c, []string{"cluster", "node"}); err != nil </span><span class="cov0" title="0">{
                logger.Error(err)
                return app.SendMessage(c, http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov0" title="0">node, err := service.GetNode(c.Param("namespace"), c.Param("cluster"), c.Param("node"))
        if err != nil </span><span class="cov0" title="0">{
                logger.Infof("not found a node (namespace=%s, cluster=%s, node=%s, cause=%s)", c.Param("namespace"), c.Param("cluster"), c.Param("node"), err)
                return app.SendMessage(c, http.StatusNotFound, err.Error())
        }</span>

        <span class="cov0" title="0">return app.Send(c, http.StatusOK, node)</span>
}

// AddNode
// @Tags Node
// @Summary Add Node
// @Description Add Node
// @ID AddNode
// @Accept json
// @Produce json
// @Param        namespace        path        string        true  "namespace"
// @Param        cluster        path        string        true  "cluster"
// @Param json body model.NodeReq true "Reuest json"
// @Success 200 {object} model.Node
// @Router /ns/{namespace}/clusters/{cluster}/nodes [post]
func AddNode(c echo.Context) error <span class="cov0" title="0">{
        start := time.Now()
        if err := app.Validate(c, []string{"cluster"}); err != nil </span><span class="cov0" title="0">{
                logger.Error(err)
                return app.SendMessage(c, http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov0" title="0">nodeReq := &amp;model.NodeReq{}
        if err := c.Bind(nodeReq); err != nil </span><span class="cov0" title="0">{
                logger.Error(err)
                return app.SendMessage(c, http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov0" title="0">err := app.NodeReqValidate(*nodeReq)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error(err)
                return app.SendMessage(c, http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov0" title="0">node, err := service.AddNode(c.Param("namespace"), c.Param("cluster"), nodeReq)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error(err)
                return app.SendMessage(c, http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov0" title="0">duration := time.Since(start)
        logger.Info(" duration := ", duration)
        return app.Send(c, http.StatusOK, node)</span>
}

// RemoveNode
// @Tags Node
// @Summary Remove Node
// @Description Remove Node
// @ID RemoveNode
// @Accept json
// @Produce json
// @Param        namespace        path        string        true  "namespace"
// @Param        cluster        path        string        true  "cluster"
// @Param        node        path        string        true  "node"
// @Success 200 {object} model.Status
// @Router /ns/{namespace}/clusters/{cluster}/nodes/{node} [delete]
func RemoveNode(c echo.Context) error <span class="cov0" title="0">{
        if err := app.Validate(c, []string{"cluster", "node"}); err != nil </span><span class="cov0" title="0">{
                logger.Error(err)
                return app.SendMessage(c, http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov0" title="0">status, err := service.RemoveNode(c.Param("namespace"), c.Param("cluster"), c.Param("node"))
        if err != nil </span><span class="cov0" title="0">{
                logger.Error(err)
                return app.SendMessage(c, http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov0" title="0">return app.Send(c, http.StatusOK, status)</span>
}
</pre>
		
		<pre class="file" id="file67" style="display: none">package service

import (
        "errors"
        "fmt"
        "sync"

        ssh "github.com/cloud-barista/cb-spider/cloud-control-manager/vm-ssh"
        "github.com/jmleefree/actiontest2/src/core/model"
        "github.com/jmleefree/actiontest2/src/core/model/tumblebug"
        "github.com/jmleefree/actiontest2/src/core/service"
        "github.com/jmleefree/actiontest2/src/utils/config"
        "github.com/jmleefree/actiontest2/src/utils/lang"

        logger "github.com/sirupsen/logrus"
)

func ListCluster(namespace string) (*model.ClusterList, error) <span class="cov0" title="0">{
        clusters := model.NewClusterList(namespace)

        err := clusters.SelectList()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return clusters, nil</span>
}

func GetCluster(namespace string, clusterName string) (*model.Cluster, error) <span class="cov0" title="0">{
        cluster := model.NewCluster(namespace, clusterName)
        err := cluster.Select()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return cluster, nil</span>
}

func CreateCluster(namespace string, req *model.ClusterReq) (*model.Cluster, error) <span class="cov8" title="1">{
        clusterName := req.Name
        cluster := model.NewCluster(namespace, clusterName)
        cluster.UId = lang.GetUid()
        cluster.NetworkCni = req.Config.Kubernetes.NetworkCni
        mcisName := clusterName

        // Namespace 존재여부 확인
        ns := tumblebug.NewNS(namespace)
        exists, err := ns.GET()
        if err != nil </span><span class="cov0" title="0">{
                return cluster, err
        }</span>
        <span class="cov8" title="1">if !exists </span><span class="cov0" title="0">{
                return cluster, errors.New(fmt.Sprintf("namespace does not exist (name=%s)", namespace))
        }</span>

        // MCIS 존재여부 확인
        <span class="cov8" title="1">mcis := tumblebug.NewMCIS(namespace, mcisName)
        exists, err = mcis.GET()
        if err != nil </span><span class="cov0" title="0">{
                return cluster, err
        }</span>
        <span class="cov8" title="1">if exists </span><span class="cov0" title="0">{
                return cluster, errors.New("MCIS already exists")
        }</span>

        <span class="cov8" title="1">var nodeConfigInfos []service.NodeConfigInfo
        // control plane
        cp, err := service.SetNodeConfigInfos(req.ControlPlane, config.CONTROL_PLANE)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">nodeConfigInfos = append(nodeConfigInfos, cp...)

        // worker
        wk, err := service.SetNodeConfigInfos(req.Worker, config.WORKER)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">nodeConfigInfos = append(nodeConfigInfos, wk...)

        cIdx := 0
        wIdx := 0
        var nodes []model.Node

        for _, nodeConfigInfo := range nodeConfigInfos </span><span class="cov8" title="1">{
                // MCIR - 존재하면 재활용 없다면 생성 기준
                // 1. create vpc
                vpc, err := nodeConfigInfo.CreateVPC(namespace, clusterName)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // 2. create firewall
                <span class="cov8" title="1">fw, err := nodeConfigInfo.CreateFirewall(namespace, clusterName)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // 3. create sshKey
                <span class="cov8" title="1">sshKey, err := nodeConfigInfo.CreateSshKey(namespace, clusterName)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // 4. create image
                <span class="cov8" title="1">image, err := nodeConfigInfo.CreateImage(namespace, clusterName)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // 5. create spec
                <span class="cov8" title="1">spec, err := nodeConfigInfo.CreateSpec(namespace, clusterName)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // 6. vm
                <span class="cov8" title="1">for i := 0; i &lt; nodeConfigInfo.Count; i++ </span><span class="cov8" title="1">{
                        if nodeConfigInfo.Role == config.CONTROL_PLANE </span><span class="cov8" title="1">{
                                cIdx++
                        }</span> else<span class="cov8" title="1"> {
                                wIdx++
                        }</span>

                        <span class="cov8" title="1">vm := model.VM{
                                Config:       nodeConfigInfo.Connection,
                                VPC:          vpc.Name,
                                Subnet:       vpc.Subnets[0].Name,
                                Firewall:     []string{fw.Name},
                                SSHKey:       sshKey.Name,
                                Image:        image.Name,
                                Spec:         spec.Name,
                                UserAccount:  nodeConfigInfo.Account,
                                UserPassword: "",
                                Description:  "",
                                Credential:   sshKey.PrivateKey,
                                Role:         nodeConfigInfo.Role,
                                Csp:          nodeConfigInfo.Csp,
                        }

                        if nodeConfigInfo.Role == config.CONTROL_PLANE </span><span class="cov8" title="1">{
                                vm.Name = lang.GetNodeName(clusterName, config.CONTROL_PLANE, cIdx)
                                if cIdx == 1 </span><span class="cov8" title="1">{
                                        vm.IsCPLeader = true
                                        cluster.CpLeader = vm.Name
                                }</span>
                        } else<span class="cov8" title="1"> {
                                vm.Name = lang.GetNodeName(clusterName, config.WORKER, wIdx)
                        }</span>

                        <span class="cov8" title="1">mcis.VMs = append(mcis.VMs, vm)</span>
                }
        }

        // MCIS 생성
        <span class="cov8" title="1">logger.Infof("start create MCIS (name=%s)", mcisName)
        if err = mcis.POST(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">logger.Infof("create MCIS OK.. (name=%s)", mcisName)

        // 결과값 저장
        cluster.MCIS = mcisName
        for _, vm := range mcis.VMs </span><span class="cov8" title="1">{
                node := model.NewNodeVM(namespace, cluster.Name, vm)
                node.UId = lang.GetUid()

                // insert node in store
                nodes = append(nodes, *node)
                err := node.Insert()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">err = cluster.Insert()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var wg sync.WaitGroup
        c := make(chan error)
        wg.Add(len(mcis.VMs))

        // bootstrap
        logger.Infoln("start k8s bootstrap")
        for _, vm := range mcis.VMs </span><span class="cov8" title="1">{
                err = cluster.Update()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">go func(vm model.VM) </span><span class="cov8" title="1">{
                        defer wg.Done()
                        sshInfo := ssh.SSHInfo{
                                UserName:   service.GetUserAccount(vm.Csp),
                                PrivateKey: []byte(vm.Credential),
                                ServerPort: fmt.Sprintf("%s:22", vm.PublicIP),
                        }
                        _ = vm.ConnectionTest(&amp;sshInfo)
                        err := vm.CopyScripts(&amp;sshInfo, cluster.NetworkCni)
                        if err != nil </span><span class="cov0" title="0">{
                                cluster.Fail()
                                c &lt;- err
                        }</span>

                        <span class="cov8" title="1">err = vm.SetSystemd(&amp;sshInfo, cluster.NetworkCni)
                        if err != nil </span><span class="cov0" title="0">{
                                cluster.Fail()
                                c &lt;- err
                        }</span>

                        <span class="cov8" title="1">err = vm.Bootstrap(&amp;sshInfo)
                        if err != nil </span><span class="cov0" title="0">{
                                cluster.Fail()
                                c &lt;- err
                        }</span>
                }(vm)
        }

        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                wg.Wait()
                close(c)
                logger.Infoln("end k8s bootstrap")
        }</span>()

        <span class="cov8" title="1">for err := range c </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        // init &amp; join
        <span class="cov8" title="1">var joinCmd []string
        IPs := service.GetControlPlaneIPs(mcis.VMs)

        logger.Infoln("start k8s init")
        for _, vm := range mcis.VMs </span><span class="cov8" title="1">{
                if vm.Role == config.CONTROL_PLANE &amp;&amp; vm.IsCPLeader </span><span class="cov8" title="1">{
                        sshInfo := ssh.SSHInfo{
                                UserName:   service.GetUserAccount(vm.Csp),
                                PrivateKey: []byte(vm.Credential),
                                ServerPort: fmt.Sprintf("%s:22", vm.PublicIP),
                        }

                        logger.Infoln("install HAProxy")
                        err := vm.InstallHAProxy(&amp;sshInfo, IPs)
                        if err != nil </span><span class="cov0" title="0">{
                                cluster.Fail()
                                return nil, err
                        }</span>

                        <span class="cov8" title="1">logger.Infoln("control plane init")
                        var clusterConfig string
                        joinCmd, clusterConfig, err = vm.ControlPlaneInit(&amp;sshInfo, req.Config.Kubernetes)
                        if err != nil </span><span class="cov0" title="0">{
                                cluster.Fail()
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">cluster.ClusterConfig = clusterConfig

                        logger.Infoln("install networkCNI")
                        err = vm.InstallNetworkCNI(&amp;sshInfo, req.Config.Kubernetes.NetworkCni)
                        if err != nil </span><span class="cov0" title="0">{
                                cluster.Fail()
                                return nil, err
                        }</span>
                }
        }
        <span class="cov8" title="1">logger.Infoln("end k8s init")

        logger.Infoln("start k8s join")
        for _, vm := range mcis.VMs </span><span class="cov8" title="1">{
                sshInfo := ssh.SSHInfo{
                        UserName:   service.GetUserAccount(vm.Csp),
                        PrivateKey: []byte(vm.Credential),
                        ServerPort: fmt.Sprintf("%s:22", vm.PublicIP),
                }

                if vm.Role == config.CONTROL_PLANE </span><span class="cov8" title="1">{
                        if !vm.IsCPLeader </span><span class="cov0" title="0">{
                                logger.Infoln("control plane join")
                                err := vm.ControlPlaneJoin(&amp;sshInfo, &amp;joinCmd[0])
                                if err != nil </span><span class="cov0" title="0">{
                                        cluster.Fail()
                                        return nil, err
                                }</span>
                        }
                } else<span class="cov8" title="1"> {
                        logger.Infoln("worker join")
                        err := vm.WorkerJoin(&amp;sshInfo, &amp;joinCmd[1])
                        if err != nil </span><span class="cov0" title="0">{
                                cluster.Fail()
                                return nil, err
                        }</span>
                }
        }
        <span class="cov8" title="1">logger.Infoln("end k8s join")

        cluster.Complete()
        cluster.Nodes = nodes

        return cluster, nil</span>
}

func DeleteCluster(namespace string, clusterName string) (*model.Status, error) <span class="cov0" title="0">{
        mcisName := clusterName //cluster 이름과 동일하게 (임시)

        status := model.NewStatus()
        status.Code = model.STATUS_UNKNOWN

        // 1. delete mcis
        logger.Infof("start delete MCIS (name=%s)", mcisName)
        mcis := tumblebug.NewMCIS(namespace, mcisName)
        exist, err := mcis.GET()
        if err != nil </span><span class="cov0" title="0">{
                return status, err
        }</span>
        <span class="cov0" title="0">if exist </span><span class="cov0" title="0">{
                if err = mcis.DELETE(); err != nil </span><span class="cov0" title="0">{
                        return status, err
                }</span>
                // sleep 이후 확인하는 로직 추가 필요
                <span class="cov0" title="0">logger.Infof("delete MCIS OK.. (name=%s)", mcisName)
                status.Code = model.STATUS_SUCCESS
                status.Message = "success"

                cluster := model.NewCluster(namespace, clusterName)
                if err := cluster.Delete(); err != nil </span><span class="cov0" title="0">{
                        status.Message = "delete success but cannot delete from the store"
                        return status, nil
                }</span>
        } else<span class="cov0" title="0"> {
                status.Code = model.STATUS_NOT_EXIST
                logger.Infof("delete MCIS skip (cannot find).. (name=%s)", mcisName)
        }</span>

        <span class="cov0" title="0">return status, nil</span>
}
</pre>
		
		<pre class="file" id="file68" style="display: none">package service

import (
        "encoding/json"
        "errors"
        "fmt"
        "strings"
        "sync"

        "github.com/jmleefree/actiontest2/src/core/common"
        "github.com/jmleefree/actiontest2/src/core/model"
        "github.com/jmleefree/actiontest2/src/core/model/tumblebug"
        "github.com/jmleefree/actiontest2/src/core/service"
        "github.com/jmleefree/actiontest2/src/utils/config"
        "github.com/jmleefree/actiontest2/src/utils/lang"

        ssh "github.com/cloud-barista/cb-spider/cloud-control-manager/vm-ssh"
        logger "github.com/sirupsen/logrus"
)

func ListNode(namespace string, clusterName string) (*model.NodeList, error) <span class="cov0" title="0">{
        nodes := model.NewNodeList(namespace, clusterName)
        err := nodes.SelectList()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return nodes, nil</span>
}

func GetNode(namespace string, clusterName string, nodeName string) (*model.Node, error) <span class="cov0" title="0">{
        node := model.NewNode(namespace, clusterName, nodeName)
        err := node.Select()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return node, nil</span>
}

func AddNode(namespace string, clusterName string, req *model.NodeReq) (*model.NodeList, error) <span class="cov0" title="0">{

        mcisName := clusterName
        mcis := tumblebug.NewMCIS(namespace, mcisName)

        exists, err := mcis.GET()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if !exists </span><span class="cov0" title="0">{
                return nil, errors.New("MCIS not found")
        }</span>

        // get join command
        <span class="cov0" title="0">workerJoinCmd, err := getWorkerJoinCmdForAddNode(namespace, clusterName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("join command cannot get")
        }</span>
        <span class="cov0" title="0">networkCni := getClusterNetworkCNI(namespace, clusterName)

        var nodeConfigInfos []service.NodeConfigInfo
        // worker
        wk, err := service.SetNodeConfigInfos(req.Worker, config.WORKER)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">nodeConfigInfos = append(nodeConfigInfos, wk...)

        cIdx := 0
        wIdx := 0
        maxCIdx, maxWIdx := getMaxIdx(namespace, clusterName)
        var TVMs []tumblebug.TVM

        for _, nodeConfigInfo := range nodeConfigInfos </span><span class="cov0" title="0">{
                // MCIR - 존재하면 재활용 없다면 생성 기준
                // 1. create vpc
                vpc, err := nodeConfigInfo.CreateVPC(namespace, clusterName)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // 2. create firewall
                <span class="cov0" title="0">fw, err := nodeConfigInfo.CreateFirewall(namespace, clusterName)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // 3. create sshKey
                <span class="cov0" title="0">sshKey, err := nodeConfigInfo.CreateSshKey(namespace, clusterName)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // 4. create image
                <span class="cov0" title="0">image, err := nodeConfigInfo.CreateImage(namespace, clusterName)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // 5. create spec
                <span class="cov0" title="0">spec, err := nodeConfigInfo.CreateSpec(namespace, clusterName)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // 6. vm
                <span class="cov0" title="0">for i := 0; i &lt; nodeConfigInfo.Count; i++ </span><span class="cov0" title="0">{
                        if nodeConfigInfo.Role == config.CONTROL_PLANE </span><span class="cov0" title="0">{
                                cIdx++
                        }</span> else<span class="cov0" title="0"> {
                                wIdx++
                        }</span>
                        <span class="cov0" title="0">tvm := tumblebug.NewTVm(namespace, mcisName)
                        tvm.VM = model.VM{
                                Config:       nodeConfigInfo.Connection,
                                VPC:          vpc.Name,
                                Subnet:       vpc.Subnets[0].Name,
                                Firewall:     []string{fw.Name},
                                SSHKey:       sshKey.Name,
                                Image:        image.Name,
                                Spec:         spec.Name,
                                UserAccount:  nodeConfigInfo.Account,
                                UserPassword: "",
                                Description:  "",
                                Credential:   sshKey.PrivateKey,
                                Role:         spec.Role,
                                Csp:          nodeConfigInfo.Csp,
                        }

                        if nodeConfigInfo.Role == config.CONTROL_PLANE </span><span class="cov0" title="0">{
                                tvm.VM.Name = lang.GetNodeName(clusterName, config.CONTROL_PLANE, maxCIdx+cIdx)
                        }</span> else<span class="cov0" title="0"> {
                                tvm.VM.Name = lang.GetNodeName(clusterName, config.WORKER, maxWIdx+wIdx)
                        }</span>

                        // vm 생성
                        <span class="cov0" title="0">logger.Infof("start create VM (mcisname=%s, nodename=%s)", mcisName, tvm.VM.Name)
                        err := tvm.POST()
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Warnf("create VM error (mcisname=%s, nodename=%s)", mcisName, tvm.VM.Name)
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">logger.Infof("create VM OK.. (mcisname=%s, nodename=%s)", mcisName, tvm.VM.Name)

                        TVMs = append(TVMs, *tvm)</span>
                }
        }

        <span class="cov0" title="0">var wg sync.WaitGroup
        c := make(chan error)
        wg.Add(len(TVMs))

        logger.Infoln("start connect VMs")
        for _, tvm := range TVMs </span><span class="cov0" title="0">{
                go func(vm model.VM) </span><span class="cov0" title="0">{
                        defer wg.Done()
                        sshInfo := ssh.SSHInfo{
                                UserName:   service.GetUserAccount(vm.Csp),
                                PrivateKey: []byte(vm.Credential),
                                ServerPort: fmt.Sprintf("%s:22", vm.PublicIP),
                        }

                        _ = vm.ConnectionTest(&amp;sshInfo)
                        err := vm.CopyScripts(&amp;sshInfo, networkCni)
                        if err != nil </span><span class="cov0" title="0">{
                                c &lt;- err
                        }</span>

                        <span class="cov0" title="0">logger.Infoln("set systemd service")
                        err = vm.SetSystemd(&amp;sshInfo, networkCni)
                        if err != nil </span><span class="cov0" title="0">{
                                c &lt;- err
                        }</span>

                        <span class="cov0" title="0">logger.Infoln("bootstrap")
                        err = vm.Bootstrap(&amp;sshInfo)
                        if err != nil </span><span class="cov0" title="0">{
                                c &lt;- err
                        }</span>

                        <span class="cov0" title="0">logger.Infoln("join")
                        err = vm.WorkerJoin(&amp;sshInfo, &amp;workerJoinCmd)
                        if err != nil </span><span class="cov0" title="0">{
                                c &lt;- err
                        }</span>
                }(tvm.VM)
        }

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                wg.Wait()
                close(c)
                logger.Infoln("end connect VMs")
        }</span>()

        <span class="cov0" title="0">for err := range c </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        logger.Warnf("worker join error (cause=%v)", err)
                        return nil, err
                }</span>
        }

        // insert store
        <span class="cov0" title="0">nodes := model.NewNodeList(namespace, clusterName)
        for _, vm := range TVMs </span><span class="cov0" title="0">{
                node := model.NewNodeVM(namespace, clusterName, vm.VM)
                err := node.Insert()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">nodes.Items = append(nodes.Items, *node)</span>
        }

        <span class="cov0" title="0">return nodes, nil</span>
}

func RemoveNode(namespace string, clusterName string, nodeName string) (*model.Status, error) <span class="cov0" title="0">{
        status := model.NewStatus()
        status.Code = model.STATUS_UNKNOWN

        cpNode, err := getCPLeaderNode(namespace, clusterName)
        if err != nil </span><span class="cov0" title="0">{
                status.Message = "control-plane node not found"
                return status, err
        }</span>

        <span class="cov0" title="0">hostName, err := getHostName(namespace, clusterName, nodeName)
        if err != nil </span><span class="cov0" title="0">{
                status.Message = "get node name error"
                return status, err
        }</span>

        // drain node
        <span class="cov0" title="0">userAccount := service.GetUserAccount(cpNode.Csp)
        sshInfo := ssh.SSHInfo{
                UserName:   userAccount,
                PrivateKey: []byte(cpNode.Credential),
                ServerPort: fmt.Sprintf("%s:22", cpNode.PublicIP),
        }
        cmd := fmt.Sprintf("sudo kubectl drain %s --kubeconfig=/etc/kubernetes/admin.conf --ignore-daemonsets", hostName)
        result, err := ssh.SSHRun(sshInfo, cmd)
        if err != nil </span><span class="cov0" title="0">{
                status.Message = "kubectl drain failed"
                return status, err
        }</span>
        <span class="cov0" title="0">if strings.Contains(result, fmt.Sprintf("node/%s drained", hostName)) || strings.Contains(result, fmt.Sprintf("node/%s evicted", hostName)) </span><span class="cov0" title="0">{
                logger.Infoln("drain node success")
        }</span> else<span class="cov0" title="0"> {
                status.Message = "kubectl drain failed"
                return status, err
        }</span>

        // delete node
        <span class="cov0" title="0">cmd = fmt.Sprintf("sudo kubectl delete node %s --kubeconfig=/etc/kubernetes/admin.conf", hostName)
        result, err = ssh.SSHRun(sshInfo, cmd)
        if err != nil </span><span class="cov0" title="0">{
                status.Message = "kubectl delete node failed"
                return status, err
        }</span>
        <span class="cov0" title="0">if strings.Contains(result, "deleted") </span><span class="cov0" title="0">{
                logger.Infoln("delete node success")
        }</span> else<span class="cov0" title="0"> {
                status.Message = "kubectl delete node failed"
                return status, errors.New("kubectl delete node failed")
        }</span>

        // delete vm
        <span class="cov0" title="0">vm := tumblebug.NewTVm(namespace, clusterName)
        vm.VM.Name = nodeName
        err = vm.DELETE()
        if err != nil </span><span class="cov0" title="0">{
                status.Message = "delete vm failed"
                return status, err
        }</span>

        // delete node in store
        <span class="cov0" title="0">node := model.NewNode(namespace, clusterName, nodeName)
        if err := node.Delete(); err != nil </span><span class="cov0" title="0">{
                status.Message = err.Error()
                return status, nil
        }</span>

        <span class="cov0" title="0">status.Code = model.STATUS_SUCCESS
        status.Message = "success"

        return status, nil</span>
}

func getCluster(namespace string, clusterName string) (*model.Cluster, error) <span class="cov0" title="0">{
        key := lang.GetStoreClusterKey(namespace, clusterName)
        keyValue, err := common.CBStore.Get(key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if keyValue == nil </span><span class="cov0" title="0">{
                return nil, errors.New(fmt.Sprintf("%s not found", key))
        }</span>
        <span class="cov0" title="0">cluster := &amp;model.Cluster{}
        json.Unmarshal([]byte(keyValue.Value), cluster)

        return cluster, nil</span>
}

func getCPLeaderNode(namespace string, clusterName string) (*model.Node, error) <span class="cov0" title="0">{
        cluster, err := getCluster(namespace, clusterName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("cluster info not found")
        }</span>
        <span class="cov0" title="0">CpLeader := cluster.CpLeader

        key := lang.GetStoreNodeKey(namespace, clusterName, "")
        keyValues, err := common.CBStore.GetList(key, true)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if keyValues == nil </span><span class="cov0" title="0">{
                return nil, errors.New(fmt.Sprintf("%s not found", key))
        }</span>
        <span class="cov0" title="0">cpNode := &amp;model.Node{}
        for _, keyValue := range keyValues </span><span class="cov0" title="0">{
                node := &amp;model.Node{}
                json.Unmarshal([]byte(keyValue.Value), &amp;node)
                if node.Name == CpLeader </span><span class="cov0" title="0">{
                        cpNode = node
                        break</span>
                }
        }

        <span class="cov0" title="0">return cpNode, nil</span>
}

func getClusterNetworkCNI(namespace string, clusterName string) string <span class="cov0" title="0">{
        cluster, err := getCluster(namespace, clusterName)
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">return cluster.NetworkCni</span>
}

func getHostName(namespace string, clusterName string, nodeName string) (string, error) <span class="cov0" title="0">{
        key := lang.GetStoreNodeKey(namespace, clusterName, "")
        keyValues, err := common.CBStore.GetList(key, true)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">if keyValues == nil </span><span class="cov0" title="0">{
                return "", errors.New(fmt.Sprintf("%s not found", key))
        }</span>
        <span class="cov0" title="0">dNode := &amp;model.Node{}
        for _, keyValue := range keyValues </span><span class="cov0" title="0">{
                node := &amp;model.Node{}
                json.Unmarshal([]byte(keyValue.Value), &amp;node)
                if node.Name == nodeName </span><span class="cov0" title="0">{
                        dNode = node
                        break</span>
                }
        }

        <span class="cov0" title="0">if dNode.Csp == config.CSP_GCP </span><span class="cov0" title="0">{
                return nodeName, nil
        }</span>

        <span class="cov0" title="0">userAccount := service.GetUserAccount(dNode.Csp)
        sshInfo := ssh.SSHInfo{
                UserName:   userAccount,
                PrivateKey: []byte(dNode.Credential),
                ServerPort: fmt.Sprintf("%s:22", dNode.PublicIP),
        }
        cmd := "/bin/hostname"
        hostName, err := ssh.SSHRun(sshInfo, cmd)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return hostName, nil</span>
}

func getWorkerJoinCmdForAddNode(namespace string, clusterName string) (string, error) <span class="cov0" title="0">{
        cpNode, err := getCPLeaderNode(namespace, clusterName)
        if err != nil </span><span class="cov0" title="0">{
                return "", errors.New("control-plane node not found")
        }</span>
        <span class="cov0" title="0">userAccount := service.GetUserAccount(cpNode.Csp)
        sshInfo := ssh.SSHInfo{
                UserName:   userAccount,
                PrivateKey: []byte(cpNode.Credential),
                ServerPort: fmt.Sprintf("%s:22", cpNode.PublicIP),
        }
        cmd := "sudo kubeadm token create --print-join-command"
        result, err := ssh.SSHRun(sshInfo, cmd)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return result, nil</span>
}

func getMaxIdx(namespace string, clusterName string) (maxCpIdx int, maxWkIdx int) <span class="cov0" title="0">{
        maxCpIdx = 0
        maxWkIdx = 0

        nodes := model.NewNodeList(namespace, clusterName)
        err := nodes.SelectList()
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">var arrCp, arrWk []int
        for _, node := range nodes.Items </span><span class="cov0" title="0">{
                slice := strings.Split(node.Name, "-")
                role := len(slice) - 3
                idx := len(slice) - 2

                if slice[role] == "c" </span><span class="cov0" title="0">{
                        arrCp = append(arrCp, lang.GetIdxToInt(slice[idx]))
                }</span> else<span class="cov0" title="0"> if slice[role] == "w" </span><span class="cov0" title="0">{
                        arrWk = append(arrWk, lang.GetIdxToInt(slice[idx]))
                }</span>
        }
        <span class="cov0" title="0">fmt.Println(maxCpIdx, maxWkIdx)
        maxCpIdx = lang.GetMaxNumber(arrCp)
        maxWkIdx = lang.GetMaxNumber(arrWk)
        return</span>
}
</pre>
		
		<pre class="file" id="file69" style="display: none">package app

import (
        "errors"
        "fmt"

        "github.com/beego/beego/v2/core/validation"
        "github.com/jmleefree/actiontest2/src/core/model"
        "github.com/jmleefree/actiontest2/src/utils/config"
        "github.com/jmleefree/actiontest2/src/utils/lang"
        "github.com/labstack/echo/v4"
)

type Status struct {
        Message string `json:"message"`
}

func SendMessage(c echo.Context, httpCode int, msg string) error <span class="cov0" title="0">{
        return c.JSON(httpCode, Status{Message: msg})
}</span>

func Send(c echo.Context, httpCode int, json interface{}) error <span class="cov8" title="1">{
        return c.JSON(httpCode, json)
}</span>

func Validate(c echo.Context, params []string) error <span class="cov0" title="0">{
        valid := validation.Validation{}

        for _, name := range params </span><span class="cov0" title="0">{
                valid.Required(c.Param(name), name)
        }</span>

        <span class="cov0" title="0">if valid.HasErrors() </span><span class="cov0" title="0">{
                for _, err := range valid.Errors </span><span class="cov0" title="0">{
                        return errors.New(fmt.Sprintf("[%s]%s", err.Key, err.Error()))
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func ClusterReqDef(clusterReq model.ClusterReq) <span class="cov8" title="1">{
        clusterReq.Config.Kubernetes.NetworkCni = lang.NVL(clusterReq.Config.Kubernetes.NetworkCni, config.NETWORKCNI_KILO)
        clusterReq.Config.Kubernetes.PodCidr = lang.NVL(clusterReq.Config.Kubernetes.PodCidr, config.POD_CIDR)
        clusterReq.Config.Kubernetes.ServiceCidr = lang.NVL(clusterReq.Config.Kubernetes.ServiceCidr, config.SERVICE_CIDR)
        clusterReq.Config.Kubernetes.ServiceDnsDomain = lang.NVL(clusterReq.Config.Kubernetes.ServiceDnsDomain, config.SERVICE_DOMAIN)
}</span>

func ClusterReqValidate(req model.ClusterReq) error <span class="cov8" title="1">{
        if len(req.ControlPlane) == 0 </span><span class="cov0" title="0">{
                return errors.New("control plane node must be at least one")
        }</span>
        <span class="cov8" title="1">if len(req.Worker) == 0 </span><span class="cov0" title="0">{
                return errors.New("worker node must be at least one")
        }</span>
        <span class="cov8" title="1">if !(req.Config.Kubernetes.NetworkCni == config.NETWORKCNI_CANAL || req.Config.Kubernetes.NetworkCni == config.NETWORKCNI_KILO) </span><span class="cov0" title="0">{
                return errors.New("network cni allows only Kilo or Canal")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func NodeReqValidate(req model.NodeReq) error <span class="cov0" title="0">{
        if len(req.ControlPlane) &gt; 0 </span><span class="cov0" title="0">{
                return errors.New("control plane node not supported")
        }</span>
        <span class="cov0" title="0">if len(req.Worker) == 0 </span><span class="cov0" title="0">{
                return errors.New("worker node count must be at least one")
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file70" style="display: none">package app

import (
        "github.com/go-resty/resty/v2"
        "github.com/jmleefree/actiontest2/src/utils/config"
)

func ExecutHTTP(method string, url string, body interface{}, result interface{}) (*resty.Response, error) <span class="cov8" title="1">{

        conf := config.Config

        req := resty.New().SetDisableWarn(true).R().SetBasicAuth(*conf.Username, *conf.Password)

        if body != nil </span><span class="cov8" title="1">{
                req.SetBody(body)
        }</span>
        <span class="cov8" title="1">if result != nil </span><span class="cov8" title="1">{
                req.SetResult(result)
        }</span>

        // execute
        <span class="cov8" title="1">return req.Execute(method, url)</span>

}
</pre>
		
		<pre class="file" id="file71" style="display: none">package config

import (
        "flag"
        "os"

        "github.com/jmleefree/actiontest2/src/utils/lang"
        "github.com/sirupsen/logrus"
        logger "github.com/sirupsen/logrus"
)

type conf struct {
        RunMode      *string
        SpiderUrl    *string
        TumblebugUrl *string
        RootURL      *string
        Username     *string
        Password     *string
        AppRootPath  *string
        LoglevelHTTP *bool
}

var Config = &amp;conf{}

func Setup() <span class="cov0" title="0">{

        var logLevel *string

        Config.AppRootPath = flag.String("app-root", lang.NVL(os.Getenv("APP_ROOT"), ""), "application root path")
        Config.RootURL = flag.String("root-url", lang.NVL(os.Getenv("BASE_URL"), "/ladybug"), "root url")
        Config.SpiderUrl = flag.String("spider-url", lang.NVL(os.Getenv("SPIDER_URL"), "http://localhost:1024/spider"), "cb-spider service end-point url")
        Config.TumblebugUrl = flag.String("tumblebug-url", lang.NVL(os.Getenv("TUMBLEBUG_URL"), "http://localhost:1323/tumblebug"), "cb-tumblebug service end-point url")
        Config.Username = flag.String("basic-auth-username", lang.NVL(os.Getenv("BASIC_AUTH_USERNAME"), "default"), "rest-api basic auth usernmae")
        Config.Password = flag.String("basic-auth-password", lang.NVL(os.Getenv("BASIC_AUTH_PASSWORD"), "default"), "rest-api basic auth password")
        logLevel = flag.String("log-level", lang.NVL(os.Getenv("LOG_LEVEL"), "info"), "The log level")
        Config.LoglevelHTTP = flag.Bool("log-http", os.Getenv("LOG_HTTP") == "true", "The logging http data")

        flag.Parse()

        //logger
        logger.SetFormatter(&amp;logrus.TextFormatter{})
        logger.SetOutput(os.Stderr)

        level, err := logrus.ParseLevel(*logLevel)
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal(err)
        }</span> else<span class="cov0" title="0"> if level != logrus.GetLevel() </span><span class="cov0" title="0">{
                logger.SetLevel(level)
        }</span> else<span class="cov0" title="0"> {
                logger.SetLevel(logrus.InfoLevel)
        }</span>

        // app root path
        <span class="cov0" title="0">if len(*Config.AppRootPath) == 0 </span><span class="cov0" title="0">{
                if pwd, err := os.Getwd(); err == nil </span><span class="cov0" title="0">{
                        Config.AppRootPath = &amp;pwd
                }</span>
        }

}
</pre>
		
		<pre class="file" id="file72" style="display: none">package lang

import (
        "fmt"
        "math/rand"
        "strconv"
        "time"

        "github.com/google/uuid"
)

const (
        // Random string generation
        letterBytes   = "abcdefghijklmnopqrstuvwxyz1234567890"
        letterIdxBits = 6
        letterIdxMask = 1&lt;&lt;letterIdxBits - 1
        letterIdxMax  = 63 / letterIdxBits
)

var (
        // Random source by nano time
        randSrc = rand.NewSource(time.Now().UnixNano())
)

// NVL is null value logic
func NVL(str string, def string) string <span class="cov8" title="1">{
        if len(str) == 0 </span><span class="cov8" title="1">{
                return def
        }</span>
        <span class="cov8" title="1">return str</span>
}

// get store cluster key
func GetStoreClusterKey(namespace string, clusterName string) string <span class="cov8" title="1">{
        if clusterName == "" </span><span class="cov0" title="0">{
                return fmt.Sprintf("/ns/%s/clusters", namespace)
        }</span> else<span class="cov8" title="1"> {
                return fmt.Sprintf("/ns/%s/clusters/%s", namespace, clusterName)
        }</span>
}

// get store node key
func GetStoreNodeKey(namespace string, clusterName string, nodeName string) string <span class="cov8" title="1">{
        if nodeName == "" </span><span class="cov0" title="0">{
                return fmt.Sprintf("/ns/%s/clusters/%s/nodes", namespace, clusterName)
        }</span> else<span class="cov8" title="1"> {
                return fmt.Sprintf("/ns/%s/clusters/%s/nodes/%s", namespace, clusterName, nodeName)
        }</span>
}

// get uuid
func GetUid() string <span class="cov8" title="1">{
        return uuid.New().String()
}</span>

// Random string generation
func GetRandomString(n int) string <span class="cov8" title="1">{
        b := make([]byte, n)
        for i, cache, remain := n-1, randSrc.Int63(), letterIdxMax; i &gt;= 0; </span><span class="cov8" title="1">{
                if remain == 0 </span><span class="cov0" title="0">{
                        cache, remain = randSrc.Int63(), letterIdxMax
                }</span>
                <span class="cov8" title="1">if idx := int(cache &amp; letterIdxMask); idx &lt; len(letterBytes) </span><span class="cov8" title="1">{
                        b[i] = letterBytes[idx]
                        i--
                }</span>
                <span class="cov8" title="1">cache &gt;&gt;= letterIdxBits
                remain--</span>
        }
        <span class="cov8" title="1">return string(b)</span>
}

// get node name
func GetNodeName(clusterName string, role string, idx int) string <span class="cov8" title="1">{
        return fmt.Sprintf("%s-%s-%d-%s", clusterName, role[:1], idx, GetRandomString(5))
}</span>

func GetIdxToInt(idx string) int <span class="cov0" title="0">{
        i, err := strconv.Atoi(idx)
        if err != nil </span><span class="cov0" title="0">{
                i = 0
        }</span>
        <span class="cov0" title="0">return i</span>
}

func GetMaxNumber(arr []int) int <span class="cov0" title="0">{
        max := 0
        for _, val := range arr </span><span class="cov0" title="0">{
                if val &gt; max </span><span class="cov0" title="0">{
                        max = val
                }</span>
        }
        <span class="cov0" title="0">return max</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
